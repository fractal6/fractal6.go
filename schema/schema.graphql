
directive @hook_addLabelInput on ARGUMENT_DEFINITION
directive @hook_addLabel on FIELD_DEFINITION
directive @hook_updateLabelInput on ARGUMENT_DEFINITION
directive @hook_updateLabel on FIELD_DEFINITION
directive @hook_deleteLabelInput on ARGUMENT_DEFINITION
directive @hook_deleteLabel on FIELD_DEFINITION
directive @hook_addRoleExtInput on ARGUMENT_DEFINITION
directive @hook_addRoleExt on FIELD_DEFINITION
directive @hook_updateRoleExtInput on ARGUMENT_DEFINITION
directive @hook_updateRoleExt on FIELD_DEFINITION
directive @hook_deleteRoleExtInput on ARGUMENT_DEFINITION
directive @hook_deleteRoleExt on FIELD_DEFINITION
directive @hook_addProjectInput on ARGUMENT_DEFINITION
directive @hook_addProject on FIELD_DEFINITION
directive @hook_updateProjectInput on ARGUMENT_DEFINITION
directive @hook_updateProject on FIELD_DEFINITION
directive @hook_deleteProjectInput on ARGUMENT_DEFINITION
directive @hook_deleteProject on FIELD_DEFINITION
directive @hook_addTensionInput on ARGUMENT_DEFINITION
directive @hook_addTension on FIELD_DEFINITION
directive @hook_updateTensionInput on ARGUMENT_DEFINITION
directive @hook_updateTension on FIELD_DEFINITION
directive @hook_deleteTensionInput on ARGUMENT_DEFINITION
directive @hook_deleteTension on FIELD_DEFINITION
directive @hook_addCommentInput on ARGUMENT_DEFINITION
directive @hook_addComment on FIELD_DEFINITION
directive @hook_updateCommentInput on ARGUMENT_DEFINITION
directive @hook_updateComment on FIELD_DEFINITION
directive @hook_deleteCommentInput on ARGUMENT_DEFINITION
directive @hook_deleteComment on FIELD_DEFINITION
directive @hook_addReactionInput on ARGUMENT_DEFINITION
directive @hook_addReaction on FIELD_DEFINITION
directive @hook_updateReactionInput on ARGUMENT_DEFINITION
directive @hook_updateReaction on FIELD_DEFINITION
directive @hook_deleteReactionInput on ARGUMENT_DEFINITION
directive @hook_deleteReaction on FIELD_DEFINITION
directive @hook_addContractInput on ARGUMENT_DEFINITION
directive @hook_addContract on FIELD_DEFINITION
directive @hook_updateContractInput on ARGUMENT_DEFINITION
directive @hook_updateContract on FIELD_DEFINITION
directive @hook_deleteContractInput on ARGUMENT_DEFINITION
directive @hook_deleteContract on FIELD_DEFINITION
directive @hook_addVoteInput on ARGUMENT_DEFINITION
directive @hook_addVote on FIELD_DEFINITION
directive @hook_updateVoteInput on ARGUMENT_DEFINITION
directive @hook_updateVote on FIELD_DEFINITION
directive @hook_deleteVoteInput on ARGUMENT_DEFINITION
directive @hook_deleteVote on FIELD_DEFINITION
directive @hook_addUserInput on ARGUMENT_DEFINITION
directive @hook_addUser on FIELD_DEFINITION
directive @hook_updateUserInput on ARGUMENT_DEFINITION
directive @hook_updateUser on FIELD_DEFINITION
directive @hook_deleteUserInput on ARGUMENT_DEFINITION
directive @hook_deleteUser on FIELD_DEFINITION
directive @hook_getLabelInput on ARGUMENT_DEFINITION
directive @hook_queryLabelInput on ARGUMENT_DEFINITION
directive @hook_getRoleExtInput on ARGUMENT_DEFINITION
directive @hook_queryRoleExtInput on ARGUMENT_DEFINITION
directive @hook_getProjectInput on ARGUMENT_DEFINITION
directive @hook_queryProjectInput on ARGUMENT_DEFINITION
directive @hook_getTensionInput on ARGUMENT_DEFINITION
directive @hook_queryTensionInput on ARGUMENT_DEFINITION
directive @hook_getCommentInput on ARGUMENT_DEFINITION
directive @hook_queryCommentInput on ARGUMENT_DEFINITION
directive @hook_getReactionInput on ARGUMENT_DEFINITION
directive @hook_queryReactionInput on ARGUMENT_DEFINITION
directive @hook_getContractInput on ARGUMENT_DEFINITION
directive @hook_queryContractInput on ARGUMENT_DEFINITION
directive @hook_getVoteInput on ARGUMENT_DEFINITION
directive @hook_queryVoteInput on ARGUMENT_DEFINITION
directive @hook_getUserInput on ARGUMENT_DEFINITION
directive @hook_queryUserInput on ARGUMENT_DEFINITION


directive @hidden on FIELD_DEFINITION

directive @private on FIELD_DEFINITION

directive @meta(f: String!, k: String) on FIELD_DEFINITION

directive @isContractValidator on FIELD_DEFINITION

directive @x_add(r: String, f: String, e: [TensionEvent!], n: Int) on INPUT_FIELD_DEFINITION

directive @x_set(r: String, f: String, e: [TensionEvent!], n: Int) on INPUT_FIELD_DEFINITION

directive @x_remove(r: String, f: String, e: [TensionEvent!], n: Int) on INPUT_FIELD_DEFINITION

directive @x_patch(r: String, f: String, e: [TensionEvent!], n: Int) on INPUT_FIELD_DEFINITION

directive @x_alter(r: String, f: String, e: [TensionEvent!], n: Int) on INPUT_FIELD_DEFINITION

directive @x_patch_ro on INPUT_FIELD_DEFINITION

directive @x_ro on INPUT_FIELD_DEFINITION

directive @w_add(a: String!) on INPUT_FIELD_DEFINITION

directive @w_set(a: String!) on INPUT_FIELD_DEFINITION

directive @w_remove(a: String!) on INPUT_FIELD_DEFINITION

directive @w_patch(a: String!) on INPUT_FIELD_DEFINITION

directive @w_alter(a: String!) on INPUT_FIELD_DEFINITION

directive @w_meta_patch(f: String!, k: String) on INPUT_FIELD_DEFINITION

type Node {
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime
  nameid: String!
  rootnameid: String!
  source(filter: BlobFilter): Blob
  name: String!
  about: String
  skills: [String!]
  isRoot: Boolean!
  parent(filter: NodeFilter): Node
  type_: NodeType!
  tensions_out(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension!]
  tensions_in(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension!]
  visibility: NodeVisibility!
  mode: NodeMode!
  rights: Int!
  isArchived: Boolean!
  isPersonal: Boolean
  userCanJoin: Boolean
  guestCanCreateTension: Boolean
  watchers(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User!]
  children(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node!]
  labels(filter: LabelFilter, order: LabelOrder, first: Int, offset: Int): [Label!]
  roles(filter: RoleExtFilter, order: RoleExtOrder, first: Int, offset: Int): [RoleExt!]
  projects(filter: ProjectFilter, order: ProjectOrder, first: Int, offset: Int): [Project!]
  pinned(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension!]
  role_ext(filter: RoleExtFilter): RoleExt
  role_type: RoleType
  color: String
  first_link(filter: UserFilter): User
  second_link(filter: UserFilter): User
  contracts(filter: VoteFilter, order: VoteOrder, first: Int, offset: Int): [Vote!]
  orga_agg(filter: OrgaAggFilter): OrgaAgg @meta(f:"getOrgaAgg", k:"nameid")
  events_history(filter: EventFilter, order: EventOrder, first: Int, offset: Int): [Event!] @meta(f:"getNodeHistory", k:"nameid")
  n_open_contracts: Int @meta(f:"count_open_contracts_from_node", k:"nameid")

  tensions_outAggregate(filter: TensionFilter): TensionAggregateResult
  tensions_inAggregate(filter: TensionFilter): TensionAggregateResult
  watchersAggregate(filter: UserFilter): UserAggregateResult
  childrenAggregate(filter: NodeFilter): NodeAggregateResult
  labelsAggregate(filter: LabelFilter): LabelAggregateResult
  rolesAggregate(filter: RoleExtFilter): RoleExtAggregateResult
  projectsAggregate(filter: ProjectFilter): ProjectAggregateResult
  pinnedAggregate(filter: TensionFilter): TensionAggregateResult
  contractsAggregate(filter: VoteFilter): VoteAggregateResult
  events_historyAggregate(filter: EventFilter): EventAggregateResult
}

type NodeFragment {
  id: ID!
  nameid: String
  name: String
  about: String
  mandate(filter: MandateFilter): Mandate
  skills: [String!]
  visibility: NodeVisibility
  mode: NodeMode
  type_: NodeType
  first_link: String
  second_link: String
  role_ext: String
  role_type: RoleType
  color: String
}

type Mandate {
  id: ID!
  purpose: String!
  responsabilities: String
  domains: String
  policies: String
}

type Label {
  id: ID!
  rootnameid: String!
  name: String!
  description: String
  color: String
  tensions(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension!]
  nodes(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node!]

  tensionsAggregate(filter: TensionFilter): TensionAggregateResult
  nodesAggregate(filter: NodeFilter): NodeAggregateResult
}

type RoleExt {
  id: ID!
  rootnameid: String!
  name: String!
  about: String
  role_type: RoleType!
  color: String
  mandate(filter: MandateFilter): Mandate
  roles(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node!]
  nodes(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node!]

  rolesAggregate(filter: NodeFilter): NodeAggregateResult
  nodesAggregate(filter: NodeFilter): NodeAggregateResult
}

type Project {
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime!
  rootnameid: String!
  parentnameid: String!
  nameid: String!
  name: String!
  description: String
  status: ProjectStatus!
  columns(filter: ProjectColumnFilter, order: ProjectColumnOrder, first: Int, offset: Int): [ProjectColumn!]
  leaders(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node!]
  nodes(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node!]

  columnsAggregate(filter: ProjectColumnFilter): ProjectColumnAggregateResult
  leadersAggregate(filter: NodeFilter): NodeAggregateResult
  nodesAggregate(filter: NodeFilter): NodeAggregateResult
}

type ProjectTension {
  id: ID!
  tension(filter: TensionFilter): Tension!
  pos: Int!
  pc(filter: ProjectColumnFilter): ProjectColumn!
}

type ProjectColumn {
  id: ID!
  name: String!
  about: String
  pos: Int!
  tensions(filter: ProjectTensionFilter, order: ProjectTensionOrder, first: Int, offset: Int): [ProjectTension!]
  project(filter: ProjectFilter): Project!

  tensionsAggregate(filter: ProjectTensionFilter): ProjectTensionAggregateResult
}

type OrgaAgg {
  n_members: Int
  n_guests: Int
}

type Post {
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime
  message: String
}

type Tension {
  emitter(filter: NodeFilter): Node!
  emitterid: String!
  receiver(filter: NodeFilter): Node!
  receiverid: String!
  title: String!
  type_: TensionType!
  status: TensionStatus!
  action: TensionAction
  assignees(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User!]
  labels(filter: LabelFilter, order: LabelOrder, first: Int, offset: Int): [Label!]
  comments(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment!]
  blobs(filter: BlobFilter, order: BlobOrder, first: Int, offset: Int): [Blob!]
  history(filter: EventFilter, order: EventOrder, first: Int, offset: Int): [Event!]
  mentions(filter: EventFilter, order: EventOrder, first: Int, offset: Int): [Event!]
  contracts(filter: ContractFilter, order: ContractOrder, first: Int, offset: Int): [Contract!]
  subscribers(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User!]
  projects(filter: ProjectTensionFilter, order: ProjectTensionOrder, first: Int, offset: Int): [ProjectTension!]
  n_open_contracts: Int @meta(f:"count_open_contracts_from_tension", k:"id")
  n_comments: Int
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime
  message: String

  assigneesAggregate(filter: UserFilter): UserAggregateResult
  labelsAggregate(filter: LabelFilter): LabelAggregateResult
  commentsAggregate(filter: CommentFilter): CommentAggregateResult
  blobsAggregate(filter: BlobFilter): BlobAggregateResult
  historyAggregate(filter: EventFilter): EventAggregateResult
  mentionsAggregate(filter: EventFilter): EventAggregateResult
  contractsAggregate(filter: ContractFilter): ContractAggregateResult
  subscribersAggregate(filter: UserFilter): UserAggregateResult
  projectsAggregate(filter: ProjectTensionFilter): ProjectTensionAggregateResult
}

type Comment {
  message: String!
  reactions(filter: ReactionFilter, order: ReactionOrder, first: Int, offset: Int): [Reaction!]
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime

  reactionsAggregate(filter: ReactionFilter): ReactionAggregateResult
}

type Reaction {
  id: ID!
  reactionid: String!
  user(filter: UserFilter): User!
  comment(filter: CommentFilter): Comment!
  type_: Int!
}

type Blob {
  tension(filter: TensionFilter): Tension!
  blob_type: BlobType!
  pushedFlag: DateTime
  archivedFlag: DateTime
  node(filter: NodeFragmentFilter): NodeFragment
  md: String
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime
  message: String
}

type Event {
  tension(filter: TensionFilter): Tension!
  event_type: TensionEvent!
  mentioned(filter: TensionFilter): Tension
  old: String
  new: String
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime
  message: String
}

type EventFragment {
  event_type: TensionEvent!
  old: String
  new: String
}

type Contract {
  contractid: String!
  tension(filter: TensionFilter): Tension!
  status: ContractStatus!
  contract_type: ContractType!
  closedAt: DateTime
  event(filter: EventFragmentFilter): EventFragment!
  participants(filter: VoteFilter, order: VoteOrder, first: Int, offset: Int): [Vote!]!
  candidates(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User!]
  pending_candidates(filter: PendingUserFilter, order: PendingUserOrder, first: Int, offset: Int): [PendingUser!]
  comments(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment!]
  isValidator: Boolean @isContractValidator
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime
  message: String

  participantsAggregate(filter: VoteFilter): VoteAggregateResult
  candidatesAggregate(filter: UserFilter): UserAggregateResult
  pending_candidatesAggregate(filter: PendingUserFilter): PendingUserAggregateResult
  commentsAggregate(filter: CommentFilter): CommentAggregateResult
}

type Vote {
  voteid: String!
  contract(filter: ContractFilter): Contract!
  node(filter: NodeFilter): Node!
  data: [Int!]!
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime
  message: String
}

type User {
  id: ID!
  createdAt: DateTime!
  lastAck: DateTime!
  username: String!
  name: String
  email: String! @private
  password: String! @hidden
  bio: String
  location: String
  utc: String
  links: [String!]
  skills: [String!]
  notifyByEmail: Boolean!
  lang: Lang!
  subscriptions(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension!] @private
  watching(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node!] @private
  rights(filter: UserRightsFilter): UserRights!
  roles(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node!]
  backed_roles(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node!]
  tensions_created(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension!] @private
  tensions_assigned(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension!] @private
  contracts(filter: ContractFilter, order: ContractOrder, first: Int, offset: Int): [Contract!] @private
  reactions(filter: ReactionFilter, order: ReactionOrder, first: Int, offset: Int): [Reaction!]
  events(filter: UserEventFilter, order: UserEventOrder, first: Int, offset: Int): [UserEvent!] @private
  markAllAsRead: String
  event_count(filter: EventCountFilter): EventCount @meta(f:"getEventCount", k:"username")

  subscriptionsAggregate(filter: TensionFilter): TensionAggregateResult
  watchingAggregate(filter: NodeFilter): NodeAggregateResult
  rolesAggregate(filter: NodeFilter): NodeAggregateResult
  backed_rolesAggregate(filter: NodeFilter): NodeAggregateResult
  tensions_createdAggregate(filter: TensionFilter): TensionAggregateResult
  tensions_assignedAggregate(filter: TensionFilter): TensionAggregateResult
  contractsAggregate(filter: ContractFilter): ContractAggregateResult
  reactionsAggregate(filter: ReactionFilter): ReactionAggregateResult
  eventsAggregate(filter: UserEventFilter): UserEventAggregateResult
}

type PendingUser {
  id: ID!
  updatedAt: DateTime
  username: String!
  password: String @hidden
  email: String! @hidden
  email_token: String @hidden
  token: String @hidden
  contracts(filter: ContractFilter, order: ContractOrder, first: Int, offset: Int): [Contract!]
  subscribe: Boolean

  contractsAggregate(filter: ContractFilter): ContractAggregateResult
}

type UserRights {
  type_: UserType!
  canLogin: Boolean!
  canCreateRoot: Boolean!
  maxPublicOrga: Int!
  maxPrivateOrga: Int!
  hasEmailNotifications: Boolean!
}

type UserEvent {
  id: ID!
  createdAt: DateTime!
  isRead: Boolean!
  user(filter: UserFilter): User!
  event(filter: EventKindFilter, first: Int, offset: Int): [EventKind!]
}

union EventKind= Event| Contract| Notif

type Notif {
  tension_(filter: TensionFilter): Tension
  contract(filter: ContractFilter): Contract
  link: String
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime
  message: String
}

type EventCount {
  unread_events: Int
  pending_contracts: Int
  assigned_tensions: Int
}

enum NodeType {
  Circle
  Role
}

enum RoleType {


  Owner

  Member

  Guest

  Retired

  Pending


  Coordinator

  Peer

  Bot

}

enum NodeVisibility {
  Public

  Private

  Secret

}

enum NodeMode {
  Coordinated

  Agile

}

enum TensionStatus {
  Open
  Closed
}

enum TensionType {
  Operational
  Governance
  Help
  Alert
  Announcement

}

enum TensionAction {

  NewRole
  NewCircle
  NewMd

  EditRole
  EditCircle
  EditMd

  ArchivedRole
  ArchivedCircle
  ArchivedMd




}

enum TensionEvent {

  Created
  Reopened
  Closed
  TitleUpdated
  TypeUpdated
  CommentPushed
  AssigneeAdded
  AssigneeRemoved
  LabelAdded
  LabelRemoved
  BlobCreated
  BlobCommitted
  Mentioned
  Pinned
  Unpinned

  BlobPushed
  BlobArchived
  BlobUnarchived
  UserJoined
  UserLeft
  MemberLinked
  MemberUnlinked
  Authority
  Visibility
  Moved
}

enum BlobType {

  OnNode
  OnAbout
  OnMandate
  OnAboutAndMandate

  OnDoc

}

enum ProjectStatus {
  Open
  Closed
}

enum ContractStatus {
  Open
  Closed
  Canceled
}

enum ContractType {


  AnyCoordoDual

  AnyCandidates


  AnyCoordoSource

  AnyCoordoTarget
}

enum UserType {
  Regular

  Pro

  Root

}

enum Lang {
  EN
  FR
}

# Dgraph.Authorization {"Header":"X-Frac6-Auth","Namespace":"https://fractale.co/jwt/claims","Algo":"RS256","VerificationKey":"-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqfBbJAanlwf2mYlBszBA\nxgHw3hTu6gZ9nmej+5fCCdyA85IXhw14+F14o+vLogPe/giFuPMpG9eCOPWKvL/T\nGyahW5Lm8TRB4Pf54fZq5+VKdf5/i9u2e8CelpFvT+zLRdBmNVy9H9MitOF9mSGK\nHviPH1nHzU6TGvuVf44s60LAKliiwagALF+T/3ReDFhoqdLb1J3w4JkxFO6Guw5p\n3aDT+RMjjz9W8XpT3+k8IHocWxcEsuWMKdhuNwOHX2l7yU+/yLOrK1nuAMH7KewC\nCT4gJOan1qFO8NKe37jeQgsuRbhtF5C+L6CKs3n+B2A3ZOYB4gzdJfMLXxW/wwr1\nRQIDAQAB\n-----END PUBLIC KEY-----"}

directive @lambdaOnMutate(add: Boolean, update: Boolean, delete: Boolean) on OBJECT|INTERFACE

directive @id on FIELD_DEFINITION

directive @auth(password: AuthRule, query: AuthRule, add: AuthRule, update: AuthRule, delete: AuthRule) on OBJECT|INTERFACE

directive @custom(http: CustomHTTP, dql: String) on FIELD_DEFINITION

directive @hasInverse(field: String!) on FIELD_DEFINITION

directive @cascade(fields: [String]) on FIELD

directive @dgraph(type: String, pred: String) on OBJECT|INTERFACE|FIELD_DEFINITION

directive @withSubscription on OBJECT|INTERFACE|FIELD_DEFINITION

directive @lambda on FIELD_DEFINITION

directive @remoteResponse(name: String) on FIELD_DEFINITION

directive @cacheControl(maxAge: Int!) on QUERY

directive @generate(query: GenerateQueryParams, mutation: GenerateMutationParams, subscription: Boolean) on OBJECT|INTERFACE

directive @search(by: [DgraphIndex!]) on FIELD_DEFINITION

directive @secret(field: String!, pred: String) on OBJECT|INTERFACE

directive @remote on OBJECT|INTERFACE|UNION|INPUT_OBJECT|ENUM

input AddBlobInput {
  createdBy: UserRef!
  createdAt: DateTime!
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String
  tension: TensionRef! @x_add(r:"ref")
  blob_type: BlobType!
  pushedFlag: DateTime
  archivedFlag: DateTime
  node: NodeFragmentRef
  md: String
}

type AddBlobPayload {
  blob(filter: BlobFilter, order: BlobOrder, first: Int, offset: Int): [Blob]
  numUids: Int
}

input AddCommentInput {
  createdBy: UserRef!
  createdAt: DateTime!
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String
  reactions: [ReactionRef!]
}

type AddCommentPayload {
  comment(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment]
  numUids: Int
}

input AddContractInput {
  createdBy: UserRef!
  createdAt: DateTime!
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String
  contractid: String!
  tension: TensionRef! @x_add(r:"ref")
  status: ContractStatus!
  contract_type: ContractType!
  closedAt: DateTime
  event: EventFragmentRef!
  participants: [VoteRef!]!
  candidates: [UserRef!]
  pending_candidates: [PendingUserRef!]
  comments: [CommentRef!] @x_alter(r:"oneByOne")
  isValidator: Boolean
}

type AddContractPayload {
  contract(filter: ContractFilter, order: ContractOrder, first: Int, offset: Int): [Contract]
  numUids: Int
}

input AddEventCountInput {
  unread_events: Int
  pending_contracts: Int
  assigned_tensions: Int
}

type AddEventCountPayload {
  eventCount(filter: EventCountFilter, order: EventCountOrder, first: Int, offset: Int): [EventCount]
  numUids: Int
}

input AddEventFragmentInput {
  event_type: TensionEvent!
  old: String
  new: String
}

type AddEventFragmentPayload {
  eventFragment(filter: EventFragmentFilter, order: EventFragmentOrder, first: Int, offset: Int): [EventFragment]
  numUids: Int
}

input AddEventInput {
  createdBy: UserRef!
  createdAt: DateTime!
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String
  tension: TensionRef! @x_add(r:"ref")
  event_type: TensionEvent!
  mentioned: TensionRef @x_add(r:"ref")
  old: String
  new: String
}

type AddEventPayload {
  event(filter: EventFilter, order: EventOrder, first: Int, offset: Int): [Event]
  numUids: Int
}

input AddLabelInput {
  rootnameid: String!
  name: String! @w_alter(a:"lower") @x_alter(r:"unique", f:"rootnameid") @x_alter(r:"minLen", n:1)
  description: String @x_alter(r:"maxLen", n:280)
  color: String
  tensions: [TensionRef!]
  nodes: [NodeRef!] @x_alter(r:"oneByOne") @x_alter(r:"ref")
}

type AddLabelPayload {
  label(filter: LabelFilter, order: LabelOrder, first: Int, offset: Int): [Label]
  numUids: Int
}

input AddMandateInput {
  purpose: String!
  responsabilities: String
  domains: String
  policies: String
}

type AddMandatePayload {
  mandate(filter: MandateFilter, order: MandateOrder, first: Int, offset: Int): [Mandate]
  numUids: Int
}

input AddNodeFragmentInput {
  nameid: String @w_add(a:"lower")
  name: String @x_alter(r:"minLen", n:1)
  about: String @x_alter(r:"maxLen", n:280)
  mandate: MandateRef
  skills: [String!]
  visibility: NodeVisibility
  mode: NodeMode
  type_: NodeType
  first_link: String
  second_link: String
  role_ext: String
  role_type: RoleType
  color: String
}

type AddNodeFragmentPayload {
  nodeFragment(filter: NodeFragmentFilter, order: NodeFragmentOrder, first: Int, offset: Int): [NodeFragment]
  numUids: Int
}

input AddNodeInput {
  createdBy: UserRef!
  createdAt: DateTime!
  updatedAt: DateTime
  nameid: String!
  rootnameid: String!
  source: BlobRef
  name: String!
  about: String
  skills: [String!]
  isRoot: Boolean!
  parent: NodeRef
  type_: NodeType!
  tensions_out: [TensionRef!]
  tensions_in: [TensionRef!]
  visibility: NodeVisibility!
  mode: NodeMode!
  rights: Int!
  isArchived: Boolean!
  isPersonal: Boolean
  userCanJoin: Boolean
  guestCanCreateTension: Boolean
  watchers: [UserRef!]
  children: [NodeRef!]
  labels: [LabelRef!]
  roles: [RoleExtRef!]
  projects: [ProjectRef!]
  pinned: [TensionRef!] @x_add(r:"ref")
  role_ext: RoleExtRef
  role_type: RoleType
  color: String
  first_link: UserRef
  second_link: UserRef
  contracts: [VoteRef!]
  orga_agg: OrgaAggRef
  events_history: [EventRef!]
  n_open_contracts: Int
}

type AddNodePayload {
  node(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node]
  numUids: Int
}

input AddNotifInput {
  createdBy: UserRef!
  createdAt: DateTime!
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String
  tension_: TensionRef
  contract: ContractRef
  link: String
}

type AddNotifPayload {
  notif(filter: NotifFilter, order: NotifOrder, first: Int, offset: Int): [Notif]
  numUids: Int
}

input AddOrgaAggInput {
  n_members: Int
  n_guests: Int
}

type AddOrgaAggPayload {
  orgaAgg(filter: OrgaAggFilter, order: OrgaAggOrder, first: Int, offset: Int): [OrgaAgg]
  numUids: Int
}

input AddPendingUserInput {
  updatedAt: DateTime
  username: String! @w_alter(a:"lower")
  password: String
  email: String! @w_alter(a:"lower")
  email_token: String
  token: String
  contracts: [ContractRef!]
  subscribe: Boolean
}

type AddPendingUserPayload {
  pendingUser(filter: PendingUserFilter, order: PendingUserOrder, first: Int, offset: Int): [PendingUser]
  numUids: Int
}

input AddProjectColumnInput {
  name: String!
  about: String
  pos: Int!
  tensions: [ProjectTensionRef!]
  project: ProjectRef!
}

type AddProjectColumnPayload {
  projectColumn(filter: ProjectColumnFilter, order: ProjectColumnOrder, first: Int, offset: Int): [ProjectColumn]
  numUids: Int
}

input AddProjectInput {
  createdBy: UserRef!
  createdAt: DateTime!
  updatedAt: DateTime!
  rootnameid: String!
  parentnameid: String!
  nameid: String! @w_alter(a:"lower") @x_alter(r:"unique", f:"parentnameid") @x_alter(r:"minLen", n:1)
  name: String! @x_alter(r:"maxLen", n:100)
  description: String @x_alter(r:"maxLen", n:280)
  status: ProjectStatus!
  columns: [ProjectColumnRef!]
  leaders: [NodeRef!] @x_alter(r:"ref")
  nodes: [NodeRef!] @x_alter(r:"oneByOne") @x_alter(r:"ref")
}

type AddProjectPayload {
  project(filter: ProjectFilter, order: ProjectOrder, first: Int, offset: Int): [Project]
  numUids: Int
}

input AddProjectTensionInput {
  tension: TensionRef! @x_alter(r:"ref")
  pos: Int!
  pc: ProjectColumnRef!
}

type AddProjectTensionPayload {
  projectTension(filter: ProjectTensionFilter, order: ProjectTensionOrder, first: Int, offset: Int): [ProjectTension]
  numUids: Int
}

input AddReactionInput {
  reactionid: String!
  user: UserRef! @x_add(r:"ref")
  comment: CommentRef! @x_add(r:"ref")
  type_: Int!
}

type AddReactionPayload {
  reaction(filter: ReactionFilter, order: ReactionOrder, first: Int, offset: Int): [Reaction]
  numUids: Int
}

input AddRoleExtInput {
  rootnameid: String!
  name: String! @w_alter(a:"lower") @x_alter(r:"unique", f:"rootnameid") @x_alter(r:"minLen", n:1)
  about: String @x_alter(r:"maxLen", n:280)
  role_type: RoleType!
  color: String
  mandate: MandateRef
  roles: [NodeRef!]
  nodes: [NodeRef!] @x_alter(r:"oneByOne") @x_alter(r:"ref")
}

type AddRoleExtPayload {
  roleExt(filter: RoleExtFilter, order: RoleExtOrder, first: Int, offset: Int): [RoleExt]
  numUids: Int
}

input AddTensionInput {
  createdBy: UserRef!
  createdAt: DateTime!
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String
  emitter: NodeRef!
  emitterid: String!
  receiver: NodeRef!
  receiverid: String!
  title: String!
  type_: TensionType! @x_alter(r:"tensionTypeCheck")
  status: TensionStatus!
  action: TensionAction
  assignees: [UserRef!] @x_alter(r:"hasEvent", e:[AssigneeAdded, AssigneeRemoved]) @x_alter(r:"ref")
  labels: [LabelRef!] @x_alter(r:"hasEvent", e:[LabelAdded, LabelRemoved]) @x_alter(r:"ref")
  comments: [CommentRef!] @x_alter(r:"hasEvent", e:[Created, CommentPushed]) @x_alter(r:"oneByOne")
  blobs: [BlobRef!] @x_alter(r:"hasEvent", e:[BlobCreated, BlobCommitted]) @x_alter(r:"oneByOne")
  history: [EventRef!]
  mentions: [EventRef!]
  contracts: [ContractRef!] @x_add(r:"ref")
  subscribers: [UserRef!] @x_add(r:"ref")
  projects: [ProjectTensionRef!] @x_add(r:"ref")
  n_open_contracts: Int
  n_comments: Int
}

type AddTensionPayload {
  tension(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension]
  numUids: Int
}

input AddUserEventInput {
  createdAt: DateTime!
  isRead: Boolean!
  user: UserRef!
  event: [EventKindRef!] @x_add(r:"ref")
}

type AddUserEventPayload {
  userEvent(filter: UserEventFilter, order: UserEventOrder, first: Int, offset: Int): [UserEvent]
  numUids: Int
}

input AddUserInput {
  createdAt: DateTime!
  lastAck: DateTime!
  username: String! @w_add(a:"lower")
  name: String
  email: String! @w_add(a:"lower")
  password: String!
  bio: String @x_alter(r:"maxLen", n:280)
  location: String
  utc: String
  links: [String!]
  skills: [String!]
  notifyByEmail: Boolean!
  lang: Lang!
  subscriptions: [TensionRef!] @x_alter(r:"ref")
  watching: [NodeRef!] @x_alter(r:"ref")
  rights: UserRightsRef!
  roles: [NodeRef!] @x_add(r:"ref")
  backed_roles: [NodeRef!] @x_add(r:"ref")
  tensions_created: [TensionRef!] @x_add(r:"ref")
  tensions_assigned: [TensionRef!] @x_add(r:"ref")
  contracts: [ContractRef!] @x_add(r:"ref")
  reactions: [ReactionRef!]
  events: [UserEventRef!]
  markAllAsRead: String
  event_count: EventCountRef
}

type AddUserPayload {
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  numUids: Int
}

input AddUserRightsInput {
  type_: UserType!
  canLogin: Boolean!
  canCreateRoot: Boolean!
  maxPublicOrga: Int!
  maxPrivateOrga: Int!
  hasEmailNotifications: Boolean!
}

type AddUserRightsPayload {
  userRights(filter: UserRightsFilter, order: UserRightsOrder, first: Int, offset: Int): [UserRights]
  numUids: Int
}

input AddVoteInput {
  createdBy: UserRef!
  createdAt: DateTime!
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String
  voteid: String!
  contract: ContractRef! @x_add(r:"ref")
  node: NodeRef! @x_add(r:"ref")
  data: [Int!]!
}

type AddVotePayload {
  vote(filter: VoteFilter, order: VoteOrder, first: Int, offset: Int): [Vote]
  numUids: Int
}

input AuthRule {
  and: [AuthRule]
  or: [AuthRule]
  not: AuthRule
  rule: String
}

type BlobAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  messageMin: String
  messageMax: String
  pushedFlagMin: DateTime
  pushedFlagMax: DateTime
  archivedFlagMin: DateTime
  archivedFlagMax: DateTime
  mdMin: String
  mdMax: String
}

input BlobFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  blob_type: BlobType_hash
  pushedFlag: DateTimeFilter
  archivedFlag: DateTimeFilter
  has: [BlobHasFilter]
  and: [BlobFilter]
  or: [BlobFilter]
  not: BlobFilter
}

enum BlobHasFilter {
  createdBy
  createdAt
  updatedAt
  message
  tension
  blob_type
  pushedFlag
  archivedFlag
  node
  md
}

input BlobOrder {
  asc: BlobOrderable
  desc: BlobOrderable
  then: BlobOrder
}

enum BlobOrderable {
  createdAt
  updatedAt
  message
  pushedFlag
  archivedFlag
  md
}

input BlobPatch {
  createdBy: UserRef @x_patch_ro
  createdAt: DateTime @x_patch_ro
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_patch_ro
  tension: TensionRef @x_patch_ro
  blob_type: BlobType @x_patch_ro
  pushedFlag: DateTime @x_patch_ro
  archivedFlag: DateTime @x_patch_ro
  node: NodeFragmentRef @x_patch_ro
  md: String @x_patch_ro
}

input BlobRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String
  tension: TensionRef @x_add(r:"ref")
  blob_type: BlobType
  pushedFlag: DateTime
  archivedFlag: DateTime
  node: NodeFragmentRef
  md: String
}

input BlobType_hash {
  eq: BlobType
  in: [BlobType]
}

type CommentAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  messageMin: String
  messageMax: String
}

input CommentFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  has: [CommentHasFilter]
  and: [CommentFilter]
  or: [CommentFilter]
  not: CommentFilter
}

enum CommentHasFilter {
  createdBy
  createdAt
  updatedAt
  message
  reactions
}

input CommentOrder {
  asc: CommentOrderable
  desc: CommentOrderable
  then: CommentOrder
}

enum CommentOrderable {
  createdAt
  updatedAt
  message
}

input CommentPatch {
  createdBy: UserRef @x_patch_ro
  createdAt: DateTime @x_patch_ro
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_alter
  reactions: [ReactionRef!] @x_patch_ro
}

input CommentRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_alter
  reactions: [ReactionRef!]
}

input ContainsFilter {
  point: PointRef
  polygon: PolygonRef
}

type ContractAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  messageMin: String
  messageMax: String
  contractidMin: String
  contractidMax: String
  closedAtMin: DateTime
  closedAtMax: DateTime
}

input ContractFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  contractid: StringHashFilter
  status: ContractStatus_hash
  contract_type: ContractType_hash
  closedAt: DateTimeFilter
  has: [ContractHasFilter]
  and: [ContractFilter]
  or: [ContractFilter]
  not: ContractFilter
}

enum ContractHasFilter {
  createdBy
  createdAt
  updatedAt
  message
  contractid
  tension
  status
  contract_type
  closedAt
  event
  participants
  candidates
  pending_candidates
  comments
  isValidator
}

input ContractOrder {
  asc: ContractOrderable
  desc: ContractOrderable
  then: ContractOrder
}

enum ContractOrderable {
  createdAt
  updatedAt
  message
  contractid
  closedAt
}

input ContractPatch {
  createdBy: UserRef @x_patch_ro
  createdAt: DateTime @x_patch_ro
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_patch_ro
  tension: TensionRef @x_patch_ro
  status: ContractStatus @x_patch_ro
  contract_type: ContractType @x_patch_ro
  closedAt: DateTime @x_patch_ro
  event: EventFragmentRef @x_patch_ro
  participants: [VoteRef!] @x_patch_ro
  candidates: [UserRef!] @x_patch_ro
  pending_candidates: [PendingUserRef!] @x_patch_ro
  comments: [CommentRef!] @x_alter(r:"oneByOne")
  isValidator: Boolean @x_patch_ro
}

input ContractRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String
  contractid: String
  tension: TensionRef @x_add(r:"ref")
  status: ContractStatus
  contract_type: ContractType
  closedAt: DateTime
  event: EventFragmentRef
  participants: [VoteRef!]
  candidates: [UserRef!]
  pending_candidates: [PendingUserRef!]
  comments: [CommentRef!] @x_alter(r:"oneByOne")
  isValidator: Boolean
}

input ContractStatus_hash {
  eq: ContractStatus
  in: [ContractStatus]
}

input ContractType_hash {
  eq: ContractType
  in: [ContractType]
}

input CustomHTTP {
  url: String!
  method: HTTPMethod!
  body: String
  graphql: String
  mode: Mode
  forwardHeaders: [String!]
  secretHeaders: [String!]
  introspectionHeaders: [String!]
  skipIntrospection: Boolean
}

scalar DateTime

input DateTimeFilter {
  eq: DateTime
  in: [DateTime]
  le: DateTime
  lt: DateTime
  ge: DateTime
  gt: DateTime
  between: DateTimeRange
}

input DateTimeRange {
  min: DateTime!
  max: DateTime!
}

type DeleteBlobPayload {
  blob(filter: BlobFilter, order: BlobOrder, first: Int, offset: Int): [Blob]
  msg: String
  numUids: Int
}

type DeleteCommentPayload {
  comment(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment]
  msg: String
  numUids: Int
}

type DeleteContractPayload {
  contract(filter: ContractFilter, order: ContractOrder, first: Int, offset: Int): [Contract]
  msg: String
  numUids: Int
}

type DeleteEventCountPayload {
  eventCount(filter: EventCountFilter, order: EventCountOrder, first: Int, offset: Int): [EventCount]
  msg: String
  numUids: Int
}

type DeleteEventFragmentPayload {
  eventFragment(filter: EventFragmentFilter, order: EventFragmentOrder, first: Int, offset: Int): [EventFragment]
  msg: String
  numUids: Int
}

type DeleteEventPayload {
  event(filter: EventFilter, order: EventOrder, first: Int, offset: Int): [Event]
  msg: String
  numUids: Int
}

type DeleteLabelPayload {
  label(filter: LabelFilter, order: LabelOrder, first: Int, offset: Int): [Label]
  msg: String
  numUids: Int
}

type DeleteMandatePayload {
  mandate(filter: MandateFilter, order: MandateOrder, first: Int, offset: Int): [Mandate]
  msg: String
  numUids: Int
}

type DeleteNodeFragmentPayload {
  nodeFragment(filter: NodeFragmentFilter, order: NodeFragmentOrder, first: Int, offset: Int): [NodeFragment]
  msg: String
  numUids: Int
}

type DeleteNodePayload {
  node(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node]
  msg: String
  numUids: Int
}

type DeleteNotifPayload {
  notif(filter: NotifFilter, order: NotifOrder, first: Int, offset: Int): [Notif]
  msg: String
  numUids: Int
}

type DeleteOrgaAggPayload {
  orgaAgg(filter: OrgaAggFilter, order: OrgaAggOrder, first: Int, offset: Int): [OrgaAgg]
  msg: String
  numUids: Int
}

type DeletePendingUserPayload {
  pendingUser(filter: PendingUserFilter, order: PendingUserOrder, first: Int, offset: Int): [PendingUser]
  msg: String
  numUids: Int
}

type DeletePostPayload {
  post(filter: PostFilter, order: PostOrder, first: Int, offset: Int): [Post]
  msg: String
  numUids: Int
}

type DeleteProjectColumnPayload {
  projectColumn(filter: ProjectColumnFilter, order: ProjectColumnOrder, first: Int, offset: Int): [ProjectColumn]
  msg: String
  numUids: Int
}

type DeleteProjectPayload {
  project(filter: ProjectFilter, order: ProjectOrder, first: Int, offset: Int): [Project]
  msg: String
  numUids: Int
}

type DeleteProjectTensionPayload {
  projectTension(filter: ProjectTensionFilter, order: ProjectTensionOrder, first: Int, offset: Int): [ProjectTension]
  msg: String
  numUids: Int
}

type DeleteReactionPayload {
  reaction(filter: ReactionFilter, order: ReactionOrder, first: Int, offset: Int): [Reaction]
  msg: String
  numUids: Int
}

type DeleteRoleExtPayload {
  roleExt(filter: RoleExtFilter, order: RoleExtOrder, first: Int, offset: Int): [RoleExt]
  msg: String
  numUids: Int
}

type DeleteTensionPayload {
  tension(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension]
  msg: String
  numUids: Int
}

type DeleteUserEventPayload {
  userEvent(filter: UserEventFilter, order: UserEventOrder, first: Int, offset: Int): [UserEvent]
  msg: String
  numUids: Int
}

type DeleteUserPayload {
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  msg: String
  numUids: Int
}

type DeleteUserRightsPayload {
  userRights(filter: UserRightsFilter, order: UserRightsOrder, first: Int, offset: Int): [UserRights]
  msg: String
  numUids: Int
}

type DeleteVotePayload {
  vote(filter: VoteFilter, order: VoteOrder, first: Int, offset: Int): [Vote]
  msg: String
  numUids: Int
}

enum DgraphIndex {
  int
  int64
  float
  bool
  hash
  exact
  term
  fulltext
  trigram
  regexp
  year
  month
  day
  hour
  geo
}

enum ErrorBla {
  ContactCoordo
  OrgaLimitReached
  MemberLimitReached
  EmailLimitReached
  StorageLimitReached
}

type EventAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  messageMin: String
  messageMax: String
  oldMin: String
  oldMax: String
  newMin: String
  newMax: String
}

type EventCountAggregateResult {
  count: Int
  unread_eventsMin: Int
  unread_eventsMax: Int
  unread_eventsSum: Int
  unread_eventsAvg: Float
  pending_contractsMin: Int
  pending_contractsMax: Int
  pending_contractsSum: Int
  pending_contractsAvg: Float
  assigned_tensionsMin: Int
  assigned_tensionsMax: Int
  assigned_tensionsSum: Int
  assigned_tensionsAvg: Float
}

input EventCountFilter {
  has: [EventCountHasFilter]
  and: [EventCountFilter]
  or: [EventCountFilter]
  not: EventCountFilter
}

enum EventCountHasFilter {
  unread_events
  pending_contracts
  assigned_tensions
}

input EventCountOrder {
  asc: EventCountOrderable
  desc: EventCountOrderable
  then: EventCountOrder
}

enum EventCountOrderable {
  unread_events
  pending_contracts
  assigned_tensions
}

input EventCountPatch {
  unread_events: Int @x_patch_ro
  pending_contracts: Int @x_patch_ro
  assigned_tensions: Int @x_patch_ro
}

input EventCountRef {
  unread_events: Int
  pending_contracts: Int
  assigned_tensions: Int
}

input EventFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  event_type: TensionEvent_hash
  has: [EventHasFilter]
  and: [EventFilter]
  or: [EventFilter]
  not: EventFilter
}

type EventFragmentAggregateResult {
  count: Int
  oldMin: String
  oldMax: String
  newMin: String
  newMax: String
}

input EventFragmentFilter {
  event_type: TensionEvent_hash
  has: [EventFragmentHasFilter]
  and: [EventFragmentFilter]
  or: [EventFragmentFilter]
  not: EventFragmentFilter
}

enum EventFragmentHasFilter {
  event_type
  old
  new
}

input EventFragmentOrder {
  asc: EventFragmentOrderable
  desc: EventFragmentOrderable
  then: EventFragmentOrder
}

enum EventFragmentOrderable {
  old
  new
}

input EventFragmentPatch {
  event_type: TensionEvent @x_patch_ro
  old: String @x_patch_ro
  new: String @x_patch_ro
}

input EventFragmentRef {
  event_type: TensionEvent
  old: String
  new: String
}

enum EventHasFilter {
  createdBy
  createdAt
  updatedAt
  message
  tension
  event_type
  mentioned
  old
  new
}

input EventKindFilter {
  memberTypes: [EventKindType!]
  eventFilter: EventFilter
  contractFilter: ContractFilter
  notifFilter: NotifFilter
}

input EventKindRef {
  eventRef: EventRef
  contractRef: ContractRef
  notifRef: NotifRef
}

enum EventKindType {
  Event
  Contract
  Notif
}

input EventOrder {
  asc: EventOrderable
  desc: EventOrderable
  then: EventOrder
}

enum EventOrderable {
  createdAt
  updatedAt
  message
  old
  new
}

input EventPatch {
  createdBy: UserRef @x_patch_ro
  createdAt: DateTime @x_patch_ro
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_patch_ro
  tension: TensionRef @x_patch_ro
  event_type: TensionEvent @x_patch_ro
  mentioned: TensionRef @x_patch_ro
  old: String @x_patch_ro
  new: String @x_patch_ro
}

input EventRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String
  tension: TensionRef @x_add(r:"ref")
  event_type: TensionEvent
  mentioned: TensionRef @x_add(r:"ref")
  old: String
  new: String
}

input FloatFilter {
  eq: Float
  in: [Float]
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: FloatRange
}

input FloatRange {
  min: Float!
  max: Float!
}

input GenerateMutationParams {
  add: Boolean
  update: Boolean
  delete: Boolean
}

input GenerateQueryParams {
  get: Boolean
  query: Boolean
  password: Boolean
  aggregate: Boolean
}

enum HTTPMethod {
  GET
  POST
  PUT
  PATCH
  DELETE
}

scalar Int64

input Int64Filter {
  eq: Int64
  in: [Int64]
  le: Int64
  lt: Int64
  ge: Int64
  gt: Int64
  between: Int64Range
}

input Int64Range {
  min: Int64!
  max: Int64!
}

input IntersectsFilter {
  polygon: PolygonRef
  multiPolygon: MultiPolygonRef
}

input IntFilter {
  eq: Int
  in: [Int]
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: IntRange
}

input IntRange {
  min: Int!
  max: Int!
}

type LabelAggregateResult {
  count: Int
  rootnameidMin: String
  rootnameidMax: String
  nameMin: String
  nameMax: String
  descriptionMin: String
  descriptionMax: String
  colorMin: String
  colorMax: String
}

input LabelFilter {
  id: [ID!]
  rootnameid: StringHashFilter
  name: StringHashFilter_StringTermFilter @w_alter(a:"lower")
  has: [LabelHasFilter]
  and: [LabelFilter]
  or: [LabelFilter]
  not: LabelFilter
}

enum LabelHasFilter {
  rootnameid
  name
  description
  color
  tensions
  nodes
}

input LabelOrder {
  asc: LabelOrderable
  desc: LabelOrderable
  then: LabelOrder
}

enum LabelOrderable {
  rootnameid
  name
  description
  color
}

input LabelPatch {
  rootnameid: String @x_patch_ro
  name: String @w_alter(a:"lower") @x_alter(r:"unique", f:"rootnameid") @x_alter(r:"minLen", n:1)
  description: String @x_alter(r:"maxLen", n:280)
  color: String @x_alter
  tensions: [TensionRef!] @x_ro
  nodes: [NodeRef!] @x_alter(r:"oneByOne") @x_alter(r:"ref")
}

input LabelRef {
  id: ID
  rootnameid: String
  name: String @w_alter(a:"lower") @x_alter(r:"unique", f:"rootnameid") @x_alter(r:"minLen", n:1)
  description: String @x_alter(r:"maxLen", n:280)
  color: String @x_alter
  tensions: [TensionRef!] @x_ro
  nodes: [NodeRef!] @x_alter(r:"oneByOne") @x_alter(r:"ref")
}

type MandateAggregateResult {
  count: Int
  purposeMin: String
  purposeMax: String
  responsabilitiesMin: String
  responsabilitiesMax: String
  domainsMin: String
  domainsMax: String
  policiesMin: String
  policiesMax: String
}

input MandateFilter {
  id: [ID!]
  purpose: StringFullTextFilter
  has: [MandateHasFilter]
  and: [MandateFilter]
  or: [MandateFilter]
  not: MandateFilter
}

enum MandateHasFilter {
  purpose
  responsabilities
  domains
  policies
}

input MandateOrder {
  asc: MandateOrderable
  desc: MandateOrderable
  then: MandateOrder
}

enum MandateOrderable {
  purpose
  responsabilities
  domains
  policies
}

input MandatePatch {
  purpose: String @x_alter
  responsabilities: String @x_alter
  domains: String @x_alter
  policies: String @x_alter
}

input MandateRef {
  id: ID
  purpose: String @x_alter
  responsabilities: String @x_alter
  domains: String @x_alter
  policies: String @x_alter
}

enum Mode {
  BATCH
  SINGLE
}

type MultiPolygon {
  polygons: [Polygon!]!
}

input MultiPolygonRef {
  polygons: [PolygonRef!]!
}

type Mutation {
  addNode(input: [AddNodeInput!]!, upsert: Boolean): AddNodePayload
  updateNode(input: UpdateNodeInput!): UpdateNodePayload
  deleteNode(filter: NodeFilter!): DeleteNodePayload
  addNodeFragment(input: [AddNodeFragmentInput!]!): AddNodeFragmentPayload
  updateNodeFragment(input: UpdateNodeFragmentInput!): UpdateNodeFragmentPayload
  deleteNodeFragment(filter: NodeFragmentFilter!): DeleteNodeFragmentPayload
  addMandate(input: [AddMandateInput!]!): AddMandatePayload
  updateMandate(input: UpdateMandateInput!): UpdateMandatePayload
  deleteMandate(filter: MandateFilter!): DeleteMandatePayload
  addLabel(input: [AddLabelInput!]! @hook_addLabelInput): AddLabelPayload @hook_addLabel
  updateLabel(input: UpdateLabelInput! @hook_updateLabelInput): UpdateLabelPayload @hook_updateLabel
  deleteLabel(filter: LabelFilter! @hook_deleteLabelInput): DeleteLabelPayload @hook_deleteLabel
  addRoleExt(input: [AddRoleExtInput!]! @hook_addRoleExtInput): AddRoleExtPayload @hook_addRoleExt
  updateRoleExt(input: UpdateRoleExtInput! @hook_updateRoleExtInput): UpdateRoleExtPayload @hook_updateRoleExt
  deleteRoleExt(filter: RoleExtFilter! @hook_deleteRoleExtInput): DeleteRoleExtPayload @hook_deleteRoleExt
  addProject(input: [AddProjectInput!]! @hook_addProjectInput): AddProjectPayload @hook_addProject
  updateProject(input: UpdateProjectInput! @hook_updateProjectInput): UpdateProjectPayload @hook_updateProject
  deleteProject(filter: ProjectFilter! @hook_deleteProjectInput): DeleteProjectPayload @hook_deleteProject
  addProjectTension(input: [AddProjectTensionInput!]!): AddProjectTensionPayload
  updateProjectTension(input: UpdateProjectTensionInput!): UpdateProjectTensionPayload
  deleteProjectTension(filter: ProjectTensionFilter!): DeleteProjectTensionPayload
  addProjectColumn(input: [AddProjectColumnInput!]!, upsert: Boolean): AddProjectColumnPayload
  updateProjectColumn(input: UpdateProjectColumnInput!): UpdateProjectColumnPayload
  deleteProjectColumn(filter: ProjectColumnFilter!): DeleteProjectColumnPayload
  addOrgaAgg(input: [AddOrgaAggInput!]!): AddOrgaAggPayload
  updateOrgaAgg(input: UpdateOrgaAggInput!): UpdateOrgaAggPayload
  deleteOrgaAgg(filter: OrgaAggFilter!): DeleteOrgaAggPayload
  updatePost(input: UpdatePostInput!): UpdatePostPayload
  deletePost(filter: PostFilter!): DeletePostPayload
  addTension(input: [AddTensionInput!]! @hook_addTensionInput): AddTensionPayload @hook_addTension
  updateTension(input: UpdateTensionInput! @hook_updateTensionInput): UpdateTensionPayload @hook_updateTension
  deleteTension(filter: TensionFilter! @hook_deleteTensionInput): DeleteTensionPayload @hook_deleteTension
  addComment(input: [AddCommentInput!]! @hook_addCommentInput): AddCommentPayload @hook_addComment
  updateComment(input: UpdateCommentInput! @hook_updateCommentInput): UpdateCommentPayload @hook_updateComment
  deleteComment(filter: CommentFilter! @hook_deleteCommentInput): DeleteCommentPayload @hook_deleteComment
  addReaction(input: [AddReactionInput!]! @hook_addReactionInput, upsert: Boolean): AddReactionPayload @hook_addReaction
  updateReaction(input: UpdateReactionInput! @hook_updateReactionInput): UpdateReactionPayload @hook_updateReaction
  deleteReaction(filter: ReactionFilter! @hook_deleteReactionInput): DeleteReactionPayload @hook_deleteReaction
  addBlob(input: [AddBlobInput!]!): AddBlobPayload
  updateBlob(input: UpdateBlobInput!): UpdateBlobPayload
  deleteBlob(filter: BlobFilter!): DeleteBlobPayload
  addEvent(input: [AddEventInput!]!): AddEventPayload
  updateEvent(input: UpdateEventInput!): UpdateEventPayload
  deleteEvent(filter: EventFilter!): DeleteEventPayload
  addEventFragment(input: [AddEventFragmentInput!]!): AddEventFragmentPayload
  updateEventFragment(input: UpdateEventFragmentInput!): UpdateEventFragmentPayload
  deleteEventFragment(filter: EventFragmentFilter!): DeleteEventFragmentPayload
  addContract(input: [AddContractInput!]! @hook_addContractInput, upsert: Boolean): AddContractPayload @hook_addContract
  updateContract(input: UpdateContractInput! @hook_updateContractInput): UpdateContractPayload @hook_updateContract
  deleteContract(filter: ContractFilter! @hook_deleteContractInput): DeleteContractPayload @hook_deleteContract
  addVote(input: [AddVoteInput!]! @hook_addVoteInput, upsert: Boolean): AddVotePayload @hook_addVote
  updateVote(input: UpdateVoteInput! @hook_updateVoteInput): UpdateVotePayload @hook_updateVote
  deleteVote(filter: VoteFilter! @hook_deleteVoteInput): DeleteVotePayload @hook_deleteVote
  addUser(input: [AddUserInput!]! @hook_addUserInput, upsert: Boolean): AddUserPayload @hook_addUser
  updateUser(input: UpdateUserInput! @hook_updateUserInput): UpdateUserPayload @hook_updateUser
  deleteUser(filter: UserFilter! @hook_deleteUserInput): DeleteUserPayload @hook_deleteUser
  addPendingUser(input: [AddPendingUserInput!]!, upsert: Boolean): AddPendingUserPayload
  updatePendingUser(input: UpdatePendingUserInput!): UpdatePendingUserPayload
  deletePendingUser(filter: PendingUserFilter!): DeletePendingUserPayload
  addUserRights(input: [AddUserRightsInput!]!): AddUserRightsPayload
  updateUserRights(input: UpdateUserRightsInput!): UpdateUserRightsPayload
  deleteUserRights(filter: UserRightsFilter!): DeleteUserRightsPayload
  addUserEvent(input: [AddUserEventInput!]!): AddUserEventPayload
  updateUserEvent(input: UpdateUserEventInput!): UpdateUserEventPayload
  deleteUserEvent(filter: UserEventFilter!): DeleteUserEventPayload
  addNotif(input: [AddNotifInput!]!): AddNotifPayload
  updateNotif(input: UpdateNotifInput!): UpdateNotifPayload
  deleteNotif(filter: NotifFilter!): DeleteNotifPayload
  addEventCount(input: [AddEventCountInput!]!): AddEventCountPayload
  updateEventCount(input: UpdateEventCountInput!): UpdateEventCountPayload
  deleteEventCount(filter: EventCountFilter!): DeleteEventCountPayload
}

input NearFilter {
  distance: Float!
  coordinate: PointRef!
}

type NodeAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  nameidMin: String
  nameidMax: String
  rootnameidMin: String
  rootnameidMax: String
  nameMin: String
  nameMax: String
  aboutMin: String
  aboutMax: String
  rightsMin: Int
  rightsMax: Int
  rightsSum: Int
  rightsAvg: Float
  colorMin: String
  colorMax: String
  n_open_contractsMin: Int
  n_open_contractsMax: Int
  n_open_contractsSum: Int
  n_open_contractsAvg: Float
}

input NodeFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  nameid: StringHashFilter_StringRegExpFilter
  rootnameid: StringHashFilter_StringRegExpFilter
  name: StringTermFilter
  about: StringFullTextFilter
  skills: StringTermFilter
  isRoot: Boolean
  type_: NodeType_hash
  visibility: NodeVisibility_hash
  mode: NodeMode_hash
  isArchived: Boolean
  isPersonal: Boolean
  role_type: RoleType_hash
  has: [NodeHasFilter]
  and: [NodeFilter]
  or: [NodeFilter]
  not: NodeFilter
}

type NodeFragmentAggregateResult {
  count: Int
  nameidMin: String
  nameidMax: String
  nameMin: String
  nameMax: String
  aboutMin: String
  aboutMax: String
  first_linkMin: String
  first_linkMax: String
  second_linkMin: String
  second_linkMax: String
  role_extMin: String
  role_extMax: String
  colorMin: String
  colorMax: String
}

input NodeFragmentFilter {
  id: [ID!]
  has: [NodeFragmentHasFilter]
  and: [NodeFragmentFilter]
  or: [NodeFragmentFilter]
  not: NodeFragmentFilter
}

enum NodeFragmentHasFilter {
  nameid
  name
  about
  mandate
  skills
  visibility
  mode
  type_
  first_link
  second_link
  role_ext
  role_type
  color
}

input NodeFragmentOrder {
  asc: NodeFragmentOrderable
  desc: NodeFragmentOrderable
  then: NodeFragmentOrder
}

enum NodeFragmentOrderable {
  nameid
  name
  about
  first_link
  second_link
  role_ext
  color
}

input NodeFragmentPatch {
  nameid: String @x_patch_ro
  name: String @x_alter(r:"minLen", n:1)
  about: String @x_alter(r:"maxLen", n:280)
  mandate: MandateRef @x_alter
  skills: [String!] @x_alter
  visibility: NodeVisibility @x_patch_ro
  mode: NodeMode @x_patch_ro
  type_: NodeType @x_patch_ro
  first_link: String @x_patch_ro
  second_link: String @x_patch_ro
  role_ext: String @x_patch_ro
  role_type: RoleType @x_patch_ro
  color: String @x_patch_ro
}

input NodeFragmentRef {
  id: ID
  nameid: String @w_add(a:"lower")
  name: String @x_alter(r:"minLen", n:1)
  about: String @x_alter(r:"maxLen", n:280)
  mandate: MandateRef @x_alter
  skills: [String!] @x_alter
  visibility: NodeVisibility
  mode: NodeMode
  type_: NodeType
  first_link: String
  second_link: String
  role_ext: String
  role_type: RoleType
  color: String
}

enum NodeHasFilter {
  createdBy
  createdAt
  updatedAt
  nameid
  rootnameid
  source
  name
  about
  skills
  isRoot
  parent
  type_
  tensions_out
  tensions_in
  visibility
  mode
  rights
  isArchived
  isPersonal
  userCanJoin
  guestCanCreateTension
  watchers
  children
  labels
  roles
  projects
  pinned
  role_ext
  role_type
  color
  first_link
  second_link
  contracts
  orga_agg
  events_history
  n_open_contracts
}

input NodeMode_hash {
  eq: NodeMode
  in: [NodeMode]
}

input NodeOrder {
  asc: NodeOrderable
  desc: NodeOrderable
  then: NodeOrder
}

enum NodeOrderable {
  createdAt
  updatedAt
  nameid
  rootnameid
  name
  about
  rights
  color
  n_open_contracts
}

input NodePatch {
  createdBy: UserRef @x_patch_ro
  createdAt: DateTime @x_patch_ro
  updatedAt: DateTime @x_patch_ro
  rootnameid: String @x_patch_ro
  source: BlobRef @x_patch_ro
  name: String @x_patch_ro
  about: String @x_patch_ro
  skills: [String!] @x_patch_ro
  isRoot: Boolean @x_patch_ro
  parent: NodeRef @x_patch_ro
  type_: NodeType @x_patch_ro
  tensions_out: [TensionRef!] @x_patch_ro
  tensions_in: [TensionRef!] @x_patch_ro
  visibility: NodeVisibility @x_patch_ro
  mode: NodeMode @x_patch_ro
  rights: Int @x_patch_ro
  isArchived: Boolean @x_patch_ro
  isPersonal: Boolean @x_patch_ro
  userCanJoin: Boolean @x_patch_ro
  guestCanCreateTension: Boolean @x_patch_ro
  watchers: [UserRef!] @x_patch_ro
  children: [NodeRef!] @x_patch_ro
  labels: [LabelRef!] @x_patch_ro
  roles: [RoleExtRef!] @x_patch_ro
  projects: [ProjectRef!] @x_patch_ro
  pinned: [TensionRef!] @x_patch_ro
  role_ext: RoleExtRef @x_patch_ro
  role_type: RoleType @x_patch_ro
  color: String @x_patch_ro
  first_link: UserRef @x_patch_ro
  second_link: UserRef @x_patch_ro
  contracts: [VoteRef!] @x_patch_ro
  orga_agg: OrgaAggRef @x_patch_ro
  events_history: [EventRef!] @x_patch_ro
  n_open_contracts: Int @x_patch_ro
}

input NodeRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime
  updatedAt: DateTime
  nameid: String
  rootnameid: String
  source: BlobRef
  name: String
  about: String
  skills: [String!]
  isRoot: Boolean
  parent: NodeRef
  type_: NodeType
  tensions_out: [TensionRef!]
  tensions_in: [TensionRef!]
  visibility: NodeVisibility
  mode: NodeMode
  rights: Int
  isArchived: Boolean
  isPersonal: Boolean
  userCanJoin: Boolean
  guestCanCreateTension: Boolean
  watchers: [UserRef!]
  children: [NodeRef!]
  labels: [LabelRef!]
  roles: [RoleExtRef!]
  projects: [ProjectRef!]
  pinned: [TensionRef!] @x_add(r:"ref")
  role_ext: RoleExtRef
  role_type: RoleType
  color: String
  first_link: UserRef
  second_link: UserRef
  contracts: [VoteRef!]
  orga_agg: OrgaAggRef
  events_history: [EventRef!]
  n_open_contracts: Int
}

input NodeType_hash {
  eq: NodeType
  in: [NodeType]
}

input NodeVisibility_hash {
  eq: NodeVisibility
  in: [NodeVisibility]
}

type NotifAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  messageMin: String
  messageMax: String
  linkMin: String
  linkMax: String
}

input NotifFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  has: [NotifHasFilter]
  and: [NotifFilter]
  or: [NotifFilter]
  not: NotifFilter
}

enum NotifHasFilter {
  createdBy
  createdAt
  updatedAt
  message
  tension_
  contract
  link
}

input NotifOrder {
  asc: NotifOrderable
  desc: NotifOrderable
  then: NotifOrder
}

enum NotifOrderable {
  createdAt
  updatedAt
  message
  link
}

input NotifPatch {
  createdBy: UserRef @x_patch_ro
  createdAt: DateTime @x_patch_ro
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_patch_ro
  tension_: TensionRef @x_patch_ro
  contract: ContractRef @x_patch_ro
  link: String @x_patch_ro
}

input NotifRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String
  tension_: TensionRef
  contract: ContractRef
  link: String
}

type OrgaAggAggregateResult {
  count: Int
  n_membersMin: Int
  n_membersMax: Int
  n_membersSum: Int
  n_membersAvg: Float
  n_guestsMin: Int
  n_guestsMax: Int
  n_guestsSum: Int
  n_guestsAvg: Float
}

input OrgaAggFilter {
  has: [OrgaAggHasFilter]
  and: [OrgaAggFilter]
  or: [OrgaAggFilter]
  not: OrgaAggFilter
}

enum OrgaAggHasFilter {
  n_members
  n_guests
}

input OrgaAggOrder {
  asc: OrgaAggOrderable
  desc: OrgaAggOrderable
  then: OrgaAggOrder
}

enum OrgaAggOrderable {
  n_members
  n_guests
}

input OrgaAggPatch {
  n_members: Int @x_patch_ro
  n_guests: Int @x_patch_ro
}

input OrgaAggRef {
  n_members: Int
  n_guests: Int
}

type PendingUserAggregateResult {
  count: Int
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  usernameMin: String
  usernameMax: String
  passwordMin: String
  passwordMax: String
  emailMin: String
  emailMax: String
  email_tokenMin: String
  email_tokenMax: String
  tokenMin: String
  tokenMax: String
}

input PendingUserFilter {
  id: [ID!]
  username: StringHashFilter @w_alter(a:"lower")
  email: StringHashFilter @w_alter(a:"lower")
  email_token: StringHashFilter
  token: StringHashFilter
  has: [PendingUserHasFilter]
  and: [PendingUserFilter]
  or: [PendingUserFilter]
  not: PendingUserFilter
}

enum PendingUserHasFilter {
  updatedAt
  username
  password
  email
  email_token
  token
  contracts
  subscribe
}

input PendingUserOrder {
  asc: PendingUserOrderable
  desc: PendingUserOrderable
  then: PendingUserOrder
}

enum PendingUserOrderable {
  updatedAt
  username
  password
  email
  email_token
  token
}

input PendingUserPatch {
  updatedAt: DateTime @x_patch_ro
  password: String @x_patch_ro
  email_token: String @x_patch_ro
  token: String @x_patch_ro
  contracts: [ContractRef!] @x_patch_ro
  subscribe: Boolean @x_patch_ro
}

input PendingUserRef {
  id: ID
  updatedAt: DateTime
  username: String @w_alter(a:"lower")
  password: String
  email: String @w_alter(a:"lower")
  email_token: String
  token: String
  contracts: [ContractRef!]
  subscribe: Boolean
}

type Point {
  longitude: Float!
  latitude: Float!
}

input PointGeoFilter {
  near: NearFilter
  within: WithinFilter
}

type PointList {
  points: [Point!]!
}

input PointListRef {
  points: [PointRef!]!
}

input PointRef {
  longitude: Float!
  latitude: Float!
}

type Polygon {
  coordinates: [PointList!]!
}

input PolygonGeoFilter {
  near: NearFilter
  within: WithinFilter
  contains: ContainsFilter
  intersects: IntersectsFilter
}

input PolygonRef {
  coordinates: [PointListRef!]!
}

type PostAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  messageMin: String
  messageMax: String
}

input PostFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  has: [PostHasFilter]
  and: [PostFilter]
  or: [PostFilter]
  not: PostFilter
}

enum PostHasFilter {
  createdBy
  createdAt
  updatedAt
  message
}

input PostOrder {
  asc: PostOrderable
  desc: PostOrderable
  then: PostOrder
}

enum PostOrderable {
  createdAt
  updatedAt
  message
}

input PostPatch {
  createdBy: UserRef @x_patch_ro
  createdAt: DateTime @x_patch_ro
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_alter(r:"isOwner", f:"createdBy")
}

input PostRef {
  id: ID!
}

type ProjectAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  rootnameidMin: String
  rootnameidMax: String
  parentnameidMin: String
  parentnameidMax: String
  nameidMin: String
  nameidMax: String
  nameMin: String
  nameMax: String
  descriptionMin: String
  descriptionMax: String
}

type ProjectColumnAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
  aboutMin: String
  aboutMax: String
  posMin: Int
  posMax: Int
  posSum: Int
  posAvg: Float
}

input ProjectColumnFilter {
  id: [ID!]
  name: StringHashFilter
  has: [ProjectColumnHasFilter]
  and: [ProjectColumnFilter]
  or: [ProjectColumnFilter]
  not: ProjectColumnFilter
}

enum ProjectColumnHasFilter {
  name
  about
  pos
  tensions
  project
}

input ProjectColumnOrder {
  asc: ProjectColumnOrderable
  desc: ProjectColumnOrderable
  then: ProjectColumnOrder
}

enum ProjectColumnOrderable {
  name
  about
  pos
}

input ProjectColumnPatch {
  about: String @x_patch_ro
  pos: Int @x_patch_ro
  tensions: [ProjectTensionRef!] @x_patch_ro
  project: ProjectRef @x_patch_ro
}

input ProjectColumnRef {
  id: ID
  name: String
  about: String
  pos: Int
  tensions: [ProjectTensionRef!]
  project: ProjectRef
}

input ProjectFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  rootnameid: StringHashFilter
  parentnameid: StringHashFilter
  nameid: StringHashFilter @w_alter(a:"lower")
  name: StringTermFilter
  status: ProjectStatus_hash
  has: [ProjectHasFilter]
  and: [ProjectFilter]
  or: [ProjectFilter]
  not: ProjectFilter
}

enum ProjectHasFilter {
  createdBy
  createdAt
  updatedAt
  rootnameid
  parentnameid
  nameid
  name
  description
  status
  columns
  leaders
  nodes
}

input ProjectOrder {
  asc: ProjectOrderable
  desc: ProjectOrderable
  then: ProjectOrder
}

enum ProjectOrderable {
  createdAt
  updatedAt
  rootnameid
  parentnameid
  nameid
  name
  description
}

input ProjectPatch {
  createdBy: UserRef @x_patch_ro
  createdAt: DateTime @x_patch_ro
  updatedAt: DateTime @x_patch_ro
  rootnameid: String @x_patch_ro
  parentnameid: String @x_patch_ro
  nameid: String @w_alter(a:"lower") @x_alter(r:"unique", f:"parentnameid") @x_alter(r:"minLen", n:1)
  name: String @x_alter(r:"maxLen", n:100)
  description: String @x_alter(r:"maxLen", n:280)
  status: ProjectStatus @x_patch_ro
  columns: [ProjectColumnRef!] @x_patch_ro
  leaders: [NodeRef!] @x_alter(r:"ref")
  nodes: [NodeRef!] @x_alter(r:"oneByOne") @x_alter(r:"ref")
}

input ProjectRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime
  updatedAt: DateTime
  rootnameid: String
  parentnameid: String
  nameid: String @w_alter(a:"lower") @x_alter(r:"unique", f:"parentnameid") @x_alter(r:"minLen", n:1)
  name: String @x_alter(r:"maxLen", n:100)
  description: String @x_alter(r:"maxLen", n:280)
  status: ProjectStatus
  columns: [ProjectColumnRef!]
  leaders: [NodeRef!] @x_alter(r:"ref")
  nodes: [NodeRef!] @x_alter(r:"oneByOne") @x_alter(r:"ref")
}

input ProjectStatus_hash {
  eq: ProjectStatus
  in: [ProjectStatus]
}

type ProjectTensionAggregateResult {
  count: Int
  posMin: Int
  posMax: Int
  posSum: Int
  posAvg: Float
}

input ProjectTensionFilter {
  id: [ID!]
  has: [ProjectTensionHasFilter]
  and: [ProjectTensionFilter]
  or: [ProjectTensionFilter]
  not: ProjectTensionFilter
}

enum ProjectTensionHasFilter {
  tension
  pos
  pc
}

input ProjectTensionOrder {
  asc: ProjectTensionOrderable
  desc: ProjectTensionOrderable
  then: ProjectTensionOrder
}

enum ProjectTensionOrderable {
  pos
}

input ProjectTensionPatch {
  tension: TensionRef @x_alter(r:"ref")
  pos: Int @x_alter
  pc: ProjectColumnRef @x_patch_ro
}

input ProjectTensionRef {
  id: ID
  tension: TensionRef @x_alter(r:"ref")
  pos: Int @x_alter
  pc: ProjectColumnRef
}

type Query {
  getNode(id: ID, nameid: String): Node
  queryNode(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node]
  aggregateNode(filter: NodeFilter): NodeAggregateResult
  getNodeFragment(id: ID!): NodeFragment
  queryNodeFragment(filter: NodeFragmentFilter, order: NodeFragmentOrder, first: Int, offset: Int): [NodeFragment]
  aggregateNodeFragment(filter: NodeFragmentFilter): NodeFragmentAggregateResult
  getMandate(id: ID!): Mandate
  queryMandate(filter: MandateFilter, order: MandateOrder, first: Int, offset: Int): [Mandate]
  aggregateMandate(filter: MandateFilter): MandateAggregateResult
  getLabel(id: ID!): Label
  queryLabel(filter: LabelFilter @hook_queryLabelInput, order: LabelOrder, first: Int, offset: Int): [Label]
  aggregateLabel(filter: LabelFilter): LabelAggregateResult
  getRoleExt(id: ID!): RoleExt
  queryRoleExt(filter: RoleExtFilter @hook_queryRoleExtInput, order: RoleExtOrder, first: Int, offset: Int): [RoleExt]
  aggregateRoleExt(filter: RoleExtFilter): RoleExtAggregateResult
  getProject(id: ID!): Project
  queryProject(filter: ProjectFilter @hook_queryProjectInput, order: ProjectOrder, first: Int, offset: Int): [Project]
  aggregateProject(filter: ProjectFilter): ProjectAggregateResult
  getProjectTension(id: ID!): ProjectTension
  queryProjectTension(filter: ProjectTensionFilter, order: ProjectTensionOrder, first: Int, offset: Int): [ProjectTension]
  aggregateProjectTension(filter: ProjectTensionFilter): ProjectTensionAggregateResult
  getProjectColumn(id: ID, name: String): ProjectColumn
  queryProjectColumn(filter: ProjectColumnFilter, order: ProjectColumnOrder, first: Int, offset: Int): [ProjectColumn]
  aggregateProjectColumn(filter: ProjectColumnFilter): ProjectColumnAggregateResult
  queryOrgaAgg(filter: OrgaAggFilter, order: OrgaAggOrder, first: Int, offset: Int): [OrgaAgg]
  aggregateOrgaAgg(filter: OrgaAggFilter): OrgaAggAggregateResult
  getPost(id: ID!): Post
  queryPost(filter: PostFilter, order: PostOrder, first: Int, offset: Int): [Post]
  aggregatePost(filter: PostFilter): PostAggregateResult
  getTension(id: ID!): Tension
  queryTension(filter: TensionFilter @hook_queryTensionInput, order: TensionOrder, first: Int, offset: Int): [Tension]
  aggregateTension(filter: TensionFilter): TensionAggregateResult
  getComment(id: ID!): Comment
  queryComment(filter: CommentFilter @hook_queryCommentInput, order: CommentOrder, first: Int, offset: Int): [Comment]
  aggregateComment(filter: CommentFilter): CommentAggregateResult
  getReaction(id: ID, reactionid: String): Reaction
  queryReaction(filter: ReactionFilter @hook_queryReactionInput, order: ReactionOrder, first: Int, offset: Int): [Reaction]
  aggregateReaction(filter: ReactionFilter): ReactionAggregateResult
  getBlob(id: ID!): Blob
  queryBlob(filter: BlobFilter, order: BlobOrder, first: Int, offset: Int): [Blob]
  aggregateBlob(filter: BlobFilter): BlobAggregateResult
  getEvent(id: ID!): Event
  queryEvent(filter: EventFilter, order: EventOrder, first: Int, offset: Int): [Event]
  aggregateEvent(filter: EventFilter): EventAggregateResult
  queryEventFragment(filter: EventFragmentFilter, order: EventFragmentOrder, first: Int, offset: Int): [EventFragment]
  aggregateEventFragment(filter: EventFragmentFilter): EventFragmentAggregateResult
  getContract(id: ID, contractid: String): Contract
  queryContract(filter: ContractFilter @hook_queryContractInput, order: ContractOrder, first: Int, offset: Int): [Contract]
  aggregateContract(filter: ContractFilter): ContractAggregateResult
  getVote(id: ID, voteid: String): Vote
  queryVote(filter: VoteFilter @hook_queryVoteInput, order: VoteOrder, first: Int, offset: Int): [Vote]
  aggregateVote(filter: VoteFilter): VoteAggregateResult
  getUser(id: ID, username: String, email: String): User
  queryUser(filter: UserFilter @hook_queryUserInput, order: UserOrder, first: Int, offset: Int): [User]
  aggregateUser(filter: UserFilter): UserAggregateResult
  getPendingUser(id: ID, username: String, email: String): PendingUser
  queryPendingUser(filter: PendingUserFilter, order: PendingUserOrder, first: Int, offset: Int): [PendingUser]
  aggregatePendingUser(filter: PendingUserFilter): PendingUserAggregateResult
  queryUserRights(filter: UserRightsFilter, order: UserRightsOrder, first: Int, offset: Int): [UserRights]
  aggregateUserRights(filter: UserRightsFilter): UserRightsAggregateResult
  getUserEvent(id: ID!): UserEvent
  queryUserEvent(filter: UserEventFilter, order: UserEventOrder, first: Int, offset: Int): [UserEvent]
  aggregateUserEvent(filter: UserEventFilter): UserEventAggregateResult
  getNotif(id: ID!): Notif
  queryNotif(filter: NotifFilter, order: NotifOrder, first: Int, offset: Int): [Notif]
  aggregateNotif(filter: NotifFilter): NotifAggregateResult
  queryEventCount(filter: EventCountFilter, order: EventCountOrder, first: Int, offset: Int): [EventCount]
  aggregateEventCount(filter: EventCountFilter): EventCountAggregateResult
}

type ReactionAggregateResult {
  count: Int
  reactionidMin: String
  reactionidMax: String
  type_Min: Int
  type_Max: Int
  type_Sum: Int
  type_Avg: Float
}

input ReactionFilter {
  id: [ID!]
  reactionid: StringHashFilter
  has: [ReactionHasFilter]
  and: [ReactionFilter]
  or: [ReactionFilter]
  not: ReactionFilter
}

enum ReactionHasFilter {
  reactionid
  user
  comment
  type_
}

input ReactionOrder {
  asc: ReactionOrderable
  desc: ReactionOrderable
  then: ReactionOrder
}

enum ReactionOrderable {
  reactionid
  type_
}

input ReactionPatch {
  user: UserRef @x_patch_ro
  comment: CommentRef @x_patch_ro
  type_: Int @x_patch_ro
}

input ReactionRef {
  id: ID
  reactionid: String
  user: UserRef @x_add(r:"ref")
  comment: CommentRef @x_add(r:"ref")
  type_: Int
}

type RoleExtAggregateResult {
  count: Int
  rootnameidMin: String
  rootnameidMax: String
  nameMin: String
  nameMax: String
  aboutMin: String
  aboutMax: String
  colorMin: String
  colorMax: String
}

input RoleExtFilter {
  id: [ID!]
  rootnameid: StringHashFilter
  name: StringHashFilter_StringTermFilter @w_alter(a:"lower")
  has: [RoleExtHasFilter]
  and: [RoleExtFilter]
  or: [RoleExtFilter]
  not: RoleExtFilter
}

enum RoleExtHasFilter {
  rootnameid
  name
  about
  role_type
  color
  mandate
  roles
  nodes
}

input RoleExtOrder {
  asc: RoleExtOrderable
  desc: RoleExtOrderable
  then: RoleExtOrder
}

enum RoleExtOrderable {
  rootnameid
  name
  about
  color
}

input RoleExtPatch {
  rootnameid: String @x_patch_ro
  name: String @w_alter(a:"lower") @x_alter(r:"unique", f:"rootnameid") @x_alter(r:"minLen", n:1)
  about: String @x_alter(r:"maxLen", n:280)
  role_type: RoleType @x_alter
  color: String @x_alter
  mandate: MandateRef @x_alter
  roles: [NodeRef!] @x_ro
  nodes: [NodeRef!] @x_alter(r:"oneByOne") @x_alter(r:"ref")
}

input RoleExtRef {
  id: ID
  rootnameid: String
  name: String @w_alter(a:"lower") @x_alter(r:"unique", f:"rootnameid") @x_alter(r:"minLen", n:1)
  about: String @x_alter(r:"maxLen", n:280)
  role_type: RoleType @x_alter
  color: String @x_alter
  mandate: MandateRef @x_alter
  roles: [NodeRef!] @x_ro
  nodes: [NodeRef!] @x_alter(r:"oneByOne") @x_alter(r:"ref")
}

input RoleType_hash {
  eq: RoleType
  in: [RoleType]
}

input StringExactFilter {
  eq: String
  in: [String]
  le: String
  lt: String
  ge: String
  gt: String
  between: StringRange
}

input StringFullTextFilter {
  alloftext: String
  anyoftext: String
}

input StringHashFilter {
  eq: String
  in: [String]
}

input StringHashFilter_StringRegExpFilter {
  eq: String
  in: [String]
  regexp: String
}

input StringHashFilter_StringTermFilter {
  eq: String
  in: [String]
  allofterms: String
  anyofterms: String
}

input StringRange {
  min: String!
  max: String!
}

input StringRegExpFilter {
  regexp: String
}

input StringTermFilter {
  allofterms: String
  anyofterms: String
}

type TensionAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  messageMin: String
  messageMax: String
  emitteridMin: String
  emitteridMax: String
  receiveridMin: String
  receiveridMax: String
  titleMin: String
  titleMax: String
  n_open_contractsMin: Int
  n_open_contractsMax: Int
  n_open_contractsSum: Int
  n_open_contractsAvg: Float
  n_commentsMin: Int
  n_commentsMax: Int
  n_commentsSum: Int
  n_commentsAvg: Float
}

input TensionEvent_hash {
  eq: TensionEvent
  in: [TensionEvent]
}

input TensionFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  emitterid: StringHashFilter_StringRegExpFilter
  receiverid: StringHashFilter_StringRegExpFilter
  title: StringFullTextFilter
  type_: TensionType_hash
  status: TensionStatus_hash
  has: [TensionHasFilter]
  and: [TensionFilter]
  or: [TensionFilter]
  not: TensionFilter
}

enum TensionHasFilter {
  createdBy
  createdAt
  updatedAt
  message
  emitter
  emitterid
  receiver
  receiverid
  title
  type_
  status
  action
  assignees
  labels
  comments
  blobs
  history
  mentions
  contracts
  subscribers
  projects
  n_open_contracts
  n_comments
}

input TensionOrder {
  asc: TensionOrderable
  desc: TensionOrderable
  then: TensionOrder
}

enum TensionOrderable {
  createdAt
  updatedAt
  message
  emitterid
  receiverid
  title
  n_open_contracts
  n_comments
}

input TensionPatch {
  createdBy: UserRef @x_patch_ro
  createdAt: DateTime @x_patch_ro
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_patch_ro
  emitter: NodeRef @x_patch_ro
  emitterid: String @x_patch_ro
  receiver: NodeRef @x_patch_ro
  receiverid: String @x_patch_ro
  title: String @x_patch_ro
  type_: TensionType @x_alter(r:"tensionTypeCheck")
  status: TensionStatus @x_patch_ro
  action: TensionAction @x_patch_ro
  assignees: [UserRef!] @x_alter(r:"hasEvent", e:[AssigneeAdded, AssigneeRemoved]) @x_alter(r:"ref")
  labels: [LabelRef!] @x_alter(r:"hasEvent", e:[LabelAdded, LabelRemoved]) @x_alter(r:"ref")
  comments: [CommentRef!] @x_alter(r:"hasEvent", e:[Created, CommentPushed]) @x_alter(r:"oneByOne")
  blobs: [BlobRef!] @x_alter(r:"hasEvent", e:[BlobCreated, BlobCommitted]) @x_alter(r:"oneByOne")
  history: [EventRef!] @x_alter
  mentions: [EventRef!] @x_patch_ro
  contracts: [ContractRef!] @x_patch_ro
  subscribers: [UserRef!] @x_patch_ro
  projects: [ProjectTensionRef!] @x_patch_ro
  n_open_contracts: Int @x_patch_ro
  n_comments: Int @x_patch_ro
}

input TensionRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String
  emitter: NodeRef
  emitterid: String
  receiver: NodeRef
  receiverid: String
  title: String
  type_: TensionType @x_alter(r:"tensionTypeCheck")
  status: TensionStatus
  action: TensionAction
  assignees: [UserRef!] @x_alter(r:"hasEvent", e:[AssigneeAdded, AssigneeRemoved]) @x_alter(r:"ref")
  labels: [LabelRef!] @x_alter(r:"hasEvent", e:[LabelAdded, LabelRemoved]) @x_alter(r:"ref")
  comments: [CommentRef!] @x_alter(r:"hasEvent", e:[Created, CommentPushed]) @x_alter(r:"oneByOne")
  blobs: [BlobRef!] @x_alter(r:"hasEvent", e:[BlobCreated, BlobCommitted]) @x_alter(r:"oneByOne")
  history: [EventRef!] @x_alter
  mentions: [EventRef!]
  contracts: [ContractRef!] @x_add(r:"ref")
  subscribers: [UserRef!] @x_add(r:"ref")
  projects: [ProjectTensionRef!] @x_add(r:"ref")
  n_open_contracts: Int
  n_comments: Int
}

input TensionStatus_hash {
  eq: TensionStatus
  in: [TensionStatus]
}

input TensionType_hash {
  eq: TensionType
  in: [TensionType]
}

input UpdateBlobInput {
  filter: BlobFilter!
  set: BlobPatch
  remove: BlobPatch
}

type UpdateBlobPayload {
  blob(filter: BlobFilter, order: BlobOrder, first: Int, offset: Int): [Blob]
  numUids: Int
}

input UpdateCommentInput {
  filter: CommentFilter!
  set: CommentPatch
  remove: CommentPatch
}

type UpdateCommentPayload {
  comment(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment]
  numUids: Int
}

input UpdateContractInput {
  filter: ContractFilter!
  set: ContractPatch
  remove: ContractPatch
}

type UpdateContractPayload {
  contract(filter: ContractFilter, order: ContractOrder, first: Int, offset: Int): [Contract]
  numUids: Int
}

input UpdateEventCountInput {
  filter: EventCountFilter!
  set: EventCountPatch
  remove: EventCountPatch
}

type UpdateEventCountPayload {
  eventCount(filter: EventCountFilter, order: EventCountOrder, first: Int, offset: Int): [EventCount]
  numUids: Int
}

input UpdateEventFragmentInput {
  filter: EventFragmentFilter!
  set: EventFragmentPatch
  remove: EventFragmentPatch
}

type UpdateEventFragmentPayload {
  eventFragment(filter: EventFragmentFilter, order: EventFragmentOrder, first: Int, offset: Int): [EventFragment]
  numUids: Int
}

input UpdateEventInput {
  filter: EventFilter!
  set: EventPatch
  remove: EventPatch
}

type UpdateEventPayload {
  event(filter: EventFilter, order: EventOrder, first: Int, offset: Int): [Event]
  numUids: Int
}

input UpdateLabelInput {
  filter: LabelFilter!
  set: LabelPatch
  remove: LabelPatch
}

type UpdateLabelPayload {
  label(filter: LabelFilter, order: LabelOrder, first: Int, offset: Int): [Label]
  numUids: Int
}

input UpdateMandateInput {
  filter: MandateFilter!
  set: MandatePatch
  remove: MandatePatch
}

type UpdateMandatePayload {
  mandate(filter: MandateFilter, order: MandateOrder, first: Int, offset: Int): [Mandate]
  numUids: Int
}

input UpdateNodeFragmentInput {
  filter: NodeFragmentFilter!
  set: NodeFragmentPatch
  remove: NodeFragmentPatch
}

type UpdateNodeFragmentPayload {
  nodeFragment(filter: NodeFragmentFilter, order: NodeFragmentOrder, first: Int, offset: Int): [NodeFragment]
  numUids: Int
}

input UpdateNodeInput {
  filter: NodeFilter!
  set: NodePatch
  remove: NodePatch
}

type UpdateNodePayload {
  node(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node]
  numUids: Int
}

input UpdateNotifInput {
  filter: NotifFilter!
  set: NotifPatch
  remove: NotifPatch
}

type UpdateNotifPayload {
  notif(filter: NotifFilter, order: NotifOrder, first: Int, offset: Int): [Notif]
  numUids: Int
}

input UpdateOrgaAggInput {
  filter: OrgaAggFilter!
  set: OrgaAggPatch
  remove: OrgaAggPatch
}

type UpdateOrgaAggPayload {
  orgaAgg(filter: OrgaAggFilter, order: OrgaAggOrder, first: Int, offset: Int): [OrgaAgg]
  numUids: Int
}

input UpdatePendingUserInput {
  filter: PendingUserFilter!
  set: PendingUserPatch
  remove: PendingUserPatch
}

type UpdatePendingUserPayload {
  pendingUser(filter: PendingUserFilter, order: PendingUserOrder, first: Int, offset: Int): [PendingUser]
  numUids: Int
}

input UpdatePostInput {
  filter: PostFilter!
  set: PostPatch
  remove: PostPatch
}

type UpdatePostPayload {
  post(filter: PostFilter, order: PostOrder, first: Int, offset: Int): [Post]
  numUids: Int
}

input UpdateProjectColumnInput {
  filter: ProjectColumnFilter!
  set: ProjectColumnPatch
  remove: ProjectColumnPatch
}

type UpdateProjectColumnPayload {
  projectColumn(filter: ProjectColumnFilter, order: ProjectColumnOrder, first: Int, offset: Int): [ProjectColumn]
  numUids: Int
}

input UpdateProjectInput {
  filter: ProjectFilter!
  set: ProjectPatch
  remove: ProjectPatch
}

type UpdateProjectPayload {
  project(filter: ProjectFilter, order: ProjectOrder, first: Int, offset: Int): [Project]
  numUids: Int
}

input UpdateProjectTensionInput {
  filter: ProjectTensionFilter!
  set: ProjectTensionPatch
  remove: ProjectTensionPatch
}

type UpdateProjectTensionPayload {
  projectTension(filter: ProjectTensionFilter, order: ProjectTensionOrder, first: Int, offset: Int): [ProjectTension]
  numUids: Int
}

input UpdateReactionInput {
  filter: ReactionFilter!
  set: ReactionPatch
  remove: ReactionPatch
}

type UpdateReactionPayload {
  reaction(filter: ReactionFilter, order: ReactionOrder, first: Int, offset: Int): [Reaction]
  numUids: Int
}

input UpdateRoleExtInput {
  filter: RoleExtFilter!
  set: RoleExtPatch
  remove: RoleExtPatch
}

type UpdateRoleExtPayload {
  roleExt(filter: RoleExtFilter, order: RoleExtOrder, first: Int, offset: Int): [RoleExt]
  numUids: Int
}

input UpdateTensionInput {
  filter: TensionFilter!
  set: TensionPatch
  remove: TensionPatch
}

type UpdateTensionPayload {
  tension(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension]
  numUids: Int
}

input UpdateUserEventInput {
  filter: UserEventFilter!
  set: UserEventPatch
  remove: UserEventPatch
}

type UpdateUserEventPayload {
  userEvent(filter: UserEventFilter, order: UserEventOrder, first: Int, offset: Int): [UserEvent]
  numUids: Int
}

input UpdateUserInput {
  filter: UserFilter!
  set: UserPatch
  remove: UserPatch
}

type UpdateUserPayload {
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  numUids: Int
}

input UpdateUserRightsInput {
  filter: UserRightsFilter!
  set: UserRightsPatch
  remove: UserRightsPatch
}

type UpdateUserRightsPayload {
  userRights(filter: UserRightsFilter, order: UserRightsOrder, first: Int, offset: Int): [UserRights]
  numUids: Int
}

input UpdateVoteInput {
  filter: VoteFilter!
  set: VotePatch
  remove: VotePatch
}

type UpdateVotePayload {
  vote(filter: VoteFilter, order: VoteOrder, first: Int, offset: Int): [Vote]
  numUids: Int
}

type UserAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  lastAckMin: DateTime
  lastAckMax: DateTime
  usernameMin: String
  usernameMax: String
  nameMin: String
  nameMax: String
  emailMin: String
  emailMax: String
  passwordMin: String
  passwordMax: String
  bioMin: String
  bioMax: String
  locationMin: String
  locationMax: String
  utcMin: String
  utcMax: String
  markAllAsReadMin: String
  markAllAsReadMax: String
}

type UserEventAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
}

input UserEventFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  isRead: Boolean
  has: [UserEventHasFilter]
  and: [UserEventFilter]
  or: [UserEventFilter]
  not: UserEventFilter
}

enum UserEventHasFilter {
  createdAt
  isRead
  user
  event
}

input UserEventOrder {
  asc: UserEventOrderable
  desc: UserEventOrderable
  then: UserEventOrder
}

enum UserEventOrderable {
  createdAt
}

input UserEventPatch {
  createdAt: DateTime @x_patch_ro
  isRead: Boolean @x_alter
  user: UserRef @x_patch_ro
  event: [EventKindRef!] @x_patch_ro
}

input UserEventRef {
  id: ID
  createdAt: DateTime
  isRead: Boolean @x_alter
  user: UserRef
  event: [EventKindRef!] @x_add(r:"ref")
}

input UserFilter {
  id: [ID!]
  username: StringHashFilter_StringRegExpFilter @w_add(a:"lower")
  name: StringRegExpFilter
  email: StringHashFilter @w_add(a:"lower")
  has: [UserHasFilter]
  and: [UserFilter]
  or: [UserFilter]
  not: UserFilter
}

enum UserHasFilter {
  createdAt
  lastAck
  username
  name
  email
  password
  bio
  location
  utc
  links
  skills
  notifyByEmail
  lang
  subscriptions
  watching
  rights
  roles
  backed_roles
  tensions_created
  tensions_assigned
  contracts
  reactions
  events
  markAllAsRead
  event_count
}

input UserOrder {
  asc: UserOrderable
  desc: UserOrderable
  then: UserOrder
}

enum UserOrderable {
  createdAt
  lastAck
  username
  name
  email
  password
  bio
  location
  utc
  markAllAsRead
}

input UserPatch {
  createdAt: DateTime @x_patch_ro
  lastAck: DateTime @x_patch_ro
  name: String @x_patch
  password: String @x_patch_ro
  bio: String @x_patch @x_alter(r:"maxLen", n:280)
  location: String @x_patch
  utc: String @x_patch
  links: [String!] @x_patch
  skills: [String!] @x_patch
  notifyByEmail: Boolean @x_patch
  lang: Lang @x_patch
  subscriptions: [TensionRef!] @x_patch @x_alter(r:"ref")
  watching: [NodeRef!] @x_patch @x_alter(r:"ref")
  rights: UserRightsRef @x_patch_ro
  roles: [NodeRef!] @x_patch_ro
  backed_roles: [NodeRef!] @x_patch_ro
  tensions_created: [TensionRef!] @x_patch_ro
  tensions_assigned: [TensionRef!] @x_patch_ro
  contracts: [ContractRef!] @x_patch_ro
  reactions: [ReactionRef!] @x_alter
  events: [UserEventRef!] @x_alter
  markAllAsRead: String @w_meta_patch(f:"markAllAsRead", k:"username") @x_alter
  event_count: EventCountRef @x_patch_ro
}

input UserRef {
  id: ID
  createdAt: DateTime
  lastAck: DateTime
  username: String @w_add(a:"lower")
  name: String @x_patch
  email: String @w_add(a:"lower")
  password: String
  bio: String @x_patch @x_alter(r:"maxLen", n:280)
  location: String @x_patch
  utc: String @x_patch
  links: [String!] @x_patch
  skills: [String!] @x_patch
  notifyByEmail: Boolean @x_patch
  lang: Lang @x_patch
  subscriptions: [TensionRef!] @x_patch @x_alter(r:"ref")
  watching: [NodeRef!] @x_patch @x_alter(r:"ref")
  rights: UserRightsRef
  roles: [NodeRef!] @x_add(r:"ref")
  backed_roles: [NodeRef!] @x_add(r:"ref")
  tensions_created: [TensionRef!] @x_add(r:"ref")
  tensions_assigned: [TensionRef!] @x_add(r:"ref")
  contracts: [ContractRef!] @x_add(r:"ref")
  reactions: [ReactionRef!] @x_alter
  events: [UserEventRef!] @x_alter
  markAllAsRead: String @w_meta_patch(f:"markAllAsRead", k:"username") @x_alter
  event_count: EventCountRef
}

type UserRightsAggregateResult {
  count: Int
  maxPublicOrgaMin: Int
  maxPublicOrgaMax: Int
  maxPublicOrgaSum: Int
  maxPublicOrgaAvg: Float
  maxPrivateOrgaMin: Int
  maxPrivateOrgaMax: Int
  maxPrivateOrgaSum: Int
  maxPrivateOrgaAvg: Float
}

input UserRightsFilter {
  has: [UserRightsHasFilter]
  and: [UserRightsFilter]
  or: [UserRightsFilter]
  not: UserRightsFilter
}

enum UserRightsHasFilter {
  type_
  canLogin
  canCreateRoot
  maxPublicOrga
  maxPrivateOrga
  hasEmailNotifications
}

input UserRightsOrder {
  asc: UserRightsOrderable
  desc: UserRightsOrderable
  then: UserRightsOrder
}

enum UserRightsOrderable {
  maxPublicOrga
  maxPrivateOrga
}

input UserRightsPatch {
  type_: UserType @x_patch_ro
  canLogin: Boolean @x_patch_ro
  canCreateRoot: Boolean @x_patch_ro
  maxPublicOrga: Int @x_patch_ro
  maxPrivateOrga: Int @x_patch_ro
  hasEmailNotifications: Boolean @x_patch_ro
}

input UserRightsRef {
  type_: UserType
  canLogin: Boolean
  canCreateRoot: Boolean
  maxPublicOrga: Int
  maxPrivateOrga: Int
  hasEmailNotifications: Boolean
}

type VoteAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  messageMin: String
  messageMax: String
  voteidMin: String
  voteidMax: String
}

input VoteFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  voteid: StringHashFilter
  has: [VoteHasFilter]
  and: [VoteFilter]
  or: [VoteFilter]
  not: VoteFilter
}

enum VoteHasFilter {
  createdBy
  createdAt
  updatedAt
  message
  voteid
  contract
  node
  data
}

input VoteOrder {
  asc: VoteOrderable
  desc: VoteOrderable
  then: VoteOrder
}

enum VoteOrderable {
  createdAt
  updatedAt
  message
  voteid
}

input VotePatch {
  createdBy: UserRef @x_patch_ro
  createdAt: DateTime @x_patch_ro
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_patch_ro
  contract: ContractRef @x_patch_ro
  node: NodeRef @x_patch_ro
  data: [Int!] @x_patch_ro
}

input VoteRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String
  voteid: String
  contract: ContractRef @x_add(r:"ref")
  node: NodeRef @x_add(r:"ref")
  data: [Int!]
}

input WithinFilter {
  polygon: PolygonRef!
}
