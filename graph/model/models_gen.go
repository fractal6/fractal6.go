// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type CardKind interface {
	IsCardKind()
}

type EventKind interface {
	IsEventKind()
}

type AddBlobInput struct {
	CreatedBy    *UserRef         `json:"createdBy"`
	CreatedAt    string           `json:"createdAt"`
	UpdatedAt    *string          `json:"updatedAt,omitempty"`
	Message      *string          `json:"message,omitempty"`
	Tension      *TensionRef      `json:"tension"`
	BlobType     BlobType         `json:"blob_type"`
	PushedFlag   *string          `json:"pushedFlag,omitempty"`
	ArchivedFlag *string          `json:"archivedFlag,omitempty"`
	Node         *NodeFragmentRef `json:"node,omitempty"`
	Md           *string          `json:"md,omitempty"`
}

type AddBlobPayload struct {
	Blob    []*Blob `json:"blob,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type AddCommentInput struct {
	CreatedBy *UserRef       `json:"createdBy"`
	CreatedAt string         `json:"createdAt"`
	UpdatedAt *string        `json:"updatedAt,omitempty"`
	Message   *string        `json:"message,omitempty"`
	Reactions []*ReactionRef `json:"reactions,omitempty"`
}

type AddCommentPayload struct {
	Comment []*Comment `json:"comment,omitempty"`
	NumUids *int       `json:"numUids,omitempty"`
}

type AddContractInput struct {
	CreatedBy         *UserRef          `json:"createdBy"`
	CreatedAt         string            `json:"createdAt"`
	UpdatedAt         *string           `json:"updatedAt,omitempty"`
	Message           *string           `json:"message,omitempty"`
	Contractid        string            `json:"contractid"`
	Tension           *TensionRef       `json:"tension"`
	Status            ContractStatus    `json:"status"`
	ContractType      ContractType      `json:"contract_type"`
	ClosedAt          *string           `json:"closedAt,omitempty"`
	Event             *EventFragmentRef `json:"event"`
	Participants      []*VoteRef        `json:"participants"`
	Candidates        []*UserRef        `json:"candidates,omitempty"`
	PendingCandidates []*PendingUserRef `json:"pending_candidates,omitempty"`
	Comments          []*CommentRef     `json:"comments,omitempty"`
	IsValidator       *bool             `json:"isValidator,omitempty"`
}

type AddContractPayload struct {
	Contract []*Contract `json:"contract,omitempty"`
	NumUids  *int        `json:"numUids,omitempty"`
}

type AddEventCountInput struct {
	UnreadEvents     *int `json:"unread_events,omitempty"`
	PendingContracts *int `json:"pending_contracts,omitempty"`
	AssignedTensions *int `json:"assigned_tensions,omitempty"`
}

type AddEventCountPayload struct {
	EventCount []*EventCount `json:"eventCount,omitempty"`
	NumUids    *int          `json:"numUids,omitempty"`
}

type AddEventFragmentInput struct {
	EventType TensionEvent `json:"event_type"`
	Old       *string      `json:"old,omitempty"`
	New       *string      `json:"new,omitempty"`
}

type AddEventFragmentPayload struct {
	EventFragment []*EventFragment `json:"eventFragment,omitempty"`
	NumUids       *int             `json:"numUids,omitempty"`
}

type AddEventInput struct {
	CreatedBy *UserRef     `json:"createdBy"`
	CreatedAt string       `json:"createdAt"`
	UpdatedAt *string      `json:"updatedAt,omitempty"`
	Message   *string      `json:"message,omitempty"`
	Tension   *TensionRef  `json:"tension"`
	EventType TensionEvent `json:"event_type"`
	Mentioned *TensionRef  `json:"mentioned,omitempty"`
	Old       *string      `json:"old,omitempty"`
	New       *string      `json:"new,omitempty"`
}

type AddEventPayload struct {
	Event   []*Event `json:"event,omitempty"`
	NumUids *int     `json:"numUids,omitempty"`
}

type AddLabelInput struct {
	Rootnameid  string        `json:"rootnameid"`
	Name        string        `json:"name"`
	Description *string       `json:"description,omitempty"`
	Color       *string       `json:"color,omitempty"`
	Tensions    []*TensionRef `json:"tensions,omitempty"`
	Nodes       []*NodeRef    `json:"nodes,omitempty"`
}

type AddLabelPayload struct {
	Label   []*Label `json:"label,omitempty"`
	NumUids *int     `json:"numUids,omitempty"`
}

type AddMandateInput struct {
	Purpose          string  `json:"purpose"`
	Responsabilities *string `json:"responsabilities,omitempty"`
	Domains          *string `json:"domains,omitempty"`
	Policies         *string `json:"policies,omitempty"`
}

type AddMandatePayload struct {
	Mandate []*Mandate `json:"mandate,omitempty"`
	NumUids *int       `json:"numUids,omitempty"`
}

type AddNodeFragmentInput struct {
	Nameid     *string         `json:"nameid,omitempty"`
	Name       *string         `json:"name,omitempty"`
	About      *string         `json:"about,omitempty"`
	Mandate    *MandateRef     `json:"mandate,omitempty"`
	Skills     []string        `json:"skills,omitempty"`
	Visibility *NodeVisibility `json:"visibility,omitempty"`
	Mode       *NodeMode       `json:"mode,omitempty"`
	Type       *NodeType       `json:"type_,omitempty"`
	FirstLink  *string         `json:"first_link,omitempty"`
	RoleExt    *string         `json:"role_ext,omitempty"`
	RoleType   *RoleType       `json:"role_type,omitempty"`
	Color      *string         `json:"color,omitempty"`
}

type AddNodeFragmentPayload struct {
	NodeFragment []*NodeFragment `json:"nodeFragment,omitempty"`
	NumUids      *int            `json:"numUids,omitempty"`
}

type AddNodeInput struct {
	CreatedBy             *UserRef       `json:"createdBy"`
	CreatedAt             string         `json:"createdAt"`
	UpdatedAt             *string        `json:"updatedAt,omitempty"`
	Nameid                string         `json:"nameid"`
	Rootnameid            string         `json:"rootnameid"`
	Source                *BlobRef       `json:"source,omitempty"`
	Name                  string         `json:"name"`
	About                 *string        `json:"about,omitempty"`
	Skills                []string       `json:"skills,omitempty"`
	IsRoot                bool           `json:"isRoot"`
	Parent                *NodeRef       `json:"parent,omitempty"`
	Type                  NodeType       `json:"type_"`
	TensionsOut           []*TensionRef  `json:"tensions_out,omitempty"`
	TensionsIn            []*TensionRef  `json:"tensions_in,omitempty"`
	Visibility            NodeVisibility `json:"visibility"`
	Mode                  NodeMode       `json:"mode"`
	Rights                int            `json:"rights"`
	IsArchived            bool           `json:"isArchived"`
	IsPersonal            *bool          `json:"isPersonal,omitempty"`
	UserCanJoin           *bool          `json:"userCanJoin,omitempty"`
	GuestCanCreateTension *bool          `json:"guestCanCreateTension,omitempty"`
	Watchers              []*UserRef     `json:"watchers,omitempty"`
	Children              []*NodeRef     `json:"children,omitempty"`
	Labels                []*LabelRef    `json:"labels,omitempty"`
	Roles                 []*RoleExtRef  `json:"roles,omitempty"`
	Projects              []*ProjectRef  `json:"projects,omitempty"`
	Pinned                []*TensionRef  `json:"pinned,omitempty"`
	RoleExt               *RoleExtRef    `json:"role_ext,omitempty"`
	RoleType              *RoleType      `json:"role_type,omitempty"`
	Color                 *string        `json:"color,omitempty"`
	FirstLink             *UserRef       `json:"first_link,omitempty"`
	Contracts             []*VoteRef     `json:"contracts,omitempty"`
	EventsHistory         []*EventRef    `json:"events_history,omitempty"`
}

type AddNodePayload struct {
	Node    []*Node `json:"node,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type AddNotifInput struct {
	CreatedBy *UserRef     `json:"createdBy"`
	CreatedAt string       `json:"createdAt"`
	UpdatedAt *string      `json:"updatedAt,omitempty"`
	Message   *string      `json:"message,omitempty"`
	Tension   *TensionRef  `json:"tension_,omitempty"`
	Contract  *ContractRef `json:"contract,omitempty"`
	Link      *string      `json:"link,omitempty"`
}

type AddNotifPayload struct {
	Notif   []*Notif `json:"notif,omitempty"`
	NumUids *int     `json:"numUids,omitempty"`
}

type AddPendingUserInput struct {
	UpdatedAt  *string        `json:"updatedAt,omitempty"`
	Username   string         `json:"username"`
	Password   *string        `json:"password,omitempty"`
	Email      string         `json:"email"`
	EmailToken *string        `json:"email_token,omitempty"`
	Token      *string        `json:"token,omitempty"`
	Contracts  []*ContractRef `json:"contracts,omitempty"`
	Subscribe  *bool          `json:"subscribe,omitempty"`
}

type AddPendingUserPayload struct {
	PendingUser []*PendingUser `json:"pendingUser,omitempty"`
	NumUids     *int           `json:"numUids,omitempty"`
}

type AddProjectCardInput struct {
	Pos    int                     `json:"pos"`
	Card   *CardKindRef            `json:"card"`
	Pc     *ProjectColumnRef       `json:"pc"`
	Values []*ProjectFieldValueRef `json:"values,omitempty"`
}

type AddProjectCardPayload struct {
	ProjectCard []*ProjectCard `json:"projectCard,omitempty"`
	NumUids     *int           `json:"numUids,omitempty"`
}

type AddProjectColumnInput struct {
	Name        string            `json:"name"`
	Description *string           `json:"description,omitempty"`
	Color       *string           `json:"color,omitempty"`
	Pos         int               `json:"pos"`
	ColType     ProjectColumnType `json:"col_type"`
	Cards       []*ProjectCardRef `json:"cards,omitempty"`
	Project     *ProjectRef       `json:"project"`
	Tensions    []*TensionRef     `json:"tensions,omitempty"`
}

type AddProjectColumnPayload struct {
	ProjectColumn []*ProjectColumn `json:"projectColumn,omitempty"`
	NumUids       *int             `json:"numUids,omitempty"`
}

type AddProjectDraftInput struct {
	CreatedBy *UserRef `json:"createdBy"`
	CreatedAt string   `json:"createdAt"`
	UpdatedAt *string  `json:"updatedAt,omitempty"`
	Message   *string  `json:"message,omitempty"`
	Title     string   `json:"title"`
}

type AddProjectDraftPayload struct {
	ProjectDraft []*ProjectDraft `json:"projectDraft,omitempty"`
	NumUids      *int            `json:"numUids,omitempty"`
}

type AddProjectFieldInput struct {
	FieldType ProjectFieldType        `json:"field_type"`
	IsVisible bool                    `json:"isVisible"`
	Values    []*ProjectFieldValueRef `json:"values,omitempty"`
}

type AddProjectFieldPayload struct {
	ProjectField []*ProjectField `json:"projectField,omitempty"`
	NumUids      *int            `json:"numUids,omitempty"`
}

type AddProjectFieldValueInput struct {
	Field *ProjectFieldRef `json:"field"`
	Value string           `json:"value"`
	Pos   *int             `json:"pos,omitempty"`
}

type AddProjectFieldValuePayload struct {
	ProjectFieldValue []*ProjectFieldValue `json:"projectFieldValue,omitempty"`
	NumUids           *int                 `json:"numUids,omitempty"`
}

type AddProjectInput struct {
	CreatedBy    *UserRef            `json:"createdBy"`
	CreatedAt    string              `json:"createdAt"`
	UpdatedAt    string              `json:"updatedAt"`
	Rootnameid   string              `json:"rootnameid"`
	Parentnameid string              `json:"parentnameid"`
	Nameid       string              `json:"nameid"`
	Name         string              `json:"name"`
	Description  *string             `json:"description,omitempty"`
	Status       ProjectStatus       `json:"status"`
	Columns      []*ProjectColumnRef `json:"columns,omitempty"`
	Fields       []*ProjectFieldRef  `json:"fields,omitempty"`
	Leaders      []*NodeRef          `json:"leaders,omitempty"`
	Nodes        []*NodeRef          `json:"nodes,omitempty"`
}

type AddProjectPayload struct {
	Project []*Project `json:"project,omitempty"`
	NumUids *int       `json:"numUids,omitempty"`
}

type AddReactionInput struct {
	Reactionid string      `json:"reactionid"`
	User       *UserRef    `json:"user"`
	Comment    *CommentRef `json:"comment"`
	Type       int         `json:"type_"`
}

type AddReactionPayload struct {
	Reaction []*Reaction `json:"reaction,omitempty"`
	NumUids  *int        `json:"numUids,omitempty"`
}

type AddRoleExtInput struct {
	Rootnameid string      `json:"rootnameid"`
	Name       string      `json:"name"`
	About      *string     `json:"about,omitempty"`
	RoleType   RoleType    `json:"role_type"`
	Color      *string     `json:"color,omitempty"`
	Mandate    *MandateRef `json:"mandate,omitempty"`
	Roles      []*NodeRef  `json:"roles,omitempty"`
	Nodes      []*NodeRef  `json:"nodes,omitempty"`
}

type AddRoleExtPayload struct {
	RoleExt []*RoleExt `json:"roleExt,omitempty"`
	NumUids *int       `json:"numUids,omitempty"`
}

type AddTensionInput struct {
	CreatedBy       *UserRef            `json:"createdBy"`
	CreatedAt       string              `json:"createdAt"`
	UpdatedAt       *string             `json:"updatedAt,omitempty"`
	Message         *string             `json:"message,omitempty"`
	Emitter         *NodeRef            `json:"emitter"`
	Emitterid       string              `json:"emitterid"`
	Receiver        *NodeRef            `json:"receiver"`
	Receiverid      string              `json:"receiverid"`
	Title           string              `json:"title"`
	Type            TensionType         `json:"type_"`
	Status          TensionStatus       `json:"status"`
	Action          *TensionAction      `json:"action,omitempty"`
	Assignees       []*UserRef          `json:"assignees,omitempty"`
	Labels          []*LabelRef         `json:"labels,omitempty"`
	Comments        []*CommentRef       `json:"comments,omitempty"`
	Blobs           []*BlobRef          `json:"blobs,omitempty"`
	History         []*EventRef         `json:"history,omitempty"`
	Mentions        []*EventRef         `json:"mentions,omitempty"`
	Contracts       []*ContractRef      `json:"contracts,omitempty"`
	Subscribers     []*UserRef          `json:"subscribers,omitempty"`
	ProjectStatuses []*ProjectColumnRef `json:"project_statuses,omitempty"`
	NComments       *int                `json:"n_comments,omitempty"`
}

type AddTensionPayload struct {
	Tension []*Tension `json:"tension,omitempty"`
	NumUids *int       `json:"numUids,omitempty"`
}

type AddUserEventInput struct {
	CreatedAt string          `json:"createdAt"`
	IsRead    bool            `json:"isRead"`
	User      *UserRef        `json:"user"`
	Event     []*EventKindRef `json:"event,omitempty"`
}

type AddUserEventPayload struct {
	UserEvent []*UserEvent `json:"userEvent,omitempty"`
	NumUids   *int         `json:"numUids,omitempty"`
}

type AddUserInput struct {
	CreatedAt        string          `json:"createdAt"`
	LastAck          string          `json:"lastAck"`
	Username         string          `json:"username"`
	Name             *string         `json:"name,omitempty"`
	Email            string          `json:"email"`
	Password         string          `json:"password"`
	Bio              *string         `json:"bio,omitempty"`
	Location         *string         `json:"location,omitempty"`
	Utc              *string         `json:"utc,omitempty"`
	Links            []string        `json:"links,omitempty"`
	Skills           []string        `json:"skills,omitempty"`
	NotifyByEmail    bool            `json:"notifyByEmail"`
	Lang             Lang            `json:"lang"`
	Subscriptions    []*TensionRef   `json:"subscriptions,omitempty"`
	Watching         []*NodeRef      `json:"watching,omitempty"`
	Rights           *UserRightsRef  `json:"rights"`
	Roles            []*NodeRef      `json:"roles,omitempty"`
	TensionsCreated  []*TensionRef   `json:"tensions_created,omitempty"`
	TensionsAssigned []*TensionRef   `json:"tensions_assigned,omitempty"`
	Contracts        []*ContractRef  `json:"contracts,omitempty"`
	Reactions        []*ReactionRef  `json:"reactions,omitempty"`
	Events           []*UserEventRef `json:"events,omitempty"`
	MarkAllAsRead    *string         `json:"markAllAsRead,omitempty"`
	EventCount       *EventCountRef  `json:"event_count,omitempty"`
}

type AddUserPayload struct {
	User    []*User `json:"user,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type AddUserRightsInput struct {
	Type                  UserType `json:"type_"`
	CanLogin              bool     `json:"canLogin"`
	CanCreateRoot         bool     `json:"canCreateRoot"`
	MaxPublicOrga         int      `json:"maxPublicOrga"`
	MaxPrivateOrga        int      `json:"maxPrivateOrga"`
	HasEmailNotifications bool     `json:"hasEmailNotifications"`
}

type AddUserRightsPayload struct {
	UserRights []*UserRights `json:"userRights,omitempty"`
	NumUids    *int          `json:"numUids,omitempty"`
}

type AddVoteInput struct {
	CreatedBy *UserRef     `json:"createdBy"`
	CreatedAt string       `json:"createdAt"`
	UpdatedAt *string      `json:"updatedAt,omitempty"`
	Message   *string      `json:"message,omitempty"`
	Voteid    string       `json:"voteid"`
	Contract  *ContractRef `json:"contract"`
	Node      *NodeRef     `json:"node"`
	Data      []int        `json:"data"`
}

type AddVotePayload struct {
	Vote    []*Vote `json:"vote,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type AuthRule struct {
	And  []*AuthRule `json:"and,omitempty"`
	Or   []*AuthRule `json:"or,omitempty"`
	Not  *AuthRule   `json:"not,omitempty"`
	Rule *string     `json:"rule,omitempty"`
}

type Blob struct {
	Tension      *Tension      `json:"tension"`
	BlobType     BlobType      `json:"blob_type"`
	PushedFlag   *string       `json:"pushedFlag,omitempty"`
	ArchivedFlag *string       `json:"archivedFlag,omitempty"`
	Node         *NodeFragment `json:"node,omitempty"`
	Md           *string       `json:"md,omitempty"`
	ID           string        `json:"id"`
	CreatedBy    *User         `json:"createdBy"`
	CreatedAt    string        `json:"createdAt"`
	UpdatedAt    *string       `json:"updatedAt,omitempty"`
	Message      *string       `json:"message,omitempty"`
}

type BlobAggregateResult struct {
	Count           *int    `json:"count,omitempty"`
	CreatedAtMin    *string `json:"createdAtMin,omitempty"`
	CreatedAtMax    *string `json:"createdAtMax,omitempty"`
	UpdatedAtMin    *string `json:"updatedAtMin,omitempty"`
	UpdatedAtMax    *string `json:"updatedAtMax,omitempty"`
	MessageMin      *string `json:"messageMin,omitempty"`
	MessageMax      *string `json:"messageMax,omitempty"`
	PushedFlagMin   *string `json:"pushedFlagMin,omitempty"`
	PushedFlagMax   *string `json:"pushedFlagMax,omitempty"`
	ArchivedFlagMin *string `json:"archivedFlagMin,omitempty"`
	ArchivedFlagMax *string `json:"archivedFlagMax,omitempty"`
	MdMin           *string `json:"mdMin,omitempty"`
	MdMax           *string `json:"mdMax,omitempty"`
}

type BlobFilter struct {
	ID           []string              `json:"id,omitempty"`
	CreatedAt    *DateTimeFilter       `json:"createdAt,omitempty"`
	Message      *StringFullTextFilter `json:"message,omitempty"`
	BlobType     *BlobTypeHash         `json:"blob_type,omitempty"`
	PushedFlag   *DateTimeFilter       `json:"pushedFlag,omitempty"`
	ArchivedFlag *DateTimeFilter       `json:"archivedFlag,omitempty"`
	Has          []*BlobHasFilter      `json:"has,omitempty"`
	And          []*BlobFilter         `json:"and,omitempty"`
	Or           []*BlobFilter         `json:"or,omitempty"`
	Not          *BlobFilter           `json:"not,omitempty"`
}

type BlobOrder struct {
	Asc  *BlobOrderable `json:"asc,omitempty"`
	Desc *BlobOrderable `json:"desc,omitempty"`
	Then *BlobOrder     `json:"then,omitempty"`
}

type BlobPatch struct {
	CreatedBy    *UserRef         `json:"createdBy,omitempty"`
	CreatedAt    *string          `json:"createdAt,omitempty"`
	UpdatedAt    *string          `json:"updatedAt,omitempty"`
	Message      *string          `json:"message,omitempty"`
	Tension      *TensionRef      `json:"tension,omitempty"`
	BlobType     *BlobType        `json:"blob_type,omitempty"`
	PushedFlag   *string          `json:"pushedFlag,omitempty"`
	ArchivedFlag *string          `json:"archivedFlag,omitempty"`
	Node         *NodeFragmentRef `json:"node,omitempty"`
	Md           *string          `json:"md,omitempty"`
}

type BlobRef struct {
	ID           *string          `json:"id,omitempty"`
	CreatedBy    *UserRef         `json:"createdBy,omitempty"`
	CreatedAt    *string          `json:"createdAt,omitempty"`
	UpdatedAt    *string          `json:"updatedAt,omitempty"`
	Message      *string          `json:"message,omitempty"`
	Tension      *TensionRef      `json:"tension,omitempty"`
	BlobType     *BlobType        `json:"blob_type,omitempty"`
	PushedFlag   *string          `json:"pushedFlag,omitempty"`
	ArchivedFlag *string          `json:"archivedFlag,omitempty"`
	Node         *NodeFragmentRef `json:"node,omitempty"`
	Md           *string          `json:"md,omitempty"`
}

type BlobTypeHash struct {
	Eq *BlobType   `json:"eq,omitempty"`
	In []*BlobType `json:"in,omitempty"`
}

type CardKindFilter struct {
	MemberTypes        []CardKindType      `json:"memberTypes,omitempty"`
	TensionFilter      *TensionFilter      `json:"tensionFilter,omitempty"`
	ProjectDraftFilter *ProjectDraftFilter `json:"projectDraftFilter,omitempty"`
}

type CardKindRef struct {
	TensionRef      *TensionRef      `json:"tensionRef,omitempty"`
	ProjectDraftRef *ProjectDraftRef `json:"projectDraftRef,omitempty"`
}

type Comment struct {
	Message            string                   `json:"message"`
	Reactions          []*Reaction              `json:"reactions,omitempty"`
	ID                 string                   `json:"id"`
	CreatedBy          *User                    `json:"createdBy"`
	CreatedAt          string                   `json:"createdAt"`
	UpdatedAt          *string                  `json:"updatedAt,omitempty"`
	ReactionsAggregate *ReactionAggregateResult `json:"reactionsAggregate,omitempty"`
}

type CommentAggregateResult struct {
	Count        *int    `json:"count,omitempty"`
	CreatedAtMin *string `json:"createdAtMin,omitempty"`
	CreatedAtMax *string `json:"createdAtMax,omitempty"`
	UpdatedAtMin *string `json:"updatedAtMin,omitempty"`
	UpdatedAtMax *string `json:"updatedAtMax,omitempty"`
	MessageMin   *string `json:"messageMin,omitempty"`
	MessageMax   *string `json:"messageMax,omitempty"`
}

type CommentFilter struct {
	ID        []string              `json:"id,omitempty"`
	CreatedAt *DateTimeFilter       `json:"createdAt,omitempty"`
	Message   *StringFullTextFilter `json:"message,omitempty"`
	Has       []*CommentHasFilter   `json:"has,omitempty"`
	And       []*CommentFilter      `json:"and,omitempty"`
	Or        []*CommentFilter      `json:"or,omitempty"`
	Not       *CommentFilter        `json:"not,omitempty"`
}

type CommentOrder struct {
	Asc  *CommentOrderable `json:"asc,omitempty"`
	Desc *CommentOrderable `json:"desc,omitempty"`
	Then *CommentOrder     `json:"then,omitempty"`
}

type CommentPatch struct {
	CreatedBy *UserRef       `json:"createdBy,omitempty"`
	CreatedAt *string        `json:"createdAt,omitempty"`
	UpdatedAt *string        `json:"updatedAt,omitempty"`
	Message   *string        `json:"message,omitempty"`
	Reactions []*ReactionRef `json:"reactions,omitempty"`
}

type CommentRef struct {
	ID        *string        `json:"id,omitempty"`
	CreatedBy *UserRef       `json:"createdBy,omitempty"`
	CreatedAt *string        `json:"createdAt,omitempty"`
	UpdatedAt *string        `json:"updatedAt,omitempty"`
	Message   *string        `json:"message,omitempty"`
	Reactions []*ReactionRef `json:"reactions,omitempty"`
}

type ContainsFilter struct {
	Point   *PointRef   `json:"point,omitempty"`
	Polygon *PolygonRef `json:"polygon,omitempty"`
}

type Contract struct {
	Contractid                 string                      `json:"contractid"`
	Tension                    *Tension                    `json:"tension"`
	Status                     ContractStatus              `json:"status"`
	ContractType               ContractType                `json:"contract_type"`
	ClosedAt                   *string                     `json:"closedAt,omitempty"`
	Event                      *EventFragment              `json:"event"`
	Participants               []*Vote                     `json:"participants"`
	Candidates                 []*User                     `json:"candidates,omitempty"`
	PendingCandidates          []*PendingUser              `json:"pending_candidates,omitempty"`
	Comments                   []*Comment                  `json:"comments,omitempty"`
	IsValidator                *bool                       `json:"isValidator,omitempty"`
	ID                         string                      `json:"id"`
	CreatedBy                  *User                       `json:"createdBy"`
	CreatedAt                  string                      `json:"createdAt"`
	UpdatedAt                  *string                     `json:"updatedAt,omitempty"`
	Message                    *string                     `json:"message,omitempty"`
	ParticipantsAggregate      *VoteAggregateResult        `json:"participantsAggregate,omitempty"`
	CandidatesAggregate        *UserAggregateResult        `json:"candidatesAggregate,omitempty"`
	PendingCandidatesAggregate *PendingUserAggregateResult `json:"pending_candidatesAggregate,omitempty"`
	CommentsAggregate          *CommentAggregateResult     `json:"commentsAggregate,omitempty"`
}

func (Contract) IsEventKind() {}

type ContractAggregateResult struct {
	Count         *int    `json:"count,omitempty"`
	CreatedAtMin  *string `json:"createdAtMin,omitempty"`
	CreatedAtMax  *string `json:"createdAtMax,omitempty"`
	UpdatedAtMin  *string `json:"updatedAtMin,omitempty"`
	UpdatedAtMax  *string `json:"updatedAtMax,omitempty"`
	MessageMin    *string `json:"messageMin,omitempty"`
	MessageMax    *string `json:"messageMax,omitempty"`
	ContractidMin *string `json:"contractidMin,omitempty"`
	ContractidMax *string `json:"contractidMax,omitempty"`
	ClosedAtMin   *string `json:"closedAtMin,omitempty"`
	ClosedAtMax   *string `json:"closedAtMax,omitempty"`
}

type ContractFilter struct {
	ID           []string              `json:"id,omitempty"`
	CreatedAt    *DateTimeFilter       `json:"createdAt,omitempty"`
	Message      *StringFullTextFilter `json:"message,omitempty"`
	Contractid   *StringHashFilter     `json:"contractid,omitempty"`
	Status       *ContractStatusHash   `json:"status,omitempty"`
	ContractType *ContractTypeHash     `json:"contract_type,omitempty"`
	ClosedAt     *DateTimeFilter       `json:"closedAt,omitempty"`
	Has          []*ContractHasFilter  `json:"has,omitempty"`
	And          []*ContractFilter     `json:"and,omitempty"`
	Or           []*ContractFilter     `json:"or,omitempty"`
	Not          *ContractFilter       `json:"not,omitempty"`
}

type ContractOrder struct {
	Asc  *ContractOrderable `json:"asc,omitempty"`
	Desc *ContractOrderable `json:"desc,omitempty"`
	Then *ContractOrder     `json:"then,omitempty"`
}

type ContractPatch struct {
	CreatedBy         *UserRef          `json:"createdBy,omitempty"`
	CreatedAt         *string           `json:"createdAt,omitempty"`
	UpdatedAt         *string           `json:"updatedAt,omitempty"`
	Message           *string           `json:"message,omitempty"`
	Tension           *TensionRef       `json:"tension,omitempty"`
	Status            *ContractStatus   `json:"status,omitempty"`
	ContractType      *ContractType     `json:"contract_type,omitempty"`
	ClosedAt          *string           `json:"closedAt,omitempty"`
	Event             *EventFragmentRef `json:"event,omitempty"`
	Participants      []*VoteRef        `json:"participants,omitempty"`
	Candidates        []*UserRef        `json:"candidates,omitempty"`
	PendingCandidates []*PendingUserRef `json:"pending_candidates,omitempty"`
	Comments          []*CommentRef     `json:"comments,omitempty"`
	IsValidator       *bool             `json:"isValidator,omitempty"`
}

type ContractRef struct {
	ID                *string           `json:"id,omitempty"`
	CreatedBy         *UserRef          `json:"createdBy,omitempty"`
	CreatedAt         *string           `json:"createdAt,omitempty"`
	UpdatedAt         *string           `json:"updatedAt,omitempty"`
	Message           *string           `json:"message,omitempty"`
	Contractid        *string           `json:"contractid,omitempty"`
	Tension           *TensionRef       `json:"tension,omitempty"`
	Status            *ContractStatus   `json:"status,omitempty"`
	ContractType      *ContractType     `json:"contract_type,omitempty"`
	ClosedAt          *string           `json:"closedAt,omitempty"`
	Event             *EventFragmentRef `json:"event,omitempty"`
	Participants      []*VoteRef        `json:"participants,omitempty"`
	Candidates        []*UserRef        `json:"candidates,omitempty"`
	PendingCandidates []*PendingUserRef `json:"pending_candidates,omitempty"`
	Comments          []*CommentRef     `json:"comments,omitempty"`
	IsValidator       *bool             `json:"isValidator,omitempty"`
}

type ContractStatusHash struct {
	Eq *ContractStatus   `json:"eq,omitempty"`
	In []*ContractStatus `json:"in,omitempty"`
}

type ContractTypeHash struct {
	Eq *ContractType   `json:"eq,omitempty"`
	In []*ContractType `json:"in,omitempty"`
}

type CustomHTTP struct {
	URL                  string     `json:"url"`
	Method               HTTPMethod `json:"method"`
	Body                 *string    `json:"body,omitempty"`
	Graphql              *string    `json:"graphql,omitempty"`
	Mode                 *Mode      `json:"mode,omitempty"`
	ForwardHeaders       []string   `json:"forwardHeaders,omitempty"`
	SecretHeaders        []string   `json:"secretHeaders,omitempty"`
	IntrospectionHeaders []string   `json:"introspectionHeaders,omitempty"`
	SkipIntrospection    *bool      `json:"skipIntrospection,omitempty"`
}

type DateTimeFilter struct {
	Eq      *string        `json:"eq,omitempty"`
	In      []*string      `json:"in,omitempty"`
	Le      *string        `json:"le,omitempty"`
	Lt      *string        `json:"lt,omitempty"`
	Ge      *string        `json:"ge,omitempty"`
	Gt      *string        `json:"gt,omitempty"`
	Between *DateTimeRange `json:"between,omitempty"`
}

type DateTimeRange struct {
	Min string `json:"min"`
	Max string `json:"max"`
}

type DeleteBlobPayload struct {
	Blob    []*Blob `json:"blob,omitempty"`
	Msg     *string `json:"msg,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type DeleteCommentPayload struct {
	Comment []*Comment `json:"comment,omitempty"`
	Msg     *string    `json:"msg,omitempty"`
	NumUids *int       `json:"numUids,omitempty"`
}

type DeleteContractPayload struct {
	Contract []*Contract `json:"contract,omitempty"`
	Msg      *string     `json:"msg,omitempty"`
	NumUids  *int        `json:"numUids,omitempty"`
}

type DeleteEventCountPayload struct {
	EventCount []*EventCount `json:"eventCount,omitempty"`
	Msg        *string       `json:"msg,omitempty"`
	NumUids    *int          `json:"numUids,omitempty"`
}

type DeleteEventFragmentPayload struct {
	EventFragment []*EventFragment `json:"eventFragment,omitempty"`
	Msg           *string          `json:"msg,omitempty"`
	NumUids       *int             `json:"numUids,omitempty"`
}

type DeleteEventPayload struct {
	Event   []*Event `json:"event,omitempty"`
	Msg     *string  `json:"msg,omitempty"`
	NumUids *int     `json:"numUids,omitempty"`
}

type DeleteLabelPayload struct {
	Label   []*Label `json:"label,omitempty"`
	Msg     *string  `json:"msg,omitempty"`
	NumUids *int     `json:"numUids,omitempty"`
}

type DeleteMandatePayload struct {
	Mandate []*Mandate `json:"mandate,omitempty"`
	Msg     *string    `json:"msg,omitempty"`
	NumUids *int       `json:"numUids,omitempty"`
}

type DeleteNodeFragmentPayload struct {
	NodeFragment []*NodeFragment `json:"nodeFragment,omitempty"`
	Msg          *string         `json:"msg,omitempty"`
	NumUids      *int            `json:"numUids,omitempty"`
}

type DeleteNodePayload struct {
	Node    []*Node `json:"node,omitempty"`
	Msg     *string `json:"msg,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type DeleteNotifPayload struct {
	Notif   []*Notif `json:"notif,omitempty"`
	Msg     *string  `json:"msg,omitempty"`
	NumUids *int     `json:"numUids,omitempty"`
}

type DeletePendingUserPayload struct {
	PendingUser []*PendingUser `json:"pendingUser,omitempty"`
	Msg         *string        `json:"msg,omitempty"`
	NumUids     *int           `json:"numUids,omitempty"`
}

type DeletePostPayload struct {
	Post    []*Post `json:"post,omitempty"`
	Msg     *string `json:"msg,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type DeleteProjectCardPayload struct {
	ProjectCard []*ProjectCard `json:"projectCard,omitempty"`
	Msg         *string        `json:"msg,omitempty"`
	NumUids     *int           `json:"numUids,omitempty"`
}

type DeleteProjectColumnPayload struct {
	ProjectColumn []*ProjectColumn `json:"projectColumn,omitempty"`
	Msg           *string          `json:"msg,omitempty"`
	NumUids       *int             `json:"numUids,omitempty"`
}

type DeleteProjectDraftPayload struct {
	ProjectDraft []*ProjectDraft `json:"projectDraft,omitempty"`
	Msg          *string         `json:"msg,omitempty"`
	NumUids      *int            `json:"numUids,omitempty"`
}

type DeleteProjectFieldPayload struct {
	ProjectField []*ProjectField `json:"projectField,omitempty"`
	Msg          *string         `json:"msg,omitempty"`
	NumUids      *int            `json:"numUids,omitempty"`
}

type DeleteProjectFieldValuePayload struct {
	ProjectFieldValue []*ProjectFieldValue `json:"projectFieldValue,omitempty"`
	Msg               *string              `json:"msg,omitempty"`
	NumUids           *int                 `json:"numUids,omitempty"`
}

type DeleteProjectPayload struct {
	Project []*Project `json:"project,omitempty"`
	Msg     *string    `json:"msg,omitempty"`
	NumUids *int       `json:"numUids,omitempty"`
}

type DeleteReactionPayload struct {
	Reaction []*Reaction `json:"reaction,omitempty"`
	Msg      *string     `json:"msg,omitempty"`
	NumUids  *int        `json:"numUids,omitempty"`
}

type DeleteRoleExtPayload struct {
	RoleExt []*RoleExt `json:"roleExt,omitempty"`
	Msg     *string    `json:"msg,omitempty"`
	NumUids *int       `json:"numUids,omitempty"`
}

type DeleteTensionPayload struct {
	Tension []*Tension `json:"tension,omitempty"`
	Msg     *string    `json:"msg,omitempty"`
	NumUids *int       `json:"numUids,omitempty"`
}

type DeleteUserEventPayload struct {
	UserEvent []*UserEvent `json:"userEvent,omitempty"`
	Msg       *string      `json:"msg,omitempty"`
	NumUids   *int         `json:"numUids,omitempty"`
}

type DeleteUserPayload struct {
	User    []*User `json:"user,omitempty"`
	Msg     *string `json:"msg,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type DeleteUserRightsPayload struct {
	UserRights []*UserRights `json:"userRights,omitempty"`
	Msg        *string       `json:"msg,omitempty"`
	NumUids    *int          `json:"numUids,omitempty"`
}

type DeleteVotePayload struct {
	Vote    []*Vote `json:"vote,omitempty"`
	Msg     *string `json:"msg,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type Event struct {
	Tension   *Tension     `json:"tension"`
	EventType TensionEvent `json:"event_type"`
	Mentioned *Tension     `json:"mentioned,omitempty"`
	Old       *string      `json:"old,omitempty"`
	New       *string      `json:"new,omitempty"`
	ID        string       `json:"id"`
	CreatedBy *User        `json:"createdBy"`
	CreatedAt string       `json:"createdAt"`
	UpdatedAt *string      `json:"updatedAt,omitempty"`
	Message   *string      `json:"message,omitempty"`
}

func (Event) IsEventKind() {}

type EventAggregateResult struct {
	Count        *int    `json:"count,omitempty"`
	CreatedAtMin *string `json:"createdAtMin,omitempty"`
	CreatedAtMax *string `json:"createdAtMax,omitempty"`
	UpdatedAtMin *string `json:"updatedAtMin,omitempty"`
	UpdatedAtMax *string `json:"updatedAtMax,omitempty"`
	MessageMin   *string `json:"messageMin,omitempty"`
	MessageMax   *string `json:"messageMax,omitempty"`
	OldMin       *string `json:"oldMin,omitempty"`
	OldMax       *string `json:"oldMax,omitempty"`
	NewMin       *string `json:"newMin,omitempty"`
	NewMax       *string `json:"newMax,omitempty"`
}

type EventCount struct {
	UnreadEvents     *int `json:"unread_events,omitempty"`
	PendingContracts *int `json:"pending_contracts,omitempty"`
	AssignedTensions *int `json:"assigned_tensions,omitempty"`
}

type EventCountAggregateResult struct {
	Count               *int     `json:"count,omitempty"`
	UnreadEventsMin     *int     `json:"unread_eventsMin,omitempty"`
	UnreadEventsMax     *int     `json:"unread_eventsMax,omitempty"`
	UnreadEventsSum     *int     `json:"unread_eventsSum,omitempty"`
	UnreadEventsAvg     *float64 `json:"unread_eventsAvg,omitempty"`
	PendingContractsMin *int     `json:"pending_contractsMin,omitempty"`
	PendingContractsMax *int     `json:"pending_contractsMax,omitempty"`
	PendingContractsSum *int     `json:"pending_contractsSum,omitempty"`
	PendingContractsAvg *float64 `json:"pending_contractsAvg,omitempty"`
	AssignedTensionsMin *int     `json:"assigned_tensionsMin,omitempty"`
	AssignedTensionsMax *int     `json:"assigned_tensionsMax,omitempty"`
	AssignedTensionsSum *int     `json:"assigned_tensionsSum,omitempty"`
	AssignedTensionsAvg *float64 `json:"assigned_tensionsAvg,omitempty"`
}

type EventCountFilter struct {
	Has []*EventCountHasFilter `json:"has,omitempty"`
	And []*EventCountFilter    `json:"and,omitempty"`
	Or  []*EventCountFilter    `json:"or,omitempty"`
	Not *EventCountFilter      `json:"not,omitempty"`
}

type EventCountOrder struct {
	Asc  *EventCountOrderable `json:"asc,omitempty"`
	Desc *EventCountOrderable `json:"desc,omitempty"`
	Then *EventCountOrder     `json:"then,omitempty"`
}

type EventCountPatch struct {
	UnreadEvents     *int `json:"unread_events,omitempty"`
	PendingContracts *int `json:"pending_contracts,omitempty"`
	AssignedTensions *int `json:"assigned_tensions,omitempty"`
}

type EventCountRef struct {
	UnreadEvents     *int `json:"unread_events,omitempty"`
	PendingContracts *int `json:"pending_contracts,omitempty"`
	AssignedTensions *int `json:"assigned_tensions,omitempty"`
}

type EventFilter struct {
	ID        []string              `json:"id,omitempty"`
	CreatedAt *DateTimeFilter       `json:"createdAt,omitempty"`
	Message   *StringFullTextFilter `json:"message,omitempty"`
	EventType *TensionEventHash     `json:"event_type,omitempty"`
	Has       []*EventHasFilter     `json:"has,omitempty"`
	And       []*EventFilter        `json:"and,omitempty"`
	Or        []*EventFilter        `json:"or,omitempty"`
	Not       *EventFilter          `json:"not,omitempty"`
}

type EventFragment struct {
	EventType TensionEvent `json:"event_type"`
	Old       *string      `json:"old,omitempty"`
	New       *string      `json:"new,omitempty"`
}

type EventFragmentAggregateResult struct {
	Count  *int    `json:"count,omitempty"`
	OldMin *string `json:"oldMin,omitempty"`
	OldMax *string `json:"oldMax,omitempty"`
	NewMin *string `json:"newMin,omitempty"`
	NewMax *string `json:"newMax,omitempty"`
}

type EventFragmentFilter struct {
	EventType *TensionEventHash         `json:"event_type,omitempty"`
	Has       []*EventFragmentHasFilter `json:"has,omitempty"`
	And       []*EventFragmentFilter    `json:"and,omitempty"`
	Or        []*EventFragmentFilter    `json:"or,omitempty"`
	Not       *EventFragmentFilter      `json:"not,omitempty"`
}

type EventFragmentOrder struct {
	Asc  *EventFragmentOrderable `json:"asc,omitempty"`
	Desc *EventFragmentOrderable `json:"desc,omitempty"`
	Then *EventFragmentOrder     `json:"then,omitempty"`
}

type EventFragmentPatch struct {
	EventType *TensionEvent `json:"event_type,omitempty"`
	Old       *string       `json:"old,omitempty"`
	New       *string       `json:"new,omitempty"`
}

type EventFragmentRef struct {
	EventType *TensionEvent `json:"event_type,omitempty"`
	Old       *string       `json:"old,omitempty"`
	New       *string       `json:"new,omitempty"`
}

type EventKindFilter struct {
	MemberTypes    []EventKindType `json:"memberTypes,omitempty"`
	EventFilter    *EventFilter    `json:"eventFilter,omitempty"`
	ContractFilter *ContractFilter `json:"contractFilter,omitempty"`
	NotifFilter    *NotifFilter    `json:"notifFilter,omitempty"`
}

type EventKindRef struct {
	EventRef    *EventRef    `json:"eventRef,omitempty"`
	ContractRef *ContractRef `json:"contractRef,omitempty"`
	NotifRef    *NotifRef    `json:"notifRef,omitempty"`
}

type EventOrder struct {
	Asc  *EventOrderable `json:"asc,omitempty"`
	Desc *EventOrderable `json:"desc,omitempty"`
	Then *EventOrder     `json:"then,omitempty"`
}

type EventPatch struct {
	CreatedBy *UserRef      `json:"createdBy,omitempty"`
	CreatedAt *string       `json:"createdAt,omitempty"`
	UpdatedAt *string       `json:"updatedAt,omitempty"`
	Message   *string       `json:"message,omitempty"`
	Tension   *TensionRef   `json:"tension,omitempty"`
	EventType *TensionEvent `json:"event_type,omitempty"`
	Mentioned *TensionRef   `json:"mentioned,omitempty"`
	Old       *string       `json:"old,omitempty"`
	New       *string       `json:"new,omitempty"`
}

type EventRef struct {
	ID        *string       `json:"id,omitempty"`
	CreatedBy *UserRef      `json:"createdBy,omitempty"`
	CreatedAt *string       `json:"createdAt,omitempty"`
	UpdatedAt *string       `json:"updatedAt,omitempty"`
	Message   *string       `json:"message,omitempty"`
	Tension   *TensionRef   `json:"tension,omitempty"`
	EventType *TensionEvent `json:"event_type,omitempty"`
	Mentioned *TensionRef   `json:"mentioned,omitempty"`
	Old       *string       `json:"old,omitempty"`
	New       *string       `json:"new,omitempty"`
}

type FloatFilter struct {
	Eq      *float64    `json:"eq,omitempty"`
	In      []*float64  `json:"in,omitempty"`
	Le      *float64    `json:"le,omitempty"`
	Lt      *float64    `json:"lt,omitempty"`
	Ge      *float64    `json:"ge,omitempty"`
	Gt      *float64    `json:"gt,omitempty"`
	Between *FloatRange `json:"between,omitempty"`
}

type FloatRange struct {
	Min float64 `json:"min"`
	Max float64 `json:"max"`
}

type GenerateMutationParams struct {
	Add    *bool `json:"add,omitempty"`
	Update *bool `json:"update,omitempty"`
	Delete *bool `json:"delete,omitempty"`
}

type GenerateQueryParams struct {
	Get       *bool `json:"get,omitempty"`
	Query     *bool `json:"query,omitempty"`
	Password  *bool `json:"password,omitempty"`
	Aggregate *bool `json:"aggregate,omitempty"`
}

type Int64Filter struct {
	Eq      *string     `json:"eq,omitempty"`
	In      []*string   `json:"in,omitempty"`
	Le      *string     `json:"le,omitempty"`
	Lt      *string     `json:"lt,omitempty"`
	Ge      *string     `json:"ge,omitempty"`
	Gt      *string     `json:"gt,omitempty"`
	Between *Int64Range `json:"between,omitempty"`
}

type Int64Range struct {
	Min string `json:"min"`
	Max string `json:"max"`
}

type IntFilter struct {
	Eq      *int      `json:"eq,omitempty"`
	In      []*int    `json:"in,omitempty"`
	Le      *int      `json:"le,omitempty"`
	Lt      *int      `json:"lt,omitempty"`
	Ge      *int      `json:"ge,omitempty"`
	Gt      *int      `json:"gt,omitempty"`
	Between *IntRange `json:"between,omitempty"`
}

type IntRange struct {
	Min int `json:"min"`
	Max int `json:"max"`
}

type IntersectsFilter struct {
	Polygon      *PolygonRef      `json:"polygon,omitempty"`
	MultiPolygon *MultiPolygonRef `json:"multiPolygon,omitempty"`
}

type Label struct {
	ID                string                  `json:"id"`
	Rootnameid        string                  `json:"rootnameid"`
	Name              string                  `json:"name"`
	Description       *string                 `json:"description,omitempty"`
	Color             *string                 `json:"color,omitempty"`
	Tensions          []*Tension              `json:"tensions,omitempty"`
	Nodes             []*Node                 `json:"nodes,omitempty"`
	TensionsAggregate *TensionAggregateResult `json:"tensionsAggregate,omitempty"`
	NodesAggregate    *NodeAggregateResult    `json:"nodesAggregate,omitempty"`
}

type LabelAggregateResult struct {
	Count          *int    `json:"count,omitempty"`
	RootnameidMin  *string `json:"rootnameidMin,omitempty"`
	RootnameidMax  *string `json:"rootnameidMax,omitempty"`
	NameMin        *string `json:"nameMin,omitempty"`
	NameMax        *string `json:"nameMax,omitempty"`
	DescriptionMin *string `json:"descriptionMin,omitempty"`
	DescriptionMax *string `json:"descriptionMax,omitempty"`
	ColorMin       *string `json:"colorMin,omitempty"`
	ColorMax       *string `json:"colorMax,omitempty"`
}

type LabelFilter struct {
	ID         []string                          `json:"id,omitempty"`
	Rootnameid *StringHashFilter                 `json:"rootnameid,omitempty"`
	Name       *StringHashFilterStringTermFilter `json:"name,omitempty"`
	Has        []*LabelHasFilter                 `json:"has,omitempty"`
	And        []*LabelFilter                    `json:"and,omitempty"`
	Or         []*LabelFilter                    `json:"or,omitempty"`
	Not        *LabelFilter                      `json:"not,omitempty"`
}

type LabelOrder struct {
	Asc  *LabelOrderable `json:"asc,omitempty"`
	Desc *LabelOrderable `json:"desc,omitempty"`
	Then *LabelOrder     `json:"then,omitempty"`
}

type LabelPatch struct {
	Rootnameid  *string       `json:"rootnameid,omitempty"`
	Name        *string       `json:"name,omitempty"`
	Description *string       `json:"description,omitempty"`
	Color       *string       `json:"color,omitempty"`
	Tensions    []*TensionRef `json:"tensions,omitempty"`
	Nodes       []*NodeRef    `json:"nodes,omitempty"`
}

type LabelRef struct {
	ID          *string       `json:"id,omitempty"`
	Rootnameid  *string       `json:"rootnameid,omitempty"`
	Name        *string       `json:"name,omitempty"`
	Description *string       `json:"description,omitempty"`
	Color       *string       `json:"color,omitempty"`
	Tensions    []*TensionRef `json:"tensions,omitempty"`
	Nodes       []*NodeRef    `json:"nodes,omitempty"`
}

type Mandate struct {
	ID               string  `json:"id"`
	Purpose          string  `json:"purpose"`
	Responsabilities *string `json:"responsabilities,omitempty"`
	Domains          *string `json:"domains,omitempty"`
	Policies         *string `json:"policies,omitempty"`
}

type MandateAggregateResult struct {
	Count               *int    `json:"count,omitempty"`
	PurposeMin          *string `json:"purposeMin,omitempty"`
	PurposeMax          *string `json:"purposeMax,omitempty"`
	ResponsabilitiesMin *string `json:"responsabilitiesMin,omitempty"`
	ResponsabilitiesMax *string `json:"responsabilitiesMax,omitempty"`
	DomainsMin          *string `json:"domainsMin,omitempty"`
	DomainsMax          *string `json:"domainsMax,omitempty"`
	PoliciesMin         *string `json:"policiesMin,omitempty"`
	PoliciesMax         *string `json:"policiesMax,omitempty"`
}

type MandateFilter struct {
	ID      []string              `json:"id,omitempty"`
	Purpose *StringFullTextFilter `json:"purpose,omitempty"`
	Has     []*MandateHasFilter   `json:"has,omitempty"`
	And     []*MandateFilter      `json:"and,omitempty"`
	Or      []*MandateFilter      `json:"or,omitempty"`
	Not     *MandateFilter        `json:"not,omitempty"`
}

type MandateOrder struct {
	Asc  *MandateOrderable `json:"asc,omitempty"`
	Desc *MandateOrderable `json:"desc,omitempty"`
	Then *MandateOrder     `json:"then,omitempty"`
}

type MandatePatch struct {
	Purpose          *string `json:"purpose,omitempty"`
	Responsabilities *string `json:"responsabilities,omitempty"`
	Domains          *string `json:"domains,omitempty"`
	Policies         *string `json:"policies,omitempty"`
}

type MandateRef struct {
	ID               *string `json:"id,omitempty"`
	Purpose          *string `json:"purpose,omitempty"`
	Responsabilities *string `json:"responsabilities,omitempty"`
	Domains          *string `json:"domains,omitempty"`
	Policies         *string `json:"policies,omitempty"`
}

type MultiPolygon struct {
	Polygons []*Polygon `json:"polygons"`
}

type MultiPolygonRef struct {
	Polygons []*PolygonRef `json:"polygons"`
}

type NearFilter struct {
	Distance   float64   `json:"distance"`
	Coordinate *PointRef `json:"coordinate"`
}

type Node struct {
	ID                     string                  `json:"id"`
	CreatedBy              *User                   `json:"createdBy"`
	CreatedAt              string                  `json:"createdAt"`
	UpdatedAt              *string                 `json:"updatedAt,omitempty"`
	Nameid                 string                  `json:"nameid"`
	Rootnameid             string                  `json:"rootnameid"`
	Source                 *Blob                   `json:"source,omitempty"`
	Name                   string                  `json:"name"`
	About                  *string                 `json:"about,omitempty"`
	Skills                 []string                `json:"skills,omitempty"`
	IsRoot                 bool                    `json:"isRoot"`
	Parent                 *Node                   `json:"parent,omitempty"`
	Type                   NodeType                `json:"type_"`
	TensionsOut            []*Tension              `json:"tensions_out,omitempty"`
	TensionsIn             []*Tension              `json:"tensions_in,omitempty"`
	Visibility             NodeVisibility          `json:"visibility"`
	Mode                   NodeMode                `json:"mode"`
	Rights                 int                     `json:"rights"`
	IsArchived             bool                    `json:"isArchived"`
	IsPersonal             *bool                   `json:"isPersonal,omitempty"`
	UserCanJoin            *bool                   `json:"userCanJoin,omitempty"`
	GuestCanCreateTension  *bool                   `json:"guestCanCreateTension,omitempty"`
	Watchers               []*User                 `json:"watchers,omitempty"`
	Children               []*Node                 `json:"children,omitempty"`
	Labels                 []*Label                `json:"labels,omitempty"`
	Roles                  []*RoleExt              `json:"roles,omitempty"`
	Projects               []*Project              `json:"projects,omitempty"`
	Pinned                 []*Tension              `json:"pinned,omitempty"`
	RoleExt                *RoleExt                `json:"role_ext,omitempty"`
	RoleType               *RoleType               `json:"role_type,omitempty"`
	Color                  *string                 `json:"color,omitempty"`
	FirstLink              *User                   `json:"first_link,omitempty"`
	Contracts              []*Vote                 `json:"contracts,omitempty"`
	EventsHistory          []*Event                `json:"events_history,omitempty"`
	TensionsOutAggregate   *TensionAggregateResult `json:"tensions_outAggregate,omitempty"`
	TensionsInAggregate    *TensionAggregateResult `json:"tensions_inAggregate,omitempty"`
	WatchersAggregate      *UserAggregateResult    `json:"watchersAggregate,omitempty"`
	ChildrenAggregate      *NodeAggregateResult    `json:"childrenAggregate,omitempty"`
	LabelsAggregate        *LabelAggregateResult   `json:"labelsAggregate,omitempty"`
	RolesAggregate         *RoleExtAggregateResult `json:"rolesAggregate,omitempty"`
	ProjectsAggregate      *ProjectAggregateResult `json:"projectsAggregate,omitempty"`
	PinnedAggregate        *TensionAggregateResult `json:"pinnedAggregate,omitempty"`
	ContractsAggregate     *VoteAggregateResult    `json:"contractsAggregate,omitempty"`
	EventsHistoryAggregate *EventAggregateResult   `json:"events_historyAggregate,omitempty"`
}

type NodeAggregateResult struct {
	Count         *int     `json:"count,omitempty"`
	CreatedAtMin  *string  `json:"createdAtMin,omitempty"`
	CreatedAtMax  *string  `json:"createdAtMax,omitempty"`
	UpdatedAtMin  *string  `json:"updatedAtMin,omitempty"`
	UpdatedAtMax  *string  `json:"updatedAtMax,omitempty"`
	NameidMin     *string  `json:"nameidMin,omitempty"`
	NameidMax     *string  `json:"nameidMax,omitempty"`
	RootnameidMin *string  `json:"rootnameidMin,omitempty"`
	RootnameidMax *string  `json:"rootnameidMax,omitempty"`
	NameMin       *string  `json:"nameMin,omitempty"`
	NameMax       *string  `json:"nameMax,omitempty"`
	AboutMin      *string  `json:"aboutMin,omitempty"`
	AboutMax      *string  `json:"aboutMax,omitempty"`
	RightsMin     *int     `json:"rightsMin,omitempty"`
	RightsMax     *int     `json:"rightsMax,omitempty"`
	RightsSum     *int     `json:"rightsSum,omitempty"`
	RightsAvg     *float64 `json:"rightsAvg,omitempty"`
	ColorMin      *string  `json:"colorMin,omitempty"`
	ColorMax      *string  `json:"colorMax,omitempty"`
}

type NodeFilter struct {
	ID         []string                            `json:"id,omitempty"`
	CreatedAt  *DateTimeFilter                     `json:"createdAt,omitempty"`
	Nameid     *StringHashFilterStringRegExpFilter `json:"nameid,omitempty"`
	Rootnameid *StringHashFilterStringRegExpFilter `json:"rootnameid,omitempty"`
	Name       *StringFullTextFilter               `json:"name,omitempty"`
	About      *StringFullTextFilter               `json:"about,omitempty"`
	Skills     *StringTermFilter                   `json:"skills,omitempty"`
	IsRoot     *bool                               `json:"isRoot,omitempty"`
	Type       *NodeTypeHash                       `json:"type_,omitempty"`
	Visibility *NodeVisibilityHash                 `json:"visibility,omitempty"`
	Mode       *NodeModeHash                       `json:"mode,omitempty"`
	IsArchived *bool                               `json:"isArchived,omitempty"`
	IsPersonal *bool                               `json:"isPersonal,omitempty"`
	RoleType   *RoleTypeHash                       `json:"role_type,omitempty"`
	Has        []*NodeHasFilter                    `json:"has,omitempty"`
	And        []*NodeFilter                       `json:"and,omitempty"`
	Or         []*NodeFilter                       `json:"or,omitempty"`
	Not        *NodeFilter                         `json:"not,omitempty"`
}

type NodeFragment struct {
	ID         string          `json:"id"`
	Nameid     *string         `json:"nameid,omitempty"`
	Name       *string         `json:"name,omitempty"`
	About      *string         `json:"about,omitempty"`
	Mandate    *Mandate        `json:"mandate,omitempty"`
	Skills     []string        `json:"skills,omitempty"`
	Visibility *NodeVisibility `json:"visibility,omitempty"`
	Mode       *NodeMode       `json:"mode,omitempty"`
	Type       *NodeType       `json:"type_,omitempty"`
	FirstLink  *string         `json:"first_link,omitempty"`
	RoleExt    *string         `json:"role_ext,omitempty"`
	RoleType   *RoleType       `json:"role_type,omitempty"`
	Color      *string         `json:"color,omitempty"`
}

type NodeFragmentAggregateResult struct {
	Count        *int    `json:"count,omitempty"`
	NameidMin    *string `json:"nameidMin,omitempty"`
	NameidMax    *string `json:"nameidMax,omitempty"`
	NameMin      *string `json:"nameMin,omitempty"`
	NameMax      *string `json:"nameMax,omitempty"`
	AboutMin     *string `json:"aboutMin,omitempty"`
	AboutMax     *string `json:"aboutMax,omitempty"`
	FirstLinkMin *string `json:"first_linkMin,omitempty"`
	FirstLinkMax *string `json:"first_linkMax,omitempty"`
	RoleExtMin   *string `json:"role_extMin,omitempty"`
	RoleExtMax   *string `json:"role_extMax,omitempty"`
	ColorMin     *string `json:"colorMin,omitempty"`
	ColorMax     *string `json:"colorMax,omitempty"`
}

type NodeFragmentFilter struct {
	ID  []string                 `json:"id,omitempty"`
	Has []*NodeFragmentHasFilter `json:"has,omitempty"`
	And []*NodeFragmentFilter    `json:"and,omitempty"`
	Or  []*NodeFragmentFilter    `json:"or,omitempty"`
	Not *NodeFragmentFilter      `json:"not,omitempty"`
}

type NodeFragmentOrder struct {
	Asc  *NodeFragmentOrderable `json:"asc,omitempty"`
	Desc *NodeFragmentOrderable `json:"desc,omitempty"`
	Then *NodeFragmentOrder     `json:"then,omitempty"`
}

type NodeFragmentPatch struct {
	Nameid     *string         `json:"nameid,omitempty"`
	Name       *string         `json:"name,omitempty"`
	About      *string         `json:"about,omitempty"`
	Mandate    *MandateRef     `json:"mandate,omitempty"`
	Skills     []string        `json:"skills,omitempty"`
	Visibility *NodeVisibility `json:"visibility,omitempty"`
	Mode       *NodeMode       `json:"mode,omitempty"`
	Type       *NodeType       `json:"type_,omitempty"`
	FirstLink  *string         `json:"first_link,omitempty"`
	RoleExt    *string         `json:"role_ext,omitempty"`
	RoleType   *RoleType       `json:"role_type,omitempty"`
	Color      *string         `json:"color,omitempty"`
}

type NodeFragmentRef struct {
	ID         *string         `json:"id,omitempty"`
	Nameid     *string         `json:"nameid,omitempty"`
	Name       *string         `json:"name,omitempty"`
	About      *string         `json:"about,omitempty"`
	Mandate    *MandateRef     `json:"mandate,omitempty"`
	Skills     []string        `json:"skills,omitempty"`
	Visibility *NodeVisibility `json:"visibility,omitempty"`
	Mode       *NodeMode       `json:"mode,omitempty"`
	Type       *NodeType       `json:"type_,omitempty"`
	FirstLink  *string         `json:"first_link,omitempty"`
	RoleExt    *string         `json:"role_ext,omitempty"`
	RoleType   *RoleType       `json:"role_type,omitempty"`
	Color      *string         `json:"color,omitempty"`
}

type NodeModeHash struct {
	Eq *NodeMode   `json:"eq,omitempty"`
	In []*NodeMode `json:"in,omitempty"`
}

type NodeOrder struct {
	Asc  *NodeOrderable `json:"asc,omitempty"`
	Desc *NodeOrderable `json:"desc,omitempty"`
	Then *NodeOrder     `json:"then,omitempty"`
}

type NodePatch struct {
	CreatedBy             *UserRef        `json:"createdBy,omitempty"`
	CreatedAt             *string         `json:"createdAt,omitempty"`
	UpdatedAt             *string         `json:"updatedAt,omitempty"`
	Rootnameid            *string         `json:"rootnameid,omitempty"`
	Source                *BlobRef        `json:"source,omitempty"`
	Name                  *string         `json:"name,omitempty"`
	About                 *string         `json:"about,omitempty"`
	Skills                []string        `json:"skills,omitempty"`
	IsRoot                *bool           `json:"isRoot,omitempty"`
	Parent                *NodeRef        `json:"parent,omitempty"`
	Type                  *NodeType       `json:"type_,omitempty"`
	TensionsOut           []*TensionRef   `json:"tensions_out,omitempty"`
	TensionsIn            []*TensionRef   `json:"tensions_in,omitempty"`
	Visibility            *NodeVisibility `json:"visibility,omitempty"`
	Mode                  *NodeMode       `json:"mode,omitempty"`
	Rights                *int            `json:"rights,omitempty"`
	IsArchived            *bool           `json:"isArchived,omitempty"`
	IsPersonal            *bool           `json:"isPersonal,omitempty"`
	UserCanJoin           *bool           `json:"userCanJoin,omitempty"`
	GuestCanCreateTension *bool           `json:"guestCanCreateTension,omitempty"`
	Watchers              []*UserRef      `json:"watchers,omitempty"`
	Children              []*NodeRef      `json:"children,omitempty"`
	Labels                []*LabelRef     `json:"labels,omitempty"`
	Roles                 []*RoleExtRef   `json:"roles,omitempty"`
	Projects              []*ProjectRef   `json:"projects,omitempty"`
	Pinned                []*TensionRef   `json:"pinned,omitempty"`
	RoleExt               *RoleExtRef     `json:"role_ext,omitempty"`
	RoleType              *RoleType       `json:"role_type,omitempty"`
	Color                 *string         `json:"color,omitempty"`
	FirstLink             *UserRef        `json:"first_link,omitempty"`
	Contracts             []*VoteRef      `json:"contracts,omitempty"`
	EventsHistory         []*EventRef     `json:"events_history,omitempty"`
}

type NodeRef struct {
	ID                    *string         `json:"id,omitempty"`
	CreatedBy             *UserRef        `json:"createdBy,omitempty"`
	CreatedAt             *string         `json:"createdAt,omitempty"`
	UpdatedAt             *string         `json:"updatedAt,omitempty"`
	Nameid                *string         `json:"nameid,omitempty"`
	Rootnameid            *string         `json:"rootnameid,omitempty"`
	Source                *BlobRef        `json:"source,omitempty"`
	Name                  *string         `json:"name,omitempty"`
	About                 *string         `json:"about,omitempty"`
	Skills                []string        `json:"skills,omitempty"`
	IsRoot                *bool           `json:"isRoot,omitempty"`
	Parent                *NodeRef        `json:"parent,omitempty"`
	Type                  *NodeType       `json:"type_,omitempty"`
	TensionsOut           []*TensionRef   `json:"tensions_out,omitempty"`
	TensionsIn            []*TensionRef   `json:"tensions_in,omitempty"`
	Visibility            *NodeVisibility `json:"visibility,omitempty"`
	Mode                  *NodeMode       `json:"mode,omitempty"`
	Rights                *int            `json:"rights,omitempty"`
	IsArchived            *bool           `json:"isArchived,omitempty"`
	IsPersonal            *bool           `json:"isPersonal,omitempty"`
	UserCanJoin           *bool           `json:"userCanJoin,omitempty"`
	GuestCanCreateTension *bool           `json:"guestCanCreateTension,omitempty"`
	Watchers              []*UserRef      `json:"watchers,omitempty"`
	Children              []*NodeRef      `json:"children,omitempty"`
	Labels                []*LabelRef     `json:"labels,omitempty"`
	Roles                 []*RoleExtRef   `json:"roles,omitempty"`
	Projects              []*ProjectRef   `json:"projects,omitempty"`
	Pinned                []*TensionRef   `json:"pinned,omitempty"`
	RoleExt               *RoleExtRef     `json:"role_ext,omitempty"`
	RoleType              *RoleType       `json:"role_type,omitempty"`
	Color                 *string         `json:"color,omitempty"`
	FirstLink             *UserRef        `json:"first_link,omitempty"`
	Contracts             []*VoteRef      `json:"contracts,omitempty"`
	EventsHistory         []*EventRef     `json:"events_history,omitempty"`
}

type NodeTypeHash struct {
	Eq *NodeType   `json:"eq,omitempty"`
	In []*NodeType `json:"in,omitempty"`
}

type NodeVisibilityHash struct {
	Eq *NodeVisibility   `json:"eq,omitempty"`
	In []*NodeVisibility `json:"in,omitempty"`
}

type Notif struct {
	Tension   *Tension  `json:"tension_,omitempty"`
	Contract  *Contract `json:"contract,omitempty"`
	Link      *string   `json:"link,omitempty"`
	ID        string    `json:"id"`
	CreatedBy *User     `json:"createdBy"`
	CreatedAt string    `json:"createdAt"`
	UpdatedAt *string   `json:"updatedAt,omitempty"`
	Message   *string   `json:"message,omitempty"`
}

func (Notif) IsEventKind() {}

type NotifAggregateResult struct {
	Count        *int    `json:"count,omitempty"`
	CreatedAtMin *string `json:"createdAtMin,omitempty"`
	CreatedAtMax *string `json:"createdAtMax,omitempty"`
	UpdatedAtMin *string `json:"updatedAtMin,omitempty"`
	UpdatedAtMax *string `json:"updatedAtMax,omitempty"`
	MessageMin   *string `json:"messageMin,omitempty"`
	MessageMax   *string `json:"messageMax,omitempty"`
	LinkMin      *string `json:"linkMin,omitempty"`
	LinkMax      *string `json:"linkMax,omitempty"`
}

type NotifFilter struct {
	ID        []string              `json:"id,omitempty"`
	CreatedAt *DateTimeFilter       `json:"createdAt,omitempty"`
	Message   *StringFullTextFilter `json:"message,omitempty"`
	Has       []*NotifHasFilter     `json:"has,omitempty"`
	And       []*NotifFilter        `json:"and,omitempty"`
	Or        []*NotifFilter        `json:"or,omitempty"`
	Not       *NotifFilter          `json:"not,omitempty"`
}

type NotifOrder struct {
	Asc  *NotifOrderable `json:"asc,omitempty"`
	Desc *NotifOrderable `json:"desc,omitempty"`
	Then *NotifOrder     `json:"then,omitempty"`
}

type NotifPatch struct {
	CreatedBy *UserRef     `json:"createdBy,omitempty"`
	CreatedAt *string      `json:"createdAt,omitempty"`
	UpdatedAt *string      `json:"updatedAt,omitempty"`
	Message   *string      `json:"message,omitempty"`
	Tension   *TensionRef  `json:"tension_,omitempty"`
	Contract  *ContractRef `json:"contract,omitempty"`
	Link      *string      `json:"link,omitempty"`
}

type NotifRef struct {
	ID        *string      `json:"id,omitempty"`
	CreatedBy *UserRef     `json:"createdBy,omitempty"`
	CreatedAt *string      `json:"createdAt,omitempty"`
	UpdatedAt *string      `json:"updatedAt,omitempty"`
	Message   *string      `json:"message,omitempty"`
	Tension   *TensionRef  `json:"tension_,omitempty"`
	Contract  *ContractRef `json:"contract,omitempty"`
	Link      *string      `json:"link,omitempty"`
}

type PendingUser struct {
	ID                 string                   `json:"id"`
	UpdatedAt          *string                  `json:"updatedAt,omitempty"`
	Username           string                   `json:"username"`
	Password           *string                  `json:"password,omitempty"`
	Email              string                   `json:"email"`
	EmailToken         *string                  `json:"email_token,omitempty"`
	Token              *string                  `json:"token,omitempty"`
	Contracts          []*Contract              `json:"contracts,omitempty"`
	Subscribe          *bool                    `json:"subscribe,omitempty"`
	ContractsAggregate *ContractAggregateResult `json:"contractsAggregate,omitempty"`
}

type PendingUserAggregateResult struct {
	Count         *int    `json:"count,omitempty"`
	UpdatedAtMin  *string `json:"updatedAtMin,omitempty"`
	UpdatedAtMax  *string `json:"updatedAtMax,omitempty"`
	UsernameMin   *string `json:"usernameMin,omitempty"`
	UsernameMax   *string `json:"usernameMax,omitempty"`
	PasswordMin   *string `json:"passwordMin,omitempty"`
	PasswordMax   *string `json:"passwordMax,omitempty"`
	EmailMin      *string `json:"emailMin,omitempty"`
	EmailMax      *string `json:"emailMax,omitempty"`
	EmailTokenMin *string `json:"email_tokenMin,omitempty"`
	EmailTokenMax *string `json:"email_tokenMax,omitempty"`
	TokenMin      *string `json:"tokenMin,omitempty"`
	TokenMax      *string `json:"tokenMax,omitempty"`
}

type PendingUserFilter struct {
	ID         []string                `json:"id,omitempty"`
	Username   *StringHashFilter       `json:"username,omitempty"`
	Email      *StringHashFilter       `json:"email,omitempty"`
	EmailToken *StringHashFilter       `json:"email_token,omitempty"`
	Token      *StringHashFilter       `json:"token,omitempty"`
	Has        []*PendingUserHasFilter `json:"has,omitempty"`
	And        []*PendingUserFilter    `json:"and,omitempty"`
	Or         []*PendingUserFilter    `json:"or,omitempty"`
	Not        *PendingUserFilter      `json:"not,omitempty"`
}

type PendingUserOrder struct {
	Asc  *PendingUserOrderable `json:"asc,omitempty"`
	Desc *PendingUserOrderable `json:"desc,omitempty"`
	Then *PendingUserOrder     `json:"then,omitempty"`
}

type PendingUserPatch struct {
	UpdatedAt  *string        `json:"updatedAt,omitempty"`
	Password   *string        `json:"password,omitempty"`
	EmailToken *string        `json:"email_token,omitempty"`
	Token      *string        `json:"token,omitempty"`
	Contracts  []*ContractRef `json:"contracts,omitempty"`
	Subscribe  *bool          `json:"subscribe,omitempty"`
}

type PendingUserRef struct {
	ID         *string        `json:"id,omitempty"`
	UpdatedAt  *string        `json:"updatedAt,omitempty"`
	Username   *string        `json:"username,omitempty"`
	Password   *string        `json:"password,omitempty"`
	Email      *string        `json:"email,omitempty"`
	EmailToken *string        `json:"email_token,omitempty"`
	Token      *string        `json:"token,omitempty"`
	Contracts  []*ContractRef `json:"contracts,omitempty"`
	Subscribe  *bool          `json:"subscribe,omitempty"`
}

type Point struct {
	Longitude float64 `json:"longitude"`
	Latitude  float64 `json:"latitude"`
}

type PointGeoFilter struct {
	Near   *NearFilter   `json:"near,omitempty"`
	Within *WithinFilter `json:"within,omitempty"`
}

type PointList struct {
	Points []*Point `json:"points"`
}

type PointListRef struct {
	Points []*PointRef `json:"points"`
}

type PointRef struct {
	Longitude float64 `json:"longitude"`
	Latitude  float64 `json:"latitude"`
}

type Polygon struct {
	Coordinates []*PointList `json:"coordinates"`
}

type PolygonGeoFilter struct {
	Near       *NearFilter       `json:"near,omitempty"`
	Within     *WithinFilter     `json:"within,omitempty"`
	Contains   *ContainsFilter   `json:"contains,omitempty"`
	Intersects *IntersectsFilter `json:"intersects,omitempty"`
}

type PolygonRef struct {
	Coordinates []*PointListRef `json:"coordinates"`
}

type Post struct {
	ID        string  `json:"id"`
	CreatedBy *User   `json:"createdBy"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt *string `json:"updatedAt,omitempty"`
	Message   *string `json:"message,omitempty"`
}

type PostAggregateResult struct {
	Count        *int    `json:"count,omitempty"`
	CreatedAtMin *string `json:"createdAtMin,omitempty"`
	CreatedAtMax *string `json:"createdAtMax,omitempty"`
	UpdatedAtMin *string `json:"updatedAtMin,omitempty"`
	UpdatedAtMax *string `json:"updatedAtMax,omitempty"`
	MessageMin   *string `json:"messageMin,omitempty"`
	MessageMax   *string `json:"messageMax,omitempty"`
}

type PostFilter struct {
	ID        []string              `json:"id,omitempty"`
	CreatedAt *DateTimeFilter       `json:"createdAt,omitempty"`
	Message   *StringFullTextFilter `json:"message,omitempty"`
	Has       []*PostHasFilter      `json:"has,omitempty"`
	And       []*PostFilter         `json:"and,omitempty"`
	Or        []*PostFilter         `json:"or,omitempty"`
	Not       *PostFilter           `json:"not,omitempty"`
}

type PostOrder struct {
	Asc  *PostOrderable `json:"asc,omitempty"`
	Desc *PostOrderable `json:"desc,omitempty"`
	Then *PostOrder     `json:"then,omitempty"`
}

type PostPatch struct {
	CreatedBy *UserRef `json:"createdBy,omitempty"`
	CreatedAt *string  `json:"createdAt,omitempty"`
	UpdatedAt *string  `json:"updatedAt,omitempty"`
	Message   *string  `json:"message,omitempty"`
}

type PostRef struct {
	ID string `json:"id"`
}

type Project struct {
	ID               string                        `json:"id"`
	CreatedBy        *User                         `json:"createdBy"`
	CreatedAt        string                        `json:"createdAt"`
	UpdatedAt        string                        `json:"updatedAt"`
	Rootnameid       string                        `json:"rootnameid"`
	Parentnameid     string                        `json:"parentnameid"`
	Nameid           string                        `json:"nameid"`
	Name             string                        `json:"name"`
	Description      *string                       `json:"description,omitempty"`
	Status           ProjectStatus                 `json:"status"`
	Columns          []*ProjectColumn              `json:"columns,omitempty"`
	Fields           []*ProjectField               `json:"fields,omitempty"`
	Leaders          []*Node                       `json:"leaders,omitempty"`
	Nodes            []*Node                       `json:"nodes,omitempty"`
	ColumnsAggregate *ProjectColumnAggregateResult `json:"columnsAggregate,omitempty"`
	FieldsAggregate  *ProjectFieldAggregateResult  `json:"fieldsAggregate,omitempty"`
	LeadersAggregate *NodeAggregateResult          `json:"leadersAggregate,omitempty"`
	NodesAggregate   *NodeAggregateResult          `json:"nodesAggregate,omitempty"`
}

type ProjectAggregateResult struct {
	Count           *int    `json:"count,omitempty"`
	CreatedAtMin    *string `json:"createdAtMin,omitempty"`
	CreatedAtMax    *string `json:"createdAtMax,omitempty"`
	UpdatedAtMin    *string `json:"updatedAtMin,omitempty"`
	UpdatedAtMax    *string `json:"updatedAtMax,omitempty"`
	RootnameidMin   *string `json:"rootnameidMin,omitempty"`
	RootnameidMax   *string `json:"rootnameidMax,omitempty"`
	ParentnameidMin *string `json:"parentnameidMin,omitempty"`
	ParentnameidMax *string `json:"parentnameidMax,omitempty"`
	NameidMin       *string `json:"nameidMin,omitempty"`
	NameidMax       *string `json:"nameidMax,omitempty"`
	NameMin         *string `json:"nameMin,omitempty"`
	NameMax         *string `json:"nameMax,omitempty"`
	DescriptionMin  *string `json:"descriptionMin,omitempty"`
	DescriptionMax  *string `json:"descriptionMax,omitempty"`
}

type ProjectCard struct {
	ID              string                            `json:"id"`
	Pos             int                               `json:"pos"`
	Card            CardKind                          `json:"card"`
	Pc              *ProjectColumn                    `json:"pc"`
	Values          []*ProjectFieldValue              `json:"values,omitempty"`
	ValuesAggregate *ProjectFieldValueAggregateResult `json:"valuesAggregate,omitempty"`
}

type ProjectCardAggregateResult struct {
	Count  *int     `json:"count,omitempty"`
	PosMin *int     `json:"posMin,omitempty"`
	PosMax *int     `json:"posMax,omitempty"`
	PosSum *int     `json:"posSum,omitempty"`
	PosAvg *float64 `json:"posAvg,omitempty"`
}

type ProjectCardFilter struct {
	ID  []string                `json:"id,omitempty"`
	Has []*ProjectCardHasFilter `json:"has,omitempty"`
	And []*ProjectCardFilter    `json:"and,omitempty"`
	Or  []*ProjectCardFilter    `json:"or,omitempty"`
	Not *ProjectCardFilter      `json:"not,omitempty"`
}

type ProjectCardOrder struct {
	Asc  *ProjectCardOrderable `json:"asc,omitempty"`
	Desc *ProjectCardOrderable `json:"desc,omitempty"`
	Then *ProjectCardOrder     `json:"then,omitempty"`
}

type ProjectCardPatch struct {
	Pos    *int                    `json:"pos,omitempty"`
	Card   *CardKindRef            `json:"card,omitempty"`
	Pc     *ProjectColumnRef       `json:"pc,omitempty"`
	Values []*ProjectFieldValueRef `json:"values,omitempty"`
}

type ProjectCardRef struct {
	ID     *string                 `json:"id,omitempty"`
	Pos    *int                    `json:"pos,omitempty"`
	Card   *CardKindRef            `json:"card,omitempty"`
	Pc     *ProjectColumnRef       `json:"pc,omitempty"`
	Values []*ProjectFieldValueRef `json:"values,omitempty"`
}

type ProjectColumn struct {
	ID                string                      `json:"id"`
	Name              string                      `json:"name"`
	Description       *string                     `json:"description,omitempty"`
	Color             *string                     `json:"color,omitempty"`
	Pos               int                         `json:"pos"`
	ColType           ProjectColumnType           `json:"col_type"`
	Cards             []*ProjectCard              `json:"cards,omitempty"`
	Project           *Project                    `json:"project"`
	Tensions          []*Tension                  `json:"tensions,omitempty"`
	CardsAggregate    *ProjectCardAggregateResult `json:"cardsAggregate,omitempty"`
	TensionsAggregate *TensionAggregateResult     `json:"tensionsAggregate,omitempty"`
}

type ProjectColumnAggregateResult struct {
	Count          *int     `json:"count,omitempty"`
	NameMin        *string  `json:"nameMin,omitempty"`
	NameMax        *string  `json:"nameMax,omitempty"`
	DescriptionMin *string  `json:"descriptionMin,omitempty"`
	DescriptionMax *string  `json:"descriptionMax,omitempty"`
	ColorMin       *string  `json:"colorMin,omitempty"`
	ColorMax       *string  `json:"colorMax,omitempty"`
	PosMin         *int     `json:"posMin,omitempty"`
	PosMax         *int     `json:"posMax,omitempty"`
	PosSum         *int     `json:"posSum,omitempty"`
	PosAvg         *float64 `json:"posAvg,omitempty"`
}

type ProjectColumnFilter struct {
	ID  []string                  `json:"id,omitempty"`
	Has []*ProjectColumnHasFilter `json:"has,omitempty"`
	And []*ProjectColumnFilter    `json:"and,omitempty"`
	Or  []*ProjectColumnFilter    `json:"or,omitempty"`
	Not *ProjectColumnFilter      `json:"not,omitempty"`
}

type ProjectColumnOrder struct {
	Asc  *ProjectColumnOrderable `json:"asc,omitempty"`
	Desc *ProjectColumnOrderable `json:"desc,omitempty"`
	Then *ProjectColumnOrder     `json:"then,omitempty"`
}

type ProjectColumnPatch struct {
	Name        *string            `json:"name,omitempty"`
	Description *string            `json:"description,omitempty"`
	Color       *string            `json:"color,omitempty"`
	Pos         *int               `json:"pos,omitempty"`
	ColType     *ProjectColumnType `json:"col_type,omitempty"`
	Cards       []*ProjectCardRef  `json:"cards,omitempty"`
	Project     *ProjectRef        `json:"project,omitempty"`
	Tensions    []*TensionRef      `json:"tensions,omitempty"`
}

type ProjectColumnRef struct {
	ID          *string            `json:"id,omitempty"`
	Name        *string            `json:"name,omitempty"`
	Description *string            `json:"description,omitempty"`
	Color       *string            `json:"color,omitempty"`
	Pos         *int               `json:"pos,omitempty"`
	ColType     *ProjectColumnType `json:"col_type,omitempty"`
	Cards       []*ProjectCardRef  `json:"cards,omitempty"`
	Project     *ProjectRef        `json:"project,omitempty"`
	Tensions    []*TensionRef      `json:"tensions,omitempty"`
}

type ProjectDraft struct {
	Title     string  `json:"title"`
	Message   *string `json:"message,omitempty"`
	ID        string  `json:"id"`
	CreatedBy *User   `json:"createdBy"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt *string `json:"updatedAt,omitempty"`
}

func (ProjectDraft) IsCardKind() {}

type ProjectDraftAggregateResult struct {
	Count        *int    `json:"count,omitempty"`
	CreatedAtMin *string `json:"createdAtMin,omitempty"`
	CreatedAtMax *string `json:"createdAtMax,omitempty"`
	UpdatedAtMin *string `json:"updatedAtMin,omitempty"`
	UpdatedAtMax *string `json:"updatedAtMax,omitempty"`
	MessageMin   *string `json:"messageMin,omitempty"`
	MessageMax   *string `json:"messageMax,omitempty"`
	TitleMin     *string `json:"titleMin,omitempty"`
	TitleMax     *string `json:"titleMax,omitempty"`
}

type ProjectDraftFilter struct {
	ID        []string                 `json:"id,omitempty"`
	CreatedAt *DateTimeFilter          `json:"createdAt,omitempty"`
	Message   *StringFullTextFilter    `json:"message,omitempty"`
	Has       []*ProjectDraftHasFilter `json:"has,omitempty"`
	And       []*ProjectDraftFilter    `json:"and,omitempty"`
	Or        []*ProjectDraftFilter    `json:"or,omitempty"`
	Not       *ProjectDraftFilter      `json:"not,omitempty"`
}

type ProjectDraftOrder struct {
	Asc  *ProjectDraftOrderable `json:"asc,omitempty"`
	Desc *ProjectDraftOrderable `json:"desc,omitempty"`
	Then *ProjectDraftOrder     `json:"then,omitempty"`
}

type ProjectDraftPatch struct {
	CreatedBy *UserRef `json:"createdBy,omitempty"`
	CreatedAt *string  `json:"createdAt,omitempty"`
	UpdatedAt *string  `json:"updatedAt,omitempty"`
	Message   *string  `json:"message,omitempty"`
	Title     *string  `json:"title,omitempty"`
}

type ProjectDraftRef struct {
	ID        *string  `json:"id,omitempty"`
	CreatedBy *UserRef `json:"createdBy,omitempty"`
	CreatedAt *string  `json:"createdAt,omitempty"`
	UpdatedAt *string  `json:"updatedAt,omitempty"`
	Message   *string  `json:"message,omitempty"`
	Title     *string  `json:"title,omitempty"`
}

type ProjectField struct {
	FieldType       ProjectFieldType                  `json:"field_type"`
	IsVisible       bool                              `json:"isVisible"`
	Values          []*ProjectFieldValue              `json:"values,omitempty"`
	ValuesAggregate *ProjectFieldValueAggregateResult `json:"valuesAggregate,omitempty"`
}

type ProjectFieldAggregateResult struct {
	Count *int `json:"count,omitempty"`
}

type ProjectFieldFilter struct {
	Has []*ProjectFieldHasFilter `json:"has,omitempty"`
	And []*ProjectFieldFilter    `json:"and,omitempty"`
	Or  []*ProjectFieldFilter    `json:"or,omitempty"`
	Not *ProjectFieldFilter      `json:"not,omitempty"`
}

type ProjectFieldPatch struct {
	FieldType *ProjectFieldType       `json:"field_type,omitempty"`
	IsVisible *bool                   `json:"isVisible,omitempty"`
	Values    []*ProjectFieldValueRef `json:"values,omitempty"`
}

type ProjectFieldRef struct {
	FieldType *ProjectFieldType       `json:"field_type,omitempty"`
	IsVisible *bool                   `json:"isVisible,omitempty"`
	Values    []*ProjectFieldValueRef `json:"values,omitempty"`
}

type ProjectFieldValue struct {
	Field *ProjectField `json:"field"`
	Value string        `json:"value"`
	Pos   *int          `json:"pos,omitempty"`
}

type ProjectFieldValueAggregateResult struct {
	Count    *int     `json:"count,omitempty"`
	ValueMin *string  `json:"valueMin,omitempty"`
	ValueMax *string  `json:"valueMax,omitempty"`
	PosMin   *int     `json:"posMin,omitempty"`
	PosMax   *int     `json:"posMax,omitempty"`
	PosSum   *int     `json:"posSum,omitempty"`
	PosAvg   *float64 `json:"posAvg,omitempty"`
}

type ProjectFieldValueFilter struct {
	Has []*ProjectFieldValueHasFilter `json:"has,omitempty"`
	And []*ProjectFieldValueFilter    `json:"and,omitempty"`
	Or  []*ProjectFieldValueFilter    `json:"or,omitempty"`
	Not *ProjectFieldValueFilter      `json:"not,omitempty"`
}

type ProjectFieldValueOrder struct {
	Asc  *ProjectFieldValueOrderable `json:"asc,omitempty"`
	Desc *ProjectFieldValueOrderable `json:"desc,omitempty"`
	Then *ProjectFieldValueOrder     `json:"then,omitempty"`
}

type ProjectFieldValuePatch struct {
	Field *ProjectFieldRef `json:"field,omitempty"`
	Value *string          `json:"value,omitempty"`
	Pos   *int             `json:"pos,omitempty"`
}

type ProjectFieldValueRef struct {
	Field *ProjectFieldRef `json:"field,omitempty"`
	Value *string          `json:"value,omitempty"`
	Pos   *int             `json:"pos,omitempty"`
}

type ProjectFilter struct {
	ID           []string              `json:"id,omitempty"`
	CreatedAt    *DateTimeFilter       `json:"createdAt,omitempty"`
	Rootnameid   *StringHashFilter     `json:"rootnameid,omitempty"`
	Parentnameid *StringHashFilter     `json:"parentnameid,omitempty"`
	Nameid       *StringHashFilter     `json:"nameid,omitempty"`
	Name         *StringFullTextFilter `json:"name,omitempty"`
	Status       *ProjectStatusHash    `json:"status,omitempty"`
	Has          []*ProjectHasFilter   `json:"has,omitempty"`
	And          []*ProjectFilter      `json:"and,omitempty"`
	Or           []*ProjectFilter      `json:"or,omitempty"`
	Not          *ProjectFilter        `json:"not,omitempty"`
}

type ProjectOrder struct {
	Asc  *ProjectOrderable `json:"asc,omitempty"`
	Desc *ProjectOrderable `json:"desc,omitempty"`
	Then *ProjectOrder     `json:"then,omitempty"`
}

type ProjectPatch struct {
	CreatedBy    *UserRef            `json:"createdBy,omitempty"`
	CreatedAt    *string             `json:"createdAt,omitempty"`
	UpdatedAt    *string             `json:"updatedAt,omitempty"`
	Rootnameid   *string             `json:"rootnameid,omitempty"`
	Parentnameid *string             `json:"parentnameid,omitempty"`
	Nameid       *string             `json:"nameid,omitempty"`
	Name         *string             `json:"name,omitempty"`
	Description  *string             `json:"description,omitempty"`
	Status       *ProjectStatus      `json:"status,omitempty"`
	Columns      []*ProjectColumnRef `json:"columns,omitempty"`
	Fields       []*ProjectFieldRef  `json:"fields,omitempty"`
	Leaders      []*NodeRef          `json:"leaders,omitempty"`
	Nodes        []*NodeRef          `json:"nodes,omitempty"`
}

type ProjectRef struct {
	ID           *string             `json:"id,omitempty"`
	CreatedBy    *UserRef            `json:"createdBy,omitempty"`
	CreatedAt    *string             `json:"createdAt,omitempty"`
	UpdatedAt    *string             `json:"updatedAt,omitempty"`
	Rootnameid   *string             `json:"rootnameid,omitempty"`
	Parentnameid *string             `json:"parentnameid,omitempty"`
	Nameid       *string             `json:"nameid,omitempty"`
	Name         *string             `json:"name,omitempty"`
	Description  *string             `json:"description,omitempty"`
	Status       *ProjectStatus      `json:"status,omitempty"`
	Columns      []*ProjectColumnRef `json:"columns,omitempty"`
	Fields       []*ProjectFieldRef  `json:"fields,omitempty"`
	Leaders      []*NodeRef          `json:"leaders,omitempty"`
	Nodes        []*NodeRef          `json:"nodes,omitempty"`
}

type ProjectStatusHash struct {
	Eq *ProjectStatus   `json:"eq,omitempty"`
	In []*ProjectStatus `json:"in,omitempty"`
}

type Reaction struct {
	ID         string   `json:"id"`
	Reactionid string   `json:"reactionid"`
	User       *User    `json:"user"`
	Comment    *Comment `json:"comment"`
	Type       int      `json:"type_"`
}

type ReactionAggregateResult struct {
	Count         *int     `json:"count,omitempty"`
	ReactionidMin *string  `json:"reactionidMin,omitempty"`
	ReactionidMax *string  `json:"reactionidMax,omitempty"`
	TypeMin       *int     `json:"type_Min,omitempty"`
	TypeMax       *int     `json:"type_Max,omitempty"`
	TypeSum       *int     `json:"type_Sum,omitempty"`
	TypeAvg       *float64 `json:"type_Avg,omitempty"`
}

type ReactionFilter struct {
	ID         []string             `json:"id,omitempty"`
	Reactionid *StringHashFilter    `json:"reactionid,omitempty"`
	Has        []*ReactionHasFilter `json:"has,omitempty"`
	And        []*ReactionFilter    `json:"and,omitempty"`
	Or         []*ReactionFilter    `json:"or,omitempty"`
	Not        *ReactionFilter      `json:"not,omitempty"`
}

type ReactionOrder struct {
	Asc  *ReactionOrderable `json:"asc,omitempty"`
	Desc *ReactionOrderable `json:"desc,omitempty"`
	Then *ReactionOrder     `json:"then,omitempty"`
}

type ReactionPatch struct {
	User    *UserRef    `json:"user,omitempty"`
	Comment *CommentRef `json:"comment,omitempty"`
	Type    *int        `json:"type_,omitempty"`
}

type ReactionRef struct {
	ID         *string     `json:"id,omitempty"`
	Reactionid *string     `json:"reactionid,omitempty"`
	User       *UserRef    `json:"user,omitempty"`
	Comment    *CommentRef `json:"comment,omitempty"`
	Type       *int        `json:"type_,omitempty"`
}

type RoleExt struct {
	ID             string               `json:"id"`
	Rootnameid     string               `json:"rootnameid"`
	Name           string               `json:"name"`
	About          *string              `json:"about,omitempty"`
	RoleType       RoleType             `json:"role_type"`
	Color          *string              `json:"color,omitempty"`
	Mandate        *Mandate             `json:"mandate,omitempty"`
	Roles          []*Node              `json:"roles,omitempty"`
	Nodes          []*Node              `json:"nodes,omitempty"`
	RolesAggregate *NodeAggregateResult `json:"rolesAggregate,omitempty"`
	NodesAggregate *NodeAggregateResult `json:"nodesAggregate,omitempty"`
}

type RoleExtAggregateResult struct {
	Count         *int    `json:"count,omitempty"`
	RootnameidMin *string `json:"rootnameidMin,omitempty"`
	RootnameidMax *string `json:"rootnameidMax,omitempty"`
	NameMin       *string `json:"nameMin,omitempty"`
	NameMax       *string `json:"nameMax,omitempty"`
	AboutMin      *string `json:"aboutMin,omitempty"`
	AboutMax      *string `json:"aboutMax,omitempty"`
	ColorMin      *string `json:"colorMin,omitempty"`
	ColorMax      *string `json:"colorMax,omitempty"`
}

type RoleExtFilter struct {
	ID         []string                          `json:"id,omitempty"`
	Rootnameid *StringHashFilter                 `json:"rootnameid,omitempty"`
	Name       *StringHashFilterStringTermFilter `json:"name,omitempty"`
	Has        []*RoleExtHasFilter               `json:"has,omitempty"`
	And        []*RoleExtFilter                  `json:"and,omitempty"`
	Or         []*RoleExtFilter                  `json:"or,omitempty"`
	Not        *RoleExtFilter                    `json:"not,omitempty"`
}

type RoleExtOrder struct {
	Asc  *RoleExtOrderable `json:"asc,omitempty"`
	Desc *RoleExtOrderable `json:"desc,omitempty"`
	Then *RoleExtOrder     `json:"then,omitempty"`
}

type RoleExtPatch struct {
	Rootnameid *string     `json:"rootnameid,omitempty"`
	Name       *string     `json:"name,omitempty"`
	About      *string     `json:"about,omitempty"`
	RoleType   *RoleType   `json:"role_type,omitempty"`
	Color      *string     `json:"color,omitempty"`
	Mandate    *MandateRef `json:"mandate,omitempty"`
	Roles      []*NodeRef  `json:"roles,omitempty"`
	Nodes      []*NodeRef  `json:"nodes,omitempty"`
}

type RoleExtRef struct {
	ID         *string     `json:"id,omitempty"`
	Rootnameid *string     `json:"rootnameid,omitempty"`
	Name       *string     `json:"name,omitempty"`
	About      *string     `json:"about,omitempty"`
	RoleType   *RoleType   `json:"role_type,omitempty"`
	Color      *string     `json:"color,omitempty"`
	Mandate    *MandateRef `json:"mandate,omitempty"`
	Roles      []*NodeRef  `json:"roles,omitempty"`
	Nodes      []*NodeRef  `json:"nodes,omitempty"`
}

type RoleTypeHash struct {
	Eq *RoleType   `json:"eq,omitempty"`
	In []*RoleType `json:"in,omitempty"`
}

type StringExactFilter struct {
	Eq      *string      `json:"eq,omitempty"`
	In      []*string    `json:"in,omitempty"`
	Le      *string      `json:"le,omitempty"`
	Lt      *string      `json:"lt,omitempty"`
	Ge      *string      `json:"ge,omitempty"`
	Gt      *string      `json:"gt,omitempty"`
	Between *StringRange `json:"between,omitempty"`
}

type StringFullTextFilter struct {
	Alloftext *string `json:"alloftext,omitempty"`
	Anyoftext *string `json:"anyoftext,omitempty"`
}

type StringHashFilter struct {
	Eq *string   `json:"eq,omitempty"`
	In []*string `json:"in,omitempty"`
}

type StringHashFilterStringRegExpFilter struct {
	Eq     *string   `json:"eq,omitempty"`
	In     []*string `json:"in,omitempty"`
	Regexp *string   `json:"regexp,omitempty"`
}

type StringHashFilterStringTermFilter struct {
	Eq         *string   `json:"eq,omitempty"`
	In         []*string `json:"in,omitempty"`
	Allofterms *string   `json:"allofterms,omitempty"`
	Anyofterms *string   `json:"anyofterms,omitempty"`
}

type StringRange struct {
	Min string `json:"min"`
	Max string `json:"max"`
}

type StringRegExpFilter struct {
	Regexp *string `json:"regexp,omitempty"`
}

type StringTermFilter struct {
	Allofterms *string `json:"allofterms,omitempty"`
	Anyofterms *string `json:"anyofterms,omitempty"`
}

type Tension struct {
	Emitter                  *Node                         `json:"emitter"`
	Emitterid                string                        `json:"emitterid"`
	Receiver                 *Node                         `json:"receiver"`
	Receiverid               string                        `json:"receiverid"`
	Title                    string                        `json:"title"`
	Type                     TensionType                   `json:"type_"`
	Status                   TensionStatus                 `json:"status"`
	Action                   *TensionAction                `json:"action,omitempty"`
	Assignees                []*User                       `json:"assignees,omitempty"`
	Labels                   []*Label                      `json:"labels,omitempty"`
	Comments                 []*Comment                    `json:"comments,omitempty"`
	Blobs                    []*Blob                       `json:"blobs,omitempty"`
	History                  []*Event                      `json:"history,omitempty"`
	Mentions                 []*Event                      `json:"mentions,omitempty"`
	Contracts                []*Contract                   `json:"contracts,omitempty"`
	Subscribers              []*User                       `json:"subscribers,omitempty"`
	ProjectStatuses          []*ProjectColumn              `json:"project_statuses,omitempty"`
	NComments                *int                          `json:"n_comments,omitempty"`
	ID                       string                        `json:"id"`
	CreatedBy                *User                         `json:"createdBy"`
	CreatedAt                string                        `json:"createdAt"`
	UpdatedAt                *string                       `json:"updatedAt,omitempty"`
	Message                  *string                       `json:"message,omitempty"`
	AssigneesAggregate       *UserAggregateResult          `json:"assigneesAggregate,omitempty"`
	LabelsAggregate          *LabelAggregateResult         `json:"labelsAggregate,omitempty"`
	CommentsAggregate        *CommentAggregateResult       `json:"commentsAggregate,omitempty"`
	BlobsAggregate           *BlobAggregateResult          `json:"blobsAggregate,omitempty"`
	HistoryAggregate         *EventAggregateResult         `json:"historyAggregate,omitempty"`
	MentionsAggregate        *EventAggregateResult         `json:"mentionsAggregate,omitempty"`
	ContractsAggregate       *ContractAggregateResult      `json:"contractsAggregate,omitempty"`
	SubscribersAggregate     *UserAggregateResult          `json:"subscribersAggregate,omitempty"`
	ProjectStatusesAggregate *ProjectColumnAggregateResult `json:"project_statusesAggregate,omitempty"`
}

func (Tension) IsCardKind() {}

type TensionAggregateResult struct {
	Count         *int     `json:"count,omitempty"`
	CreatedAtMin  *string  `json:"createdAtMin,omitempty"`
	CreatedAtMax  *string  `json:"createdAtMax,omitempty"`
	UpdatedAtMin  *string  `json:"updatedAtMin,omitempty"`
	UpdatedAtMax  *string  `json:"updatedAtMax,omitempty"`
	MessageMin    *string  `json:"messageMin,omitempty"`
	MessageMax    *string  `json:"messageMax,omitempty"`
	EmitteridMin  *string  `json:"emitteridMin,omitempty"`
	EmitteridMax  *string  `json:"emitteridMax,omitempty"`
	ReceiveridMin *string  `json:"receiveridMin,omitempty"`
	ReceiveridMax *string  `json:"receiveridMax,omitempty"`
	TitleMin      *string  `json:"titleMin,omitempty"`
	TitleMax      *string  `json:"titleMax,omitempty"`
	NCommentsMin  *int     `json:"n_commentsMin,omitempty"`
	NCommentsMax  *int     `json:"n_commentsMax,omitempty"`
	NCommentsSum  *int     `json:"n_commentsSum,omitempty"`
	NCommentsAvg  *float64 `json:"n_commentsAvg,omitempty"`
}

type TensionEventHash struct {
	Eq *TensionEvent   `json:"eq,omitempty"`
	In []*TensionEvent `json:"in,omitempty"`
}

type TensionFilter struct {
	ID         []string                            `json:"id,omitempty"`
	CreatedAt  *DateTimeFilter                     `json:"createdAt,omitempty"`
	Message    *StringFullTextFilter               `json:"message,omitempty"`
	Emitterid  *StringHashFilterStringRegExpFilter `json:"emitterid,omitempty"`
	Receiverid *StringHashFilterStringRegExpFilter `json:"receiverid,omitempty"`
	Title      *StringFullTextFilter               `json:"title,omitempty"`
	Type       *TensionTypeHash                    `json:"type_,omitempty"`
	Status     *TensionStatusHash                  `json:"status,omitempty"`
	Has        []*TensionHasFilter                 `json:"has,omitempty"`
	And        []*TensionFilter                    `json:"and,omitempty"`
	Or         []*TensionFilter                    `json:"or,omitempty"`
	Not        *TensionFilter                      `json:"not,omitempty"`
}

type TensionOrder struct {
	Asc  *TensionOrderable `json:"asc,omitempty"`
	Desc *TensionOrderable `json:"desc,omitempty"`
	Then *TensionOrder     `json:"then,omitempty"`
}

type TensionPatch struct {
	CreatedBy       *UserRef            `json:"createdBy,omitempty"`
	CreatedAt       *string             `json:"createdAt,omitempty"`
	UpdatedAt       *string             `json:"updatedAt,omitempty"`
	Message         *string             `json:"message,omitempty"`
	Emitter         *NodeRef            `json:"emitter,omitempty"`
	Emitterid       *string             `json:"emitterid,omitempty"`
	Receiver        *NodeRef            `json:"receiver,omitempty"`
	Receiverid      *string             `json:"receiverid,omitempty"`
	Title           *string             `json:"title,omitempty"`
	Type            *TensionType        `json:"type_,omitempty"`
	Status          *TensionStatus      `json:"status,omitempty"`
	Action          *TensionAction      `json:"action,omitempty"`
	Assignees       []*UserRef          `json:"assignees,omitempty"`
	Labels          []*LabelRef         `json:"labels,omitempty"`
	Comments        []*CommentRef       `json:"comments,omitempty"`
	Blobs           []*BlobRef          `json:"blobs,omitempty"`
	History         []*EventRef         `json:"history,omitempty"`
	Mentions        []*EventRef         `json:"mentions,omitempty"`
	Contracts       []*ContractRef      `json:"contracts,omitempty"`
	Subscribers     []*UserRef          `json:"subscribers,omitempty"`
	ProjectStatuses []*ProjectColumnRef `json:"project_statuses,omitempty"`
	NComments       *int                `json:"n_comments,omitempty"`
}

type TensionRef struct {
	ID              *string             `json:"id,omitempty"`
	CreatedBy       *UserRef            `json:"createdBy,omitempty"`
	CreatedAt       *string             `json:"createdAt,omitempty"`
	UpdatedAt       *string             `json:"updatedAt,omitempty"`
	Message         *string             `json:"message,omitempty"`
	Emitter         *NodeRef            `json:"emitter,omitempty"`
	Emitterid       *string             `json:"emitterid,omitempty"`
	Receiver        *NodeRef            `json:"receiver,omitempty"`
	Receiverid      *string             `json:"receiverid,omitempty"`
	Title           *string             `json:"title,omitempty"`
	Type            *TensionType        `json:"type_,omitempty"`
	Status          *TensionStatus      `json:"status,omitempty"`
	Action          *TensionAction      `json:"action,omitempty"`
	Assignees       []*UserRef          `json:"assignees,omitempty"`
	Labels          []*LabelRef         `json:"labels,omitempty"`
	Comments        []*CommentRef       `json:"comments,omitempty"`
	Blobs           []*BlobRef          `json:"blobs,omitempty"`
	History         []*EventRef         `json:"history,omitempty"`
	Mentions        []*EventRef         `json:"mentions,omitempty"`
	Contracts       []*ContractRef      `json:"contracts,omitempty"`
	Subscribers     []*UserRef          `json:"subscribers,omitempty"`
	ProjectStatuses []*ProjectColumnRef `json:"project_statuses,omitempty"`
	NComments       *int                `json:"n_comments,omitempty"`
}

type TensionStatusHash struct {
	Eq *TensionStatus   `json:"eq,omitempty"`
	In []*TensionStatus `json:"in,omitempty"`
}

type TensionTypeHash struct {
	Eq *TensionType   `json:"eq,omitempty"`
	In []*TensionType `json:"in,omitempty"`
}

type UpdateBlobInput struct {
	Filter *BlobFilter `json:"filter"`
	Set    *BlobPatch  `json:"set,omitempty"`
	Remove *BlobPatch  `json:"remove,omitempty"`
}

type UpdateBlobPayload struct {
	Blob    []*Blob `json:"blob,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type UpdateCommentInput struct {
	Filter *CommentFilter `json:"filter"`
	Set    *CommentPatch  `json:"set,omitempty"`
	Remove *CommentPatch  `json:"remove,omitempty"`
}

type UpdateCommentPayload struct {
	Comment []*Comment `json:"comment,omitempty"`
	NumUids *int       `json:"numUids,omitempty"`
}

type UpdateContractInput struct {
	Filter *ContractFilter `json:"filter"`
	Set    *ContractPatch  `json:"set,omitempty"`
	Remove *ContractPatch  `json:"remove,omitempty"`
}

type UpdateContractPayload struct {
	Contract []*Contract `json:"contract,omitempty"`
	NumUids  *int        `json:"numUids,omitempty"`
}

type UpdateEventCountInput struct {
	Filter *EventCountFilter `json:"filter"`
	Set    *EventCountPatch  `json:"set,omitempty"`
	Remove *EventCountPatch  `json:"remove,omitempty"`
}

type UpdateEventCountPayload struct {
	EventCount []*EventCount `json:"eventCount,omitempty"`
	NumUids    *int          `json:"numUids,omitempty"`
}

type UpdateEventFragmentInput struct {
	Filter *EventFragmentFilter `json:"filter"`
	Set    *EventFragmentPatch  `json:"set,omitempty"`
	Remove *EventFragmentPatch  `json:"remove,omitempty"`
}

type UpdateEventFragmentPayload struct {
	EventFragment []*EventFragment `json:"eventFragment,omitempty"`
	NumUids       *int             `json:"numUids,omitempty"`
}

type UpdateEventInput struct {
	Filter *EventFilter `json:"filter"`
	Set    *EventPatch  `json:"set,omitempty"`
	Remove *EventPatch  `json:"remove,omitempty"`
}

type UpdateEventPayload struct {
	Event   []*Event `json:"event,omitempty"`
	NumUids *int     `json:"numUids,omitempty"`
}

type UpdateLabelInput struct {
	Filter *LabelFilter `json:"filter"`
	Set    *LabelPatch  `json:"set,omitempty"`
	Remove *LabelPatch  `json:"remove,omitempty"`
}

type UpdateLabelPayload struct {
	Label   []*Label `json:"label,omitempty"`
	NumUids *int     `json:"numUids,omitempty"`
}

type UpdateMandateInput struct {
	Filter *MandateFilter `json:"filter"`
	Set    *MandatePatch  `json:"set,omitempty"`
	Remove *MandatePatch  `json:"remove,omitempty"`
}

type UpdateMandatePayload struct {
	Mandate []*Mandate `json:"mandate,omitempty"`
	NumUids *int       `json:"numUids,omitempty"`
}

type UpdateNodeFragmentInput struct {
	Filter *NodeFragmentFilter `json:"filter"`
	Set    *NodeFragmentPatch  `json:"set,omitempty"`
	Remove *NodeFragmentPatch  `json:"remove,omitempty"`
}

type UpdateNodeFragmentPayload struct {
	NodeFragment []*NodeFragment `json:"nodeFragment,omitempty"`
	NumUids      *int            `json:"numUids,omitempty"`
}

type UpdateNodeInput struct {
	Filter *NodeFilter `json:"filter"`
	Set    *NodePatch  `json:"set,omitempty"`
	Remove *NodePatch  `json:"remove,omitempty"`
}

type UpdateNodePayload struct {
	Node    []*Node `json:"node,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type UpdateNotifInput struct {
	Filter *NotifFilter `json:"filter"`
	Set    *NotifPatch  `json:"set,omitempty"`
	Remove *NotifPatch  `json:"remove,omitempty"`
}

type UpdateNotifPayload struct {
	Notif   []*Notif `json:"notif,omitempty"`
	NumUids *int     `json:"numUids,omitempty"`
}

type UpdatePendingUserInput struct {
	Filter *PendingUserFilter `json:"filter"`
	Set    *PendingUserPatch  `json:"set,omitempty"`
	Remove *PendingUserPatch  `json:"remove,omitempty"`
}

type UpdatePendingUserPayload struct {
	PendingUser []*PendingUser `json:"pendingUser,omitempty"`
	NumUids     *int           `json:"numUids,omitempty"`
}

type UpdatePostInput struct {
	Filter *PostFilter `json:"filter"`
	Set    *PostPatch  `json:"set,omitempty"`
	Remove *PostPatch  `json:"remove,omitempty"`
}

type UpdatePostPayload struct {
	Post    []*Post `json:"post,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type UpdateProjectCardInput struct {
	Filter *ProjectCardFilter `json:"filter"`
	Set    *ProjectCardPatch  `json:"set,omitempty"`
	Remove *ProjectCardPatch  `json:"remove,omitempty"`
}

type UpdateProjectCardPayload struct {
	ProjectCard []*ProjectCard `json:"projectCard,omitempty"`
	NumUids     *int           `json:"numUids,omitempty"`
}

type UpdateProjectColumnInput struct {
	Filter *ProjectColumnFilter `json:"filter"`
	Set    *ProjectColumnPatch  `json:"set,omitempty"`
	Remove *ProjectColumnPatch  `json:"remove,omitempty"`
}

type UpdateProjectColumnPayload struct {
	ProjectColumn []*ProjectColumn `json:"projectColumn,omitempty"`
	NumUids       *int             `json:"numUids,omitempty"`
}

type UpdateProjectDraftInput struct {
	Filter *ProjectDraftFilter `json:"filter"`
	Set    *ProjectDraftPatch  `json:"set,omitempty"`
	Remove *ProjectDraftPatch  `json:"remove,omitempty"`
}

type UpdateProjectDraftPayload struct {
	ProjectDraft []*ProjectDraft `json:"projectDraft,omitempty"`
	NumUids      *int            `json:"numUids,omitempty"`
}

type UpdateProjectFieldInput struct {
	Filter *ProjectFieldFilter `json:"filter"`
	Set    *ProjectFieldPatch  `json:"set,omitempty"`
	Remove *ProjectFieldPatch  `json:"remove,omitempty"`
}

type UpdateProjectFieldPayload struct {
	ProjectField []*ProjectField `json:"projectField,omitempty"`
	NumUids      *int            `json:"numUids,omitempty"`
}

type UpdateProjectFieldValueInput struct {
	Filter *ProjectFieldValueFilter `json:"filter"`
	Set    *ProjectFieldValuePatch  `json:"set,omitempty"`
	Remove *ProjectFieldValuePatch  `json:"remove,omitempty"`
}

type UpdateProjectFieldValuePayload struct {
	ProjectFieldValue []*ProjectFieldValue `json:"projectFieldValue,omitempty"`
	NumUids           *int                 `json:"numUids,omitempty"`
}

type UpdateProjectInput struct {
	Filter *ProjectFilter `json:"filter"`
	Set    *ProjectPatch  `json:"set,omitempty"`
	Remove *ProjectPatch  `json:"remove,omitempty"`
}

type UpdateProjectPayload struct {
	Project []*Project `json:"project,omitempty"`
	NumUids *int       `json:"numUids,omitempty"`
}

type UpdateReactionInput struct {
	Filter *ReactionFilter `json:"filter"`
	Set    *ReactionPatch  `json:"set,omitempty"`
	Remove *ReactionPatch  `json:"remove,omitempty"`
}

type UpdateReactionPayload struct {
	Reaction []*Reaction `json:"reaction,omitempty"`
	NumUids  *int        `json:"numUids,omitempty"`
}

type UpdateRoleExtInput struct {
	Filter *RoleExtFilter `json:"filter"`
	Set    *RoleExtPatch  `json:"set,omitempty"`
	Remove *RoleExtPatch  `json:"remove,omitempty"`
}

type UpdateRoleExtPayload struct {
	RoleExt []*RoleExt `json:"roleExt,omitempty"`
	NumUids *int       `json:"numUids,omitempty"`
}

type UpdateTensionInput struct {
	Filter *TensionFilter `json:"filter"`
	Set    *TensionPatch  `json:"set,omitempty"`
	Remove *TensionPatch  `json:"remove,omitempty"`
}

type UpdateTensionPayload struct {
	Tension []*Tension `json:"tension,omitempty"`
	NumUids *int       `json:"numUids,omitempty"`
}

type UpdateUserEventInput struct {
	Filter *UserEventFilter `json:"filter"`
	Set    *UserEventPatch  `json:"set,omitempty"`
	Remove *UserEventPatch  `json:"remove,omitempty"`
}

type UpdateUserEventPayload struct {
	UserEvent []*UserEvent `json:"userEvent,omitempty"`
	NumUids   *int         `json:"numUids,omitempty"`
}

type UpdateUserInput struct {
	Filter *UserFilter `json:"filter"`
	Set    *UserPatch  `json:"set,omitempty"`
	Remove *UserPatch  `json:"remove,omitempty"`
}

type UpdateUserPayload struct {
	User    []*User `json:"user,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type UpdateUserRightsInput struct {
	Filter *UserRightsFilter `json:"filter"`
	Set    *UserRightsPatch  `json:"set,omitempty"`
	Remove *UserRightsPatch  `json:"remove,omitempty"`
}

type UpdateUserRightsPayload struct {
	UserRights []*UserRights `json:"userRights,omitempty"`
	NumUids    *int          `json:"numUids,omitempty"`
}

type UpdateVoteInput struct {
	Filter *VoteFilter `json:"filter"`
	Set    *VotePatch  `json:"set,omitempty"`
	Remove *VotePatch  `json:"remove,omitempty"`
}

type UpdateVotePayload struct {
	Vote    []*Vote `json:"vote,omitempty"`
	NumUids *int    `json:"numUids,omitempty"`
}

type User struct {
	ID                        string                    `json:"id"`
	CreatedAt                 string                    `json:"createdAt"`
	LastAck                   string                    `json:"lastAck"`
	Username                  string                    `json:"username"`
	Name                      *string                   `json:"name,omitempty"`
	Email                     string                    `json:"email"`
	Password                  string                    `json:"password"`
	Bio                       *string                   `json:"bio,omitempty"`
	Location                  *string                   `json:"location,omitempty"`
	Utc                       *string                   `json:"utc,omitempty"`
	Links                     []string                  `json:"links,omitempty"`
	Skills                    []string                  `json:"skills,omitempty"`
	NotifyByEmail             bool                      `json:"notifyByEmail"`
	Lang                      Lang                      `json:"lang"`
	Subscriptions             []*Tension                `json:"subscriptions,omitempty"`
	Watching                  []*Node                   `json:"watching,omitempty"`
	Rights                    *UserRights               `json:"rights"`
	Roles                     []*Node                   `json:"roles,omitempty"`
	TensionsCreated           []*Tension                `json:"tensions_created,omitempty"`
	TensionsAssigned          []*Tension                `json:"tensions_assigned,omitempty"`
	Contracts                 []*Contract               `json:"contracts,omitempty"`
	Reactions                 []*Reaction               `json:"reactions,omitempty"`
	Events                    []*UserEvent              `json:"events,omitempty"`
	MarkAllAsRead             *string                   `json:"markAllAsRead,omitempty"`
	EventCount                *EventCount               `json:"event_count,omitempty"`
	SubscriptionsAggregate    *TensionAggregateResult   `json:"subscriptionsAggregate,omitempty"`
	WatchingAggregate         *NodeAggregateResult      `json:"watchingAggregate,omitempty"`
	RolesAggregate            *NodeAggregateResult      `json:"rolesAggregate,omitempty"`
	TensionsCreatedAggregate  *TensionAggregateResult   `json:"tensions_createdAggregate,omitempty"`
	TensionsAssignedAggregate *TensionAggregateResult   `json:"tensions_assignedAggregate,omitempty"`
	ContractsAggregate        *ContractAggregateResult  `json:"contractsAggregate,omitempty"`
	ReactionsAggregate        *ReactionAggregateResult  `json:"reactionsAggregate,omitempty"`
	EventsAggregate           *UserEventAggregateResult `json:"eventsAggregate,omitempty"`
}

type UserAggregateResult struct {
	Count            *int    `json:"count,omitempty"`
	CreatedAtMin     *string `json:"createdAtMin,omitempty"`
	CreatedAtMax     *string `json:"createdAtMax,omitempty"`
	LastAckMin       *string `json:"lastAckMin,omitempty"`
	LastAckMax       *string `json:"lastAckMax,omitempty"`
	UsernameMin      *string `json:"usernameMin,omitempty"`
	UsernameMax      *string `json:"usernameMax,omitempty"`
	NameMin          *string `json:"nameMin,omitempty"`
	NameMax          *string `json:"nameMax,omitempty"`
	EmailMin         *string `json:"emailMin,omitempty"`
	EmailMax         *string `json:"emailMax,omitempty"`
	PasswordMin      *string `json:"passwordMin,omitempty"`
	PasswordMax      *string `json:"passwordMax,omitempty"`
	BioMin           *string `json:"bioMin,omitempty"`
	BioMax           *string `json:"bioMax,omitempty"`
	LocationMin      *string `json:"locationMin,omitempty"`
	LocationMax      *string `json:"locationMax,omitempty"`
	UtcMin           *string `json:"utcMin,omitempty"`
	UtcMax           *string `json:"utcMax,omitempty"`
	MarkAllAsReadMin *string `json:"markAllAsReadMin,omitempty"`
	MarkAllAsReadMax *string `json:"markAllAsReadMax,omitempty"`
}

type UserEvent struct {
	ID        string      `json:"id"`
	CreatedAt string      `json:"createdAt"`
	IsRead    bool        `json:"isRead"`
	User      *User       `json:"user"`
	Event     []EventKind `json:"event,omitempty"`
}

type UserEventAggregateResult struct {
	Count        *int    `json:"count,omitempty"`
	CreatedAtMin *string `json:"createdAtMin,omitempty"`
	CreatedAtMax *string `json:"createdAtMax,omitempty"`
}

type UserEventFilter struct {
	ID        []string              `json:"id,omitempty"`
	CreatedAt *DateTimeFilter       `json:"createdAt,omitempty"`
	IsRead    *bool                 `json:"isRead,omitempty"`
	Has       []*UserEventHasFilter `json:"has,omitempty"`
	And       []*UserEventFilter    `json:"and,omitempty"`
	Or        []*UserEventFilter    `json:"or,omitempty"`
	Not       *UserEventFilter      `json:"not,omitempty"`
}

type UserEventOrder struct {
	Asc  *UserEventOrderable `json:"asc,omitempty"`
	Desc *UserEventOrderable `json:"desc,omitempty"`
	Then *UserEventOrder     `json:"then,omitempty"`
}

type UserEventPatch struct {
	CreatedAt *string         `json:"createdAt,omitempty"`
	IsRead    *bool           `json:"isRead,omitempty"`
	User      *UserRef        `json:"user,omitempty"`
	Event     []*EventKindRef `json:"event,omitempty"`
}

type UserEventRef struct {
	ID        *string         `json:"id,omitempty"`
	CreatedAt *string         `json:"createdAt,omitempty"`
	IsRead    *bool           `json:"isRead,omitempty"`
	User      *UserRef        `json:"user,omitempty"`
	Event     []*EventKindRef `json:"event,omitempty"`
}

type UserFilter struct {
	ID       []string                            `json:"id,omitempty"`
	Username *StringHashFilterStringRegExpFilter `json:"username,omitempty"`
	Name     *StringRegExpFilter                 `json:"name,omitempty"`
	Email    *StringHashFilter                   `json:"email,omitempty"`
	Has      []*UserHasFilter                    `json:"has,omitempty"`
	And      []*UserFilter                       `json:"and,omitempty"`
	Or       []*UserFilter                       `json:"or,omitempty"`
	Not      *UserFilter                         `json:"not,omitempty"`
}

type UserOrder struct {
	Asc  *UserOrderable `json:"asc,omitempty"`
	Desc *UserOrderable `json:"desc,omitempty"`
	Then *UserOrder     `json:"then,omitempty"`
}

type UserPatch struct {
	CreatedAt        *string         `json:"createdAt,omitempty"`
	LastAck          *string         `json:"lastAck,omitempty"`
	Name             *string         `json:"name,omitempty"`
	Password         *string         `json:"password,omitempty"`
	Bio              *string         `json:"bio,omitempty"`
	Location         *string         `json:"location,omitempty"`
	Utc              *string         `json:"utc,omitempty"`
	Links            []string        `json:"links,omitempty"`
	Skills           []string        `json:"skills,omitempty"`
	NotifyByEmail    *bool           `json:"notifyByEmail,omitempty"`
	Lang             *Lang           `json:"lang,omitempty"`
	Subscriptions    []*TensionRef   `json:"subscriptions,omitempty"`
	Watching         []*NodeRef      `json:"watching,omitempty"`
	Rights           *UserRightsRef  `json:"rights,omitempty"`
	Roles            []*NodeRef      `json:"roles,omitempty"`
	TensionsCreated  []*TensionRef   `json:"tensions_created,omitempty"`
	TensionsAssigned []*TensionRef   `json:"tensions_assigned,omitempty"`
	Contracts        []*ContractRef  `json:"contracts,omitempty"`
	Reactions        []*ReactionRef  `json:"reactions,omitempty"`
	Events           []*UserEventRef `json:"events,omitempty"`
	MarkAllAsRead    *string         `json:"markAllAsRead,omitempty"`
	EventCount       *EventCountRef  `json:"event_count,omitempty"`
}

type UserRef struct {
	ID               *string         `json:"id,omitempty"`
	CreatedAt        *string         `json:"createdAt,omitempty"`
	LastAck          *string         `json:"lastAck,omitempty"`
	Username         *string         `json:"username,omitempty"`
	Name             *string         `json:"name,omitempty"`
	Email            *string         `json:"email,omitempty"`
	Password         *string         `json:"password,omitempty"`
	Bio              *string         `json:"bio,omitempty"`
	Location         *string         `json:"location,omitempty"`
	Utc              *string         `json:"utc,omitempty"`
	Links            []string        `json:"links,omitempty"`
	Skills           []string        `json:"skills,omitempty"`
	NotifyByEmail    *bool           `json:"notifyByEmail,omitempty"`
	Lang             *Lang           `json:"lang,omitempty"`
	Subscriptions    []*TensionRef   `json:"subscriptions,omitempty"`
	Watching         []*NodeRef      `json:"watching,omitempty"`
	Rights           *UserRightsRef  `json:"rights,omitempty"`
	Roles            []*NodeRef      `json:"roles,omitempty"`
	TensionsCreated  []*TensionRef   `json:"tensions_created,omitempty"`
	TensionsAssigned []*TensionRef   `json:"tensions_assigned,omitempty"`
	Contracts        []*ContractRef  `json:"contracts,omitempty"`
	Reactions        []*ReactionRef  `json:"reactions,omitempty"`
	Events           []*UserEventRef `json:"events,omitempty"`
	MarkAllAsRead    *string         `json:"markAllAsRead,omitempty"`
	EventCount       *EventCountRef  `json:"event_count,omitempty"`
}

type UserRights struct {
	Type                  UserType `json:"type_"`
	CanLogin              bool     `json:"canLogin"`
	CanCreateRoot         bool     `json:"canCreateRoot"`
	MaxPublicOrga         int      `json:"maxPublicOrga"`
	MaxPrivateOrga        int      `json:"maxPrivateOrga"`
	HasEmailNotifications bool     `json:"hasEmailNotifications"`
}

type UserRightsAggregateResult struct {
	Count             *int     `json:"count,omitempty"`
	MaxPublicOrgaMin  *int     `json:"maxPublicOrgaMin,omitempty"`
	MaxPublicOrgaMax  *int     `json:"maxPublicOrgaMax,omitempty"`
	MaxPublicOrgaSum  *int     `json:"maxPublicOrgaSum,omitempty"`
	MaxPublicOrgaAvg  *float64 `json:"maxPublicOrgaAvg,omitempty"`
	MaxPrivateOrgaMin *int     `json:"maxPrivateOrgaMin,omitempty"`
	MaxPrivateOrgaMax *int     `json:"maxPrivateOrgaMax,omitempty"`
	MaxPrivateOrgaSum *int     `json:"maxPrivateOrgaSum,omitempty"`
	MaxPrivateOrgaAvg *float64 `json:"maxPrivateOrgaAvg,omitempty"`
}

type UserRightsFilter struct {
	Has []*UserRightsHasFilter `json:"has,omitempty"`
	And []*UserRightsFilter    `json:"and,omitempty"`
	Or  []*UserRightsFilter    `json:"or,omitempty"`
	Not *UserRightsFilter      `json:"not,omitempty"`
}

type UserRightsOrder struct {
	Asc  *UserRightsOrderable `json:"asc,omitempty"`
	Desc *UserRightsOrderable `json:"desc,omitempty"`
	Then *UserRightsOrder     `json:"then,omitempty"`
}

type UserRightsPatch struct {
	Type                  *UserType `json:"type_,omitempty"`
	CanLogin              *bool     `json:"canLogin,omitempty"`
	CanCreateRoot         *bool     `json:"canCreateRoot,omitempty"`
	MaxPublicOrga         *int      `json:"maxPublicOrga,omitempty"`
	MaxPrivateOrga        *int      `json:"maxPrivateOrga,omitempty"`
	HasEmailNotifications *bool     `json:"hasEmailNotifications,omitempty"`
}

type UserRightsRef struct {
	Type                  *UserType `json:"type_,omitempty"`
	CanLogin              *bool     `json:"canLogin,omitempty"`
	CanCreateRoot         *bool     `json:"canCreateRoot,omitempty"`
	MaxPublicOrga         *int      `json:"maxPublicOrga,omitempty"`
	MaxPrivateOrga        *int      `json:"maxPrivateOrga,omitempty"`
	HasEmailNotifications *bool     `json:"hasEmailNotifications,omitempty"`
}

type Vote struct {
	Voteid    string    `json:"voteid"`
	Contract  *Contract `json:"contract"`
	Node      *Node     `json:"node"`
	Data      []int     `json:"data"`
	ID        string    `json:"id"`
	CreatedBy *User     `json:"createdBy"`
	CreatedAt string    `json:"createdAt"`
	UpdatedAt *string   `json:"updatedAt,omitempty"`
	Message   *string   `json:"message,omitempty"`
}

type VoteAggregateResult struct {
	Count        *int    `json:"count,omitempty"`
	CreatedAtMin *string `json:"createdAtMin,omitempty"`
	CreatedAtMax *string `json:"createdAtMax,omitempty"`
	UpdatedAtMin *string `json:"updatedAtMin,omitempty"`
	UpdatedAtMax *string `json:"updatedAtMax,omitempty"`
	MessageMin   *string `json:"messageMin,omitempty"`
	MessageMax   *string `json:"messageMax,omitempty"`
	VoteidMin    *string `json:"voteidMin,omitempty"`
	VoteidMax    *string `json:"voteidMax,omitempty"`
}

type VoteFilter struct {
	ID        []string              `json:"id,omitempty"`
	CreatedAt *DateTimeFilter       `json:"createdAt,omitempty"`
	Message   *StringFullTextFilter `json:"message,omitempty"`
	Voteid    *StringHashFilter     `json:"voteid,omitempty"`
	Has       []*VoteHasFilter      `json:"has,omitempty"`
	And       []*VoteFilter         `json:"and,omitempty"`
	Or        []*VoteFilter         `json:"or,omitempty"`
	Not       *VoteFilter           `json:"not,omitempty"`
}

type VoteOrder struct {
	Asc  *VoteOrderable `json:"asc,omitempty"`
	Desc *VoteOrderable `json:"desc,omitempty"`
	Then *VoteOrder     `json:"then,omitempty"`
}

type VotePatch struct {
	CreatedBy *UserRef     `json:"createdBy,omitempty"`
	CreatedAt *string      `json:"createdAt,omitempty"`
	UpdatedAt *string      `json:"updatedAt,omitempty"`
	Message   *string      `json:"message,omitempty"`
	Contract  *ContractRef `json:"contract,omitempty"`
	Node      *NodeRef     `json:"node,omitempty"`
	Data      []int        `json:"data,omitempty"`
}

type VoteRef struct {
	ID        *string      `json:"id,omitempty"`
	CreatedBy *UserRef     `json:"createdBy,omitempty"`
	CreatedAt *string      `json:"createdAt,omitempty"`
	UpdatedAt *string      `json:"updatedAt,omitempty"`
	Message   *string      `json:"message,omitempty"`
	Voteid    *string      `json:"voteid,omitempty"`
	Contract  *ContractRef `json:"contract,omitempty"`
	Node      *NodeRef     `json:"node,omitempty"`
	Data      []int        `json:"data,omitempty"`
}

type WithinFilter struct {
	Polygon *PolygonRef `json:"polygon"`
}

type BlobHasFilter string

const (
	BlobHasFilterCreatedBy    BlobHasFilter = "createdBy"
	BlobHasFilterCreatedAt    BlobHasFilter = "createdAt"
	BlobHasFilterUpdatedAt    BlobHasFilter = "updatedAt"
	BlobHasFilterMessage      BlobHasFilter = "message"
	BlobHasFilterTension      BlobHasFilter = "tension"
	BlobHasFilterBlobType     BlobHasFilter = "blob_type"
	BlobHasFilterPushedFlag   BlobHasFilter = "pushedFlag"
	BlobHasFilterArchivedFlag BlobHasFilter = "archivedFlag"
	BlobHasFilterNode         BlobHasFilter = "node"
	BlobHasFilterMd           BlobHasFilter = "md"
)

var AllBlobHasFilter = []BlobHasFilter{
	BlobHasFilterCreatedBy,
	BlobHasFilterCreatedAt,
	BlobHasFilterUpdatedAt,
	BlobHasFilterMessage,
	BlobHasFilterTension,
	BlobHasFilterBlobType,
	BlobHasFilterPushedFlag,
	BlobHasFilterArchivedFlag,
	BlobHasFilterNode,
	BlobHasFilterMd,
}

func (e BlobHasFilter) IsValid() bool {
	switch e {
	case BlobHasFilterCreatedBy, BlobHasFilterCreatedAt, BlobHasFilterUpdatedAt, BlobHasFilterMessage, BlobHasFilterTension, BlobHasFilterBlobType, BlobHasFilterPushedFlag, BlobHasFilterArchivedFlag, BlobHasFilterNode, BlobHasFilterMd:
		return true
	}
	return false
}

func (e BlobHasFilter) String() string {
	return string(e)
}

func (e *BlobHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BlobHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BlobHasFilter", str)
	}
	return nil
}

func (e BlobHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BlobOrderable string

const (
	BlobOrderableCreatedAt    BlobOrderable = "createdAt"
	BlobOrderableUpdatedAt    BlobOrderable = "updatedAt"
	BlobOrderableMessage      BlobOrderable = "message"
	BlobOrderablePushedFlag   BlobOrderable = "pushedFlag"
	BlobOrderableArchivedFlag BlobOrderable = "archivedFlag"
	BlobOrderableMd           BlobOrderable = "md"
)

var AllBlobOrderable = []BlobOrderable{
	BlobOrderableCreatedAt,
	BlobOrderableUpdatedAt,
	BlobOrderableMessage,
	BlobOrderablePushedFlag,
	BlobOrderableArchivedFlag,
	BlobOrderableMd,
}

func (e BlobOrderable) IsValid() bool {
	switch e {
	case BlobOrderableCreatedAt, BlobOrderableUpdatedAt, BlobOrderableMessage, BlobOrderablePushedFlag, BlobOrderableArchivedFlag, BlobOrderableMd:
		return true
	}
	return false
}

func (e BlobOrderable) String() string {
	return string(e)
}

func (e *BlobOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BlobOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BlobOrderable", str)
	}
	return nil
}

func (e BlobOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BlobType string

const (
	BlobTypeOnNode            BlobType = "OnNode"
	BlobTypeOnAbout           BlobType = "OnAbout"
	BlobTypeOnMandate         BlobType = "OnMandate"
	BlobTypeOnAboutAndMandate BlobType = "OnAboutAndMandate"
	BlobTypeOnDoc             BlobType = "OnDoc"
)

var AllBlobType = []BlobType{
	BlobTypeOnNode,
	BlobTypeOnAbout,
	BlobTypeOnMandate,
	BlobTypeOnAboutAndMandate,
	BlobTypeOnDoc,
}

func (e BlobType) IsValid() bool {
	switch e {
	case BlobTypeOnNode, BlobTypeOnAbout, BlobTypeOnMandate, BlobTypeOnAboutAndMandate, BlobTypeOnDoc:
		return true
	}
	return false
}

func (e BlobType) String() string {
	return string(e)
}

func (e *BlobType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BlobType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BlobType", str)
	}
	return nil
}

func (e BlobType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CardKindType string

const (
	CardKindTypeTension      CardKindType = "Tension"
	CardKindTypeProjectDraft CardKindType = "ProjectDraft"
)

var AllCardKindType = []CardKindType{
	CardKindTypeTension,
	CardKindTypeProjectDraft,
}

func (e CardKindType) IsValid() bool {
	switch e {
	case CardKindTypeTension, CardKindTypeProjectDraft:
		return true
	}
	return false
}

func (e CardKindType) String() string {
	return string(e)
}

func (e *CardKindType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CardKindType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CardKindType", str)
	}
	return nil
}

func (e CardKindType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CommentHasFilter string

const (
	CommentHasFilterCreatedBy CommentHasFilter = "createdBy"
	CommentHasFilterCreatedAt CommentHasFilter = "createdAt"
	CommentHasFilterUpdatedAt CommentHasFilter = "updatedAt"
	CommentHasFilterMessage   CommentHasFilter = "message"
	CommentHasFilterReactions CommentHasFilter = "reactions"
)

var AllCommentHasFilter = []CommentHasFilter{
	CommentHasFilterCreatedBy,
	CommentHasFilterCreatedAt,
	CommentHasFilterUpdatedAt,
	CommentHasFilterMessage,
	CommentHasFilterReactions,
}

func (e CommentHasFilter) IsValid() bool {
	switch e {
	case CommentHasFilterCreatedBy, CommentHasFilterCreatedAt, CommentHasFilterUpdatedAt, CommentHasFilterMessage, CommentHasFilterReactions:
		return true
	}
	return false
}

func (e CommentHasFilter) String() string {
	return string(e)
}

func (e *CommentHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommentHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CommentHasFilter", str)
	}
	return nil
}

func (e CommentHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CommentOrderable string

const (
	CommentOrderableCreatedAt CommentOrderable = "createdAt"
	CommentOrderableUpdatedAt CommentOrderable = "updatedAt"
	CommentOrderableMessage   CommentOrderable = "message"
)

var AllCommentOrderable = []CommentOrderable{
	CommentOrderableCreatedAt,
	CommentOrderableUpdatedAt,
	CommentOrderableMessage,
}

func (e CommentOrderable) IsValid() bool {
	switch e {
	case CommentOrderableCreatedAt, CommentOrderableUpdatedAt, CommentOrderableMessage:
		return true
	}
	return false
}

func (e CommentOrderable) String() string {
	return string(e)
}

func (e *CommentOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommentOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CommentOrderable", str)
	}
	return nil
}

func (e CommentOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ContractHasFilter string

const (
	ContractHasFilterCreatedBy         ContractHasFilter = "createdBy"
	ContractHasFilterCreatedAt         ContractHasFilter = "createdAt"
	ContractHasFilterUpdatedAt         ContractHasFilter = "updatedAt"
	ContractHasFilterMessage           ContractHasFilter = "message"
	ContractHasFilterContractid        ContractHasFilter = "contractid"
	ContractHasFilterTension           ContractHasFilter = "tension"
	ContractHasFilterStatus            ContractHasFilter = "status"
	ContractHasFilterContractType      ContractHasFilter = "contract_type"
	ContractHasFilterClosedAt          ContractHasFilter = "closedAt"
	ContractHasFilterEvent             ContractHasFilter = "event"
	ContractHasFilterParticipants      ContractHasFilter = "participants"
	ContractHasFilterCandidates        ContractHasFilter = "candidates"
	ContractHasFilterPendingCandidates ContractHasFilter = "pending_candidates"
	ContractHasFilterComments          ContractHasFilter = "comments"
	ContractHasFilterIsValidator       ContractHasFilter = "isValidator"
)

var AllContractHasFilter = []ContractHasFilter{
	ContractHasFilterCreatedBy,
	ContractHasFilterCreatedAt,
	ContractHasFilterUpdatedAt,
	ContractHasFilterMessage,
	ContractHasFilterContractid,
	ContractHasFilterTension,
	ContractHasFilterStatus,
	ContractHasFilterContractType,
	ContractHasFilterClosedAt,
	ContractHasFilterEvent,
	ContractHasFilterParticipants,
	ContractHasFilterCandidates,
	ContractHasFilterPendingCandidates,
	ContractHasFilterComments,
	ContractHasFilterIsValidator,
}

func (e ContractHasFilter) IsValid() bool {
	switch e {
	case ContractHasFilterCreatedBy, ContractHasFilterCreatedAt, ContractHasFilterUpdatedAt, ContractHasFilterMessage, ContractHasFilterContractid, ContractHasFilterTension, ContractHasFilterStatus, ContractHasFilterContractType, ContractHasFilterClosedAt, ContractHasFilterEvent, ContractHasFilterParticipants, ContractHasFilterCandidates, ContractHasFilterPendingCandidates, ContractHasFilterComments, ContractHasFilterIsValidator:
		return true
	}
	return false
}

func (e ContractHasFilter) String() string {
	return string(e)
}

func (e *ContractHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContractHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContractHasFilter", str)
	}
	return nil
}

func (e ContractHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ContractOrderable string

const (
	ContractOrderableCreatedAt  ContractOrderable = "createdAt"
	ContractOrderableUpdatedAt  ContractOrderable = "updatedAt"
	ContractOrderableMessage    ContractOrderable = "message"
	ContractOrderableContractid ContractOrderable = "contractid"
	ContractOrderableClosedAt   ContractOrderable = "closedAt"
)

var AllContractOrderable = []ContractOrderable{
	ContractOrderableCreatedAt,
	ContractOrderableUpdatedAt,
	ContractOrderableMessage,
	ContractOrderableContractid,
	ContractOrderableClosedAt,
}

func (e ContractOrderable) IsValid() bool {
	switch e {
	case ContractOrderableCreatedAt, ContractOrderableUpdatedAt, ContractOrderableMessage, ContractOrderableContractid, ContractOrderableClosedAt:
		return true
	}
	return false
}

func (e ContractOrderable) String() string {
	return string(e)
}

func (e *ContractOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContractOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContractOrderable", str)
	}
	return nil
}

func (e ContractOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ContractStatus string

const (
	ContractStatusOpen     ContractStatus = "Open"
	ContractStatusClosed   ContractStatus = "Closed"
	ContractStatusCanceled ContractStatus = "Canceled"
)

var AllContractStatus = []ContractStatus{
	ContractStatusOpen,
	ContractStatusClosed,
	ContractStatusCanceled,
}

func (e ContractStatus) IsValid() bool {
	switch e {
	case ContractStatusOpen, ContractStatusClosed, ContractStatusCanceled:
		return true
	}
	return false
}

func (e ContractStatus) String() string {
	return string(e)
}

func (e *ContractStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContractStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContractStatus", str)
	}
	return nil
}

func (e ContractStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ContractType string

const (
	ContractTypeAnyCoordoDual   ContractType = "AnyCoordoDual"
	ContractTypeAnyCandidates   ContractType = "AnyCandidates"
	ContractTypeAnyCoordoSource ContractType = "AnyCoordoSource"
	ContractTypeAnyCoordoTarget ContractType = "AnyCoordoTarget"
)

var AllContractType = []ContractType{
	ContractTypeAnyCoordoDual,
	ContractTypeAnyCandidates,
	ContractTypeAnyCoordoSource,
	ContractTypeAnyCoordoTarget,
}

func (e ContractType) IsValid() bool {
	switch e {
	case ContractTypeAnyCoordoDual, ContractTypeAnyCandidates, ContractTypeAnyCoordoSource, ContractTypeAnyCoordoTarget:
		return true
	}
	return false
}

func (e ContractType) String() string {
	return string(e)
}

func (e *ContractType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContractType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContractType", str)
	}
	return nil
}

func (e ContractType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DgraphIndex string

const (
	DgraphIndexInt      DgraphIndex = "int"
	DgraphIndexInt64    DgraphIndex = "int64"
	DgraphIndexFloat    DgraphIndex = "float"
	DgraphIndexBool     DgraphIndex = "bool"
	DgraphIndexHash     DgraphIndex = "hash"
	DgraphIndexExact    DgraphIndex = "exact"
	DgraphIndexTerm     DgraphIndex = "term"
	DgraphIndexFulltext DgraphIndex = "fulltext"
	DgraphIndexTrigram  DgraphIndex = "trigram"
	DgraphIndexRegexp   DgraphIndex = "regexp"
	DgraphIndexYear     DgraphIndex = "year"
	DgraphIndexMonth    DgraphIndex = "month"
	DgraphIndexDay      DgraphIndex = "day"
	DgraphIndexHour     DgraphIndex = "hour"
	DgraphIndexGeo      DgraphIndex = "geo"
)

var AllDgraphIndex = []DgraphIndex{
	DgraphIndexInt,
	DgraphIndexInt64,
	DgraphIndexFloat,
	DgraphIndexBool,
	DgraphIndexHash,
	DgraphIndexExact,
	DgraphIndexTerm,
	DgraphIndexFulltext,
	DgraphIndexTrigram,
	DgraphIndexRegexp,
	DgraphIndexYear,
	DgraphIndexMonth,
	DgraphIndexDay,
	DgraphIndexHour,
	DgraphIndexGeo,
}

func (e DgraphIndex) IsValid() bool {
	switch e {
	case DgraphIndexInt, DgraphIndexInt64, DgraphIndexFloat, DgraphIndexBool, DgraphIndexHash, DgraphIndexExact, DgraphIndexTerm, DgraphIndexFulltext, DgraphIndexTrigram, DgraphIndexRegexp, DgraphIndexYear, DgraphIndexMonth, DgraphIndexDay, DgraphIndexHour, DgraphIndexGeo:
		return true
	}
	return false
}

func (e DgraphIndex) String() string {
	return string(e)
}

func (e *DgraphIndex) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DgraphIndex(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DgraphIndex", str)
	}
	return nil
}

func (e DgraphIndex) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ErrorBla string

const (
	ErrorBlaContactCoordo       ErrorBla = "ContactCoordo"
	ErrorBlaOrgaLimitReached    ErrorBla = "OrgaLimitReached"
	ErrorBlaMemberLimitReached  ErrorBla = "MemberLimitReached"
	ErrorBlaEmailLimitReached   ErrorBla = "EmailLimitReached"
	ErrorBlaStorageLimitReached ErrorBla = "StorageLimitReached"
)

var AllErrorBla = []ErrorBla{
	ErrorBlaContactCoordo,
	ErrorBlaOrgaLimitReached,
	ErrorBlaMemberLimitReached,
	ErrorBlaEmailLimitReached,
	ErrorBlaStorageLimitReached,
}

func (e ErrorBla) IsValid() bool {
	switch e {
	case ErrorBlaContactCoordo, ErrorBlaOrgaLimitReached, ErrorBlaMemberLimitReached, ErrorBlaEmailLimitReached, ErrorBlaStorageLimitReached:
		return true
	}
	return false
}

func (e ErrorBla) String() string {
	return string(e)
}

func (e *ErrorBla) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ErrorBla(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ErrorBla", str)
	}
	return nil
}

func (e ErrorBla) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EventCountHasFilter string

const (
	EventCountHasFilterUnreadEvents     EventCountHasFilter = "unread_events"
	EventCountHasFilterPendingContracts EventCountHasFilter = "pending_contracts"
	EventCountHasFilterAssignedTensions EventCountHasFilter = "assigned_tensions"
)

var AllEventCountHasFilter = []EventCountHasFilter{
	EventCountHasFilterUnreadEvents,
	EventCountHasFilterPendingContracts,
	EventCountHasFilterAssignedTensions,
}

func (e EventCountHasFilter) IsValid() bool {
	switch e {
	case EventCountHasFilterUnreadEvents, EventCountHasFilterPendingContracts, EventCountHasFilterAssignedTensions:
		return true
	}
	return false
}

func (e EventCountHasFilter) String() string {
	return string(e)
}

func (e *EventCountHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventCountHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventCountHasFilter", str)
	}
	return nil
}

func (e EventCountHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EventCountOrderable string

const (
	EventCountOrderableUnreadEvents     EventCountOrderable = "unread_events"
	EventCountOrderablePendingContracts EventCountOrderable = "pending_contracts"
	EventCountOrderableAssignedTensions EventCountOrderable = "assigned_tensions"
)

var AllEventCountOrderable = []EventCountOrderable{
	EventCountOrderableUnreadEvents,
	EventCountOrderablePendingContracts,
	EventCountOrderableAssignedTensions,
}

func (e EventCountOrderable) IsValid() bool {
	switch e {
	case EventCountOrderableUnreadEvents, EventCountOrderablePendingContracts, EventCountOrderableAssignedTensions:
		return true
	}
	return false
}

func (e EventCountOrderable) String() string {
	return string(e)
}

func (e *EventCountOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventCountOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventCountOrderable", str)
	}
	return nil
}

func (e EventCountOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EventFragmentHasFilter string

const (
	EventFragmentHasFilterEventType EventFragmentHasFilter = "event_type"
	EventFragmentHasFilterOld       EventFragmentHasFilter = "old"
	EventFragmentHasFilterNew       EventFragmentHasFilter = "new"
)

var AllEventFragmentHasFilter = []EventFragmentHasFilter{
	EventFragmentHasFilterEventType,
	EventFragmentHasFilterOld,
	EventFragmentHasFilterNew,
}

func (e EventFragmentHasFilter) IsValid() bool {
	switch e {
	case EventFragmentHasFilterEventType, EventFragmentHasFilterOld, EventFragmentHasFilterNew:
		return true
	}
	return false
}

func (e EventFragmentHasFilter) String() string {
	return string(e)
}

func (e *EventFragmentHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventFragmentHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventFragmentHasFilter", str)
	}
	return nil
}

func (e EventFragmentHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EventFragmentOrderable string

const (
	EventFragmentOrderableOld EventFragmentOrderable = "old"
	EventFragmentOrderableNew EventFragmentOrderable = "new"
)

var AllEventFragmentOrderable = []EventFragmentOrderable{
	EventFragmentOrderableOld,
	EventFragmentOrderableNew,
}

func (e EventFragmentOrderable) IsValid() bool {
	switch e {
	case EventFragmentOrderableOld, EventFragmentOrderableNew:
		return true
	}
	return false
}

func (e EventFragmentOrderable) String() string {
	return string(e)
}

func (e *EventFragmentOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventFragmentOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventFragmentOrderable", str)
	}
	return nil
}

func (e EventFragmentOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EventHasFilter string

const (
	EventHasFilterCreatedBy EventHasFilter = "createdBy"
	EventHasFilterCreatedAt EventHasFilter = "createdAt"
	EventHasFilterUpdatedAt EventHasFilter = "updatedAt"
	EventHasFilterMessage   EventHasFilter = "message"
	EventHasFilterTension   EventHasFilter = "tension"
	EventHasFilterEventType EventHasFilter = "event_type"
	EventHasFilterMentioned EventHasFilter = "mentioned"
	EventHasFilterOld       EventHasFilter = "old"
	EventHasFilterNew       EventHasFilter = "new"
)

var AllEventHasFilter = []EventHasFilter{
	EventHasFilterCreatedBy,
	EventHasFilterCreatedAt,
	EventHasFilterUpdatedAt,
	EventHasFilterMessage,
	EventHasFilterTension,
	EventHasFilterEventType,
	EventHasFilterMentioned,
	EventHasFilterOld,
	EventHasFilterNew,
}

func (e EventHasFilter) IsValid() bool {
	switch e {
	case EventHasFilterCreatedBy, EventHasFilterCreatedAt, EventHasFilterUpdatedAt, EventHasFilterMessage, EventHasFilterTension, EventHasFilterEventType, EventHasFilterMentioned, EventHasFilterOld, EventHasFilterNew:
		return true
	}
	return false
}

func (e EventHasFilter) String() string {
	return string(e)
}

func (e *EventHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventHasFilter", str)
	}
	return nil
}

func (e EventHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EventKindType string

const (
	EventKindTypeEvent    EventKindType = "Event"
	EventKindTypeContract EventKindType = "Contract"
	EventKindTypeNotif    EventKindType = "Notif"
)

var AllEventKindType = []EventKindType{
	EventKindTypeEvent,
	EventKindTypeContract,
	EventKindTypeNotif,
}

func (e EventKindType) IsValid() bool {
	switch e {
	case EventKindTypeEvent, EventKindTypeContract, EventKindTypeNotif:
		return true
	}
	return false
}

func (e EventKindType) String() string {
	return string(e)
}

func (e *EventKindType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventKindType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventKindType", str)
	}
	return nil
}

func (e EventKindType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EventOrderable string

const (
	EventOrderableCreatedAt EventOrderable = "createdAt"
	EventOrderableUpdatedAt EventOrderable = "updatedAt"
	EventOrderableMessage   EventOrderable = "message"
	EventOrderableOld       EventOrderable = "old"
	EventOrderableNew       EventOrderable = "new"
)

var AllEventOrderable = []EventOrderable{
	EventOrderableCreatedAt,
	EventOrderableUpdatedAt,
	EventOrderableMessage,
	EventOrderableOld,
	EventOrderableNew,
}

func (e EventOrderable) IsValid() bool {
	switch e {
	case EventOrderableCreatedAt, EventOrderableUpdatedAt, EventOrderableMessage, EventOrderableOld, EventOrderableNew:
		return true
	}
	return false
}

func (e EventOrderable) String() string {
	return string(e)
}

func (e *EventOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventOrderable", str)
	}
	return nil
}

func (e EventOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HTTPMethod string

const (
	HTTPMethodGet    HTTPMethod = "GET"
	HTTPMethodPost   HTTPMethod = "POST"
	HTTPMethodPut    HTTPMethod = "PUT"
	HTTPMethodPatch  HTTPMethod = "PATCH"
	HTTPMethodDelete HTTPMethod = "DELETE"
)

var AllHTTPMethod = []HTTPMethod{
	HTTPMethodGet,
	HTTPMethodPost,
	HTTPMethodPut,
	HTTPMethodPatch,
	HTTPMethodDelete,
}

func (e HTTPMethod) IsValid() bool {
	switch e {
	case HTTPMethodGet, HTTPMethodPost, HTTPMethodPut, HTTPMethodPatch, HTTPMethodDelete:
		return true
	}
	return false
}

func (e HTTPMethod) String() string {
	return string(e)
}

func (e *HTTPMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HTTPMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HTTPMethod", str)
	}
	return nil
}

func (e HTTPMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LabelHasFilter string

const (
	LabelHasFilterRootnameid  LabelHasFilter = "rootnameid"
	LabelHasFilterName        LabelHasFilter = "name"
	LabelHasFilterDescription LabelHasFilter = "description"
	LabelHasFilterColor       LabelHasFilter = "color"
	LabelHasFilterTensions    LabelHasFilter = "tensions"
	LabelHasFilterNodes       LabelHasFilter = "nodes"
)

var AllLabelHasFilter = []LabelHasFilter{
	LabelHasFilterRootnameid,
	LabelHasFilterName,
	LabelHasFilterDescription,
	LabelHasFilterColor,
	LabelHasFilterTensions,
	LabelHasFilterNodes,
}

func (e LabelHasFilter) IsValid() bool {
	switch e {
	case LabelHasFilterRootnameid, LabelHasFilterName, LabelHasFilterDescription, LabelHasFilterColor, LabelHasFilterTensions, LabelHasFilterNodes:
		return true
	}
	return false
}

func (e LabelHasFilter) String() string {
	return string(e)
}

func (e *LabelHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LabelHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LabelHasFilter", str)
	}
	return nil
}

func (e LabelHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LabelOrderable string

const (
	LabelOrderableRootnameid  LabelOrderable = "rootnameid"
	LabelOrderableName        LabelOrderable = "name"
	LabelOrderableDescription LabelOrderable = "description"
	LabelOrderableColor       LabelOrderable = "color"
)

var AllLabelOrderable = []LabelOrderable{
	LabelOrderableRootnameid,
	LabelOrderableName,
	LabelOrderableDescription,
	LabelOrderableColor,
}

func (e LabelOrderable) IsValid() bool {
	switch e {
	case LabelOrderableRootnameid, LabelOrderableName, LabelOrderableDescription, LabelOrderableColor:
		return true
	}
	return false
}

func (e LabelOrderable) String() string {
	return string(e)
}

func (e *LabelOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LabelOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LabelOrderable", str)
	}
	return nil
}

func (e LabelOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Lang string

const (
	LangEn Lang = "EN"
	LangFr Lang = "FR"
)

var AllLang = []Lang{
	LangEn,
	LangFr,
}

func (e Lang) IsValid() bool {
	switch e {
	case LangEn, LangFr:
		return true
	}
	return false
}

func (e Lang) String() string {
	return string(e)
}

func (e *Lang) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Lang(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Lang", str)
	}
	return nil
}

func (e Lang) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MandateHasFilter string

const (
	MandateHasFilterPurpose          MandateHasFilter = "purpose"
	MandateHasFilterResponsabilities MandateHasFilter = "responsabilities"
	MandateHasFilterDomains          MandateHasFilter = "domains"
	MandateHasFilterPolicies         MandateHasFilter = "policies"
)

var AllMandateHasFilter = []MandateHasFilter{
	MandateHasFilterPurpose,
	MandateHasFilterResponsabilities,
	MandateHasFilterDomains,
	MandateHasFilterPolicies,
}

func (e MandateHasFilter) IsValid() bool {
	switch e {
	case MandateHasFilterPurpose, MandateHasFilterResponsabilities, MandateHasFilterDomains, MandateHasFilterPolicies:
		return true
	}
	return false
}

func (e MandateHasFilter) String() string {
	return string(e)
}

func (e *MandateHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MandateHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MandateHasFilter", str)
	}
	return nil
}

func (e MandateHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MandateOrderable string

const (
	MandateOrderablePurpose          MandateOrderable = "purpose"
	MandateOrderableResponsabilities MandateOrderable = "responsabilities"
	MandateOrderableDomains          MandateOrderable = "domains"
	MandateOrderablePolicies         MandateOrderable = "policies"
)

var AllMandateOrderable = []MandateOrderable{
	MandateOrderablePurpose,
	MandateOrderableResponsabilities,
	MandateOrderableDomains,
	MandateOrderablePolicies,
}

func (e MandateOrderable) IsValid() bool {
	switch e {
	case MandateOrderablePurpose, MandateOrderableResponsabilities, MandateOrderableDomains, MandateOrderablePolicies:
		return true
	}
	return false
}

func (e MandateOrderable) String() string {
	return string(e)
}

func (e *MandateOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MandateOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MandateOrderable", str)
	}
	return nil
}

func (e MandateOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Mode string

const (
	ModeBatch  Mode = "BATCH"
	ModeSingle Mode = "SINGLE"
)

var AllMode = []Mode{
	ModeBatch,
	ModeSingle,
}

func (e Mode) IsValid() bool {
	switch e {
	case ModeBatch, ModeSingle:
		return true
	}
	return false
}

func (e Mode) String() string {
	return string(e)
}

func (e *Mode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Mode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Mode", str)
	}
	return nil
}

func (e Mode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NodeFragmentHasFilter string

const (
	NodeFragmentHasFilterNameid     NodeFragmentHasFilter = "nameid"
	NodeFragmentHasFilterName       NodeFragmentHasFilter = "name"
	NodeFragmentHasFilterAbout      NodeFragmentHasFilter = "about"
	NodeFragmentHasFilterMandate    NodeFragmentHasFilter = "mandate"
	NodeFragmentHasFilterSkills     NodeFragmentHasFilter = "skills"
	NodeFragmentHasFilterVisibility NodeFragmentHasFilter = "visibility"
	NodeFragmentHasFilterMode       NodeFragmentHasFilter = "mode"
	NodeFragmentHasFilterType       NodeFragmentHasFilter = "type_"
	NodeFragmentHasFilterFirstLink  NodeFragmentHasFilter = "first_link"
	NodeFragmentHasFilterRoleExt    NodeFragmentHasFilter = "role_ext"
	NodeFragmentHasFilterRoleType   NodeFragmentHasFilter = "role_type"
	NodeFragmentHasFilterColor      NodeFragmentHasFilter = "color"
)

var AllNodeFragmentHasFilter = []NodeFragmentHasFilter{
	NodeFragmentHasFilterNameid,
	NodeFragmentHasFilterName,
	NodeFragmentHasFilterAbout,
	NodeFragmentHasFilterMandate,
	NodeFragmentHasFilterSkills,
	NodeFragmentHasFilterVisibility,
	NodeFragmentHasFilterMode,
	NodeFragmentHasFilterType,
	NodeFragmentHasFilterFirstLink,
	NodeFragmentHasFilterRoleExt,
	NodeFragmentHasFilterRoleType,
	NodeFragmentHasFilterColor,
}

func (e NodeFragmentHasFilter) IsValid() bool {
	switch e {
	case NodeFragmentHasFilterNameid, NodeFragmentHasFilterName, NodeFragmentHasFilterAbout, NodeFragmentHasFilterMandate, NodeFragmentHasFilterSkills, NodeFragmentHasFilterVisibility, NodeFragmentHasFilterMode, NodeFragmentHasFilterType, NodeFragmentHasFilterFirstLink, NodeFragmentHasFilterRoleExt, NodeFragmentHasFilterRoleType, NodeFragmentHasFilterColor:
		return true
	}
	return false
}

func (e NodeFragmentHasFilter) String() string {
	return string(e)
}

func (e *NodeFragmentHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeFragmentHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeFragmentHasFilter", str)
	}
	return nil
}

func (e NodeFragmentHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NodeFragmentOrderable string

const (
	NodeFragmentOrderableNameid    NodeFragmentOrderable = "nameid"
	NodeFragmentOrderableName      NodeFragmentOrderable = "name"
	NodeFragmentOrderableAbout     NodeFragmentOrderable = "about"
	NodeFragmentOrderableFirstLink NodeFragmentOrderable = "first_link"
	NodeFragmentOrderableRoleExt   NodeFragmentOrderable = "role_ext"
	NodeFragmentOrderableColor     NodeFragmentOrderable = "color"
)

var AllNodeFragmentOrderable = []NodeFragmentOrderable{
	NodeFragmentOrderableNameid,
	NodeFragmentOrderableName,
	NodeFragmentOrderableAbout,
	NodeFragmentOrderableFirstLink,
	NodeFragmentOrderableRoleExt,
	NodeFragmentOrderableColor,
}

func (e NodeFragmentOrderable) IsValid() bool {
	switch e {
	case NodeFragmentOrderableNameid, NodeFragmentOrderableName, NodeFragmentOrderableAbout, NodeFragmentOrderableFirstLink, NodeFragmentOrderableRoleExt, NodeFragmentOrderableColor:
		return true
	}
	return false
}

func (e NodeFragmentOrderable) String() string {
	return string(e)
}

func (e *NodeFragmentOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeFragmentOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeFragmentOrderable", str)
	}
	return nil
}

func (e NodeFragmentOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NodeHasFilter string

const (
	NodeHasFilterCreatedBy             NodeHasFilter = "createdBy"
	NodeHasFilterCreatedAt             NodeHasFilter = "createdAt"
	NodeHasFilterUpdatedAt             NodeHasFilter = "updatedAt"
	NodeHasFilterNameid                NodeHasFilter = "nameid"
	NodeHasFilterRootnameid            NodeHasFilter = "rootnameid"
	NodeHasFilterSource                NodeHasFilter = "source"
	NodeHasFilterName                  NodeHasFilter = "name"
	NodeHasFilterAbout                 NodeHasFilter = "about"
	NodeHasFilterSkills                NodeHasFilter = "skills"
	NodeHasFilterIsRoot                NodeHasFilter = "isRoot"
	NodeHasFilterParent                NodeHasFilter = "parent"
	NodeHasFilterType                  NodeHasFilter = "type_"
	NodeHasFilterTensionsOut           NodeHasFilter = "tensions_out"
	NodeHasFilterTensionsIn            NodeHasFilter = "tensions_in"
	NodeHasFilterVisibility            NodeHasFilter = "visibility"
	NodeHasFilterMode                  NodeHasFilter = "mode"
	NodeHasFilterRights                NodeHasFilter = "rights"
	NodeHasFilterIsArchived            NodeHasFilter = "isArchived"
	NodeHasFilterIsPersonal            NodeHasFilter = "isPersonal"
	NodeHasFilterUserCanJoin           NodeHasFilter = "userCanJoin"
	NodeHasFilterGuestCanCreateTension NodeHasFilter = "guestCanCreateTension"
	NodeHasFilterWatchers              NodeHasFilter = "watchers"
	NodeHasFilterChildren              NodeHasFilter = "children"
	NodeHasFilterLabels                NodeHasFilter = "labels"
	NodeHasFilterRoles                 NodeHasFilter = "roles"
	NodeHasFilterProjects              NodeHasFilter = "projects"
	NodeHasFilterPinned                NodeHasFilter = "pinned"
	NodeHasFilterRoleExt               NodeHasFilter = "role_ext"
	NodeHasFilterRoleType              NodeHasFilter = "role_type"
	NodeHasFilterColor                 NodeHasFilter = "color"
	NodeHasFilterFirstLink             NodeHasFilter = "first_link"
	NodeHasFilterContracts             NodeHasFilter = "contracts"
	NodeHasFilterEventsHistory         NodeHasFilter = "events_history"
)

var AllNodeHasFilter = []NodeHasFilter{
	NodeHasFilterCreatedBy,
	NodeHasFilterCreatedAt,
	NodeHasFilterUpdatedAt,
	NodeHasFilterNameid,
	NodeHasFilterRootnameid,
	NodeHasFilterSource,
	NodeHasFilterName,
	NodeHasFilterAbout,
	NodeHasFilterSkills,
	NodeHasFilterIsRoot,
	NodeHasFilterParent,
	NodeHasFilterType,
	NodeHasFilterTensionsOut,
	NodeHasFilterTensionsIn,
	NodeHasFilterVisibility,
	NodeHasFilterMode,
	NodeHasFilterRights,
	NodeHasFilterIsArchived,
	NodeHasFilterIsPersonal,
	NodeHasFilterUserCanJoin,
	NodeHasFilterGuestCanCreateTension,
	NodeHasFilterWatchers,
	NodeHasFilterChildren,
	NodeHasFilterLabels,
	NodeHasFilterRoles,
	NodeHasFilterProjects,
	NodeHasFilterPinned,
	NodeHasFilterRoleExt,
	NodeHasFilterRoleType,
	NodeHasFilterColor,
	NodeHasFilterFirstLink,
	NodeHasFilterContracts,
	NodeHasFilterEventsHistory,
}

func (e NodeHasFilter) IsValid() bool {
	switch e {
	case NodeHasFilterCreatedBy, NodeHasFilterCreatedAt, NodeHasFilterUpdatedAt, NodeHasFilterNameid, NodeHasFilterRootnameid, NodeHasFilterSource, NodeHasFilterName, NodeHasFilterAbout, NodeHasFilterSkills, NodeHasFilterIsRoot, NodeHasFilterParent, NodeHasFilterType, NodeHasFilterTensionsOut, NodeHasFilterTensionsIn, NodeHasFilterVisibility, NodeHasFilterMode, NodeHasFilterRights, NodeHasFilterIsArchived, NodeHasFilterIsPersonal, NodeHasFilterUserCanJoin, NodeHasFilterGuestCanCreateTension, NodeHasFilterWatchers, NodeHasFilterChildren, NodeHasFilterLabels, NodeHasFilterRoles, NodeHasFilterProjects, NodeHasFilterPinned, NodeHasFilterRoleExt, NodeHasFilterRoleType, NodeHasFilterColor, NodeHasFilterFirstLink, NodeHasFilterContracts, NodeHasFilterEventsHistory:
		return true
	}
	return false
}

func (e NodeHasFilter) String() string {
	return string(e)
}

func (e *NodeHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeHasFilter", str)
	}
	return nil
}

func (e NodeHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NodeMode string

const (
	NodeModeCoordinated NodeMode = "Coordinated"
	NodeModeAgile       NodeMode = "Agile"
)

var AllNodeMode = []NodeMode{
	NodeModeCoordinated,
	NodeModeAgile,
}

func (e NodeMode) IsValid() bool {
	switch e {
	case NodeModeCoordinated, NodeModeAgile:
		return true
	}
	return false
}

func (e NodeMode) String() string {
	return string(e)
}

func (e *NodeMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeMode", str)
	}
	return nil
}

func (e NodeMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NodeOrderable string

const (
	NodeOrderableCreatedAt  NodeOrderable = "createdAt"
	NodeOrderableUpdatedAt  NodeOrderable = "updatedAt"
	NodeOrderableNameid     NodeOrderable = "nameid"
	NodeOrderableRootnameid NodeOrderable = "rootnameid"
	NodeOrderableName       NodeOrderable = "name"
	NodeOrderableAbout      NodeOrderable = "about"
	NodeOrderableRights     NodeOrderable = "rights"
	NodeOrderableColor      NodeOrderable = "color"
)

var AllNodeOrderable = []NodeOrderable{
	NodeOrderableCreatedAt,
	NodeOrderableUpdatedAt,
	NodeOrderableNameid,
	NodeOrderableRootnameid,
	NodeOrderableName,
	NodeOrderableAbout,
	NodeOrderableRights,
	NodeOrderableColor,
}

func (e NodeOrderable) IsValid() bool {
	switch e {
	case NodeOrderableCreatedAt, NodeOrderableUpdatedAt, NodeOrderableNameid, NodeOrderableRootnameid, NodeOrderableName, NodeOrderableAbout, NodeOrderableRights, NodeOrderableColor:
		return true
	}
	return false
}

func (e NodeOrderable) String() string {
	return string(e)
}

func (e *NodeOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeOrderable", str)
	}
	return nil
}

func (e NodeOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NodeType string

const (
	NodeTypeCircle NodeType = "Circle"
	NodeTypeRole   NodeType = "Role"
)

var AllNodeType = []NodeType{
	NodeTypeCircle,
	NodeTypeRole,
}

func (e NodeType) IsValid() bool {
	switch e {
	case NodeTypeCircle, NodeTypeRole:
		return true
	}
	return false
}

func (e NodeType) String() string {
	return string(e)
}

func (e *NodeType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeType", str)
	}
	return nil
}

func (e NodeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NodeVisibility string

const (
	NodeVisibilityPublic  NodeVisibility = "Public"
	NodeVisibilityPrivate NodeVisibility = "Private"
	NodeVisibilitySecret  NodeVisibility = "Secret"
)

var AllNodeVisibility = []NodeVisibility{
	NodeVisibilityPublic,
	NodeVisibilityPrivate,
	NodeVisibilitySecret,
}

func (e NodeVisibility) IsValid() bool {
	switch e {
	case NodeVisibilityPublic, NodeVisibilityPrivate, NodeVisibilitySecret:
		return true
	}
	return false
}

func (e NodeVisibility) String() string {
	return string(e)
}

func (e *NodeVisibility) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeVisibility(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeVisibility", str)
	}
	return nil
}

func (e NodeVisibility) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NotifHasFilter string

const (
	NotifHasFilterCreatedBy NotifHasFilter = "createdBy"
	NotifHasFilterCreatedAt NotifHasFilter = "createdAt"
	NotifHasFilterUpdatedAt NotifHasFilter = "updatedAt"
	NotifHasFilterMessage   NotifHasFilter = "message"
	NotifHasFilterTension   NotifHasFilter = "tension_"
	NotifHasFilterContract  NotifHasFilter = "contract"
	NotifHasFilterLink      NotifHasFilter = "link"
)

var AllNotifHasFilter = []NotifHasFilter{
	NotifHasFilterCreatedBy,
	NotifHasFilterCreatedAt,
	NotifHasFilterUpdatedAt,
	NotifHasFilterMessage,
	NotifHasFilterTension,
	NotifHasFilterContract,
	NotifHasFilterLink,
}

func (e NotifHasFilter) IsValid() bool {
	switch e {
	case NotifHasFilterCreatedBy, NotifHasFilterCreatedAt, NotifHasFilterUpdatedAt, NotifHasFilterMessage, NotifHasFilterTension, NotifHasFilterContract, NotifHasFilterLink:
		return true
	}
	return false
}

func (e NotifHasFilter) String() string {
	return string(e)
}

func (e *NotifHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotifHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotifHasFilter", str)
	}
	return nil
}

func (e NotifHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NotifOrderable string

const (
	NotifOrderableCreatedAt NotifOrderable = "createdAt"
	NotifOrderableUpdatedAt NotifOrderable = "updatedAt"
	NotifOrderableMessage   NotifOrderable = "message"
	NotifOrderableLink      NotifOrderable = "link"
)

var AllNotifOrderable = []NotifOrderable{
	NotifOrderableCreatedAt,
	NotifOrderableUpdatedAt,
	NotifOrderableMessage,
	NotifOrderableLink,
}

func (e NotifOrderable) IsValid() bool {
	switch e {
	case NotifOrderableCreatedAt, NotifOrderableUpdatedAt, NotifOrderableMessage, NotifOrderableLink:
		return true
	}
	return false
}

func (e NotifOrderable) String() string {
	return string(e)
}

func (e *NotifOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotifOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotifOrderable", str)
	}
	return nil
}

func (e NotifOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PendingUserHasFilter string

const (
	PendingUserHasFilterUpdatedAt  PendingUserHasFilter = "updatedAt"
	PendingUserHasFilterUsername   PendingUserHasFilter = "username"
	PendingUserHasFilterPassword   PendingUserHasFilter = "password"
	PendingUserHasFilterEmail      PendingUserHasFilter = "email"
	PendingUserHasFilterEmailToken PendingUserHasFilter = "email_token"
	PendingUserHasFilterToken      PendingUserHasFilter = "token"
	PendingUserHasFilterContracts  PendingUserHasFilter = "contracts"
	PendingUserHasFilterSubscribe  PendingUserHasFilter = "subscribe"
)

var AllPendingUserHasFilter = []PendingUserHasFilter{
	PendingUserHasFilterUpdatedAt,
	PendingUserHasFilterUsername,
	PendingUserHasFilterPassword,
	PendingUserHasFilterEmail,
	PendingUserHasFilterEmailToken,
	PendingUserHasFilterToken,
	PendingUserHasFilterContracts,
	PendingUserHasFilterSubscribe,
}

func (e PendingUserHasFilter) IsValid() bool {
	switch e {
	case PendingUserHasFilterUpdatedAt, PendingUserHasFilterUsername, PendingUserHasFilterPassword, PendingUserHasFilterEmail, PendingUserHasFilterEmailToken, PendingUserHasFilterToken, PendingUserHasFilterContracts, PendingUserHasFilterSubscribe:
		return true
	}
	return false
}

func (e PendingUserHasFilter) String() string {
	return string(e)
}

func (e *PendingUserHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PendingUserHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PendingUserHasFilter", str)
	}
	return nil
}

func (e PendingUserHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PendingUserOrderable string

const (
	PendingUserOrderableUpdatedAt  PendingUserOrderable = "updatedAt"
	PendingUserOrderableUsername   PendingUserOrderable = "username"
	PendingUserOrderablePassword   PendingUserOrderable = "password"
	PendingUserOrderableEmail      PendingUserOrderable = "email"
	PendingUserOrderableEmailToken PendingUserOrderable = "email_token"
	PendingUserOrderableToken      PendingUserOrderable = "token"
)

var AllPendingUserOrderable = []PendingUserOrderable{
	PendingUserOrderableUpdatedAt,
	PendingUserOrderableUsername,
	PendingUserOrderablePassword,
	PendingUserOrderableEmail,
	PendingUserOrderableEmailToken,
	PendingUserOrderableToken,
}

func (e PendingUserOrderable) IsValid() bool {
	switch e {
	case PendingUserOrderableUpdatedAt, PendingUserOrderableUsername, PendingUserOrderablePassword, PendingUserOrderableEmail, PendingUserOrderableEmailToken, PendingUserOrderableToken:
		return true
	}
	return false
}

func (e PendingUserOrderable) String() string {
	return string(e)
}

func (e *PendingUserOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PendingUserOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PendingUserOrderable", str)
	}
	return nil
}

func (e PendingUserOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PostHasFilter string

const (
	PostHasFilterCreatedBy PostHasFilter = "createdBy"
	PostHasFilterCreatedAt PostHasFilter = "createdAt"
	PostHasFilterUpdatedAt PostHasFilter = "updatedAt"
	PostHasFilterMessage   PostHasFilter = "message"
)

var AllPostHasFilter = []PostHasFilter{
	PostHasFilterCreatedBy,
	PostHasFilterCreatedAt,
	PostHasFilterUpdatedAt,
	PostHasFilterMessage,
}

func (e PostHasFilter) IsValid() bool {
	switch e {
	case PostHasFilterCreatedBy, PostHasFilterCreatedAt, PostHasFilterUpdatedAt, PostHasFilterMessage:
		return true
	}
	return false
}

func (e PostHasFilter) String() string {
	return string(e)
}

func (e *PostHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PostHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PostHasFilter", str)
	}
	return nil
}

func (e PostHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PostOrderable string

const (
	PostOrderableCreatedAt PostOrderable = "createdAt"
	PostOrderableUpdatedAt PostOrderable = "updatedAt"
	PostOrderableMessage   PostOrderable = "message"
)

var AllPostOrderable = []PostOrderable{
	PostOrderableCreatedAt,
	PostOrderableUpdatedAt,
	PostOrderableMessage,
}

func (e PostOrderable) IsValid() bool {
	switch e {
	case PostOrderableCreatedAt, PostOrderableUpdatedAt, PostOrderableMessage:
		return true
	}
	return false
}

func (e PostOrderable) String() string {
	return string(e)
}

func (e *PostOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PostOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PostOrderable", str)
	}
	return nil
}

func (e PostOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProjectCardHasFilter string

const (
	ProjectCardHasFilterPos    ProjectCardHasFilter = "pos"
	ProjectCardHasFilterCard   ProjectCardHasFilter = "card"
	ProjectCardHasFilterPc     ProjectCardHasFilter = "pc"
	ProjectCardHasFilterValues ProjectCardHasFilter = "values"
)

var AllProjectCardHasFilter = []ProjectCardHasFilter{
	ProjectCardHasFilterPos,
	ProjectCardHasFilterCard,
	ProjectCardHasFilterPc,
	ProjectCardHasFilterValues,
}

func (e ProjectCardHasFilter) IsValid() bool {
	switch e {
	case ProjectCardHasFilterPos, ProjectCardHasFilterCard, ProjectCardHasFilterPc, ProjectCardHasFilterValues:
		return true
	}
	return false
}

func (e ProjectCardHasFilter) String() string {
	return string(e)
}

func (e *ProjectCardHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectCardHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectCardHasFilter", str)
	}
	return nil
}

func (e ProjectCardHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProjectCardOrderable string

const (
	ProjectCardOrderablePos ProjectCardOrderable = "pos"
)

var AllProjectCardOrderable = []ProjectCardOrderable{
	ProjectCardOrderablePos,
}

func (e ProjectCardOrderable) IsValid() bool {
	switch e {
	case ProjectCardOrderablePos:
		return true
	}
	return false
}

func (e ProjectCardOrderable) String() string {
	return string(e)
}

func (e *ProjectCardOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectCardOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectCardOrderable", str)
	}
	return nil
}

func (e ProjectCardOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProjectColumnHasFilter string

const (
	ProjectColumnHasFilterName        ProjectColumnHasFilter = "name"
	ProjectColumnHasFilterDescription ProjectColumnHasFilter = "description"
	ProjectColumnHasFilterColor       ProjectColumnHasFilter = "color"
	ProjectColumnHasFilterPos         ProjectColumnHasFilter = "pos"
	ProjectColumnHasFilterColType     ProjectColumnHasFilter = "col_type"
	ProjectColumnHasFilterCards       ProjectColumnHasFilter = "cards"
	ProjectColumnHasFilterProject     ProjectColumnHasFilter = "project"
	ProjectColumnHasFilterTensions    ProjectColumnHasFilter = "tensions"
)

var AllProjectColumnHasFilter = []ProjectColumnHasFilter{
	ProjectColumnHasFilterName,
	ProjectColumnHasFilterDescription,
	ProjectColumnHasFilterColor,
	ProjectColumnHasFilterPos,
	ProjectColumnHasFilterColType,
	ProjectColumnHasFilterCards,
	ProjectColumnHasFilterProject,
	ProjectColumnHasFilterTensions,
}

func (e ProjectColumnHasFilter) IsValid() bool {
	switch e {
	case ProjectColumnHasFilterName, ProjectColumnHasFilterDescription, ProjectColumnHasFilterColor, ProjectColumnHasFilterPos, ProjectColumnHasFilterColType, ProjectColumnHasFilterCards, ProjectColumnHasFilterProject, ProjectColumnHasFilterTensions:
		return true
	}
	return false
}

func (e ProjectColumnHasFilter) String() string {
	return string(e)
}

func (e *ProjectColumnHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectColumnHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectColumnHasFilter", str)
	}
	return nil
}

func (e ProjectColumnHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProjectColumnOrderable string

const (
	ProjectColumnOrderableName        ProjectColumnOrderable = "name"
	ProjectColumnOrderableDescription ProjectColumnOrderable = "description"
	ProjectColumnOrderableColor       ProjectColumnOrderable = "color"
	ProjectColumnOrderablePos         ProjectColumnOrderable = "pos"
)

var AllProjectColumnOrderable = []ProjectColumnOrderable{
	ProjectColumnOrderableName,
	ProjectColumnOrderableDescription,
	ProjectColumnOrderableColor,
	ProjectColumnOrderablePos,
}

func (e ProjectColumnOrderable) IsValid() bool {
	switch e {
	case ProjectColumnOrderableName, ProjectColumnOrderableDescription, ProjectColumnOrderableColor, ProjectColumnOrderablePos:
		return true
	}
	return false
}

func (e ProjectColumnOrderable) String() string {
	return string(e)
}

func (e *ProjectColumnOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectColumnOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectColumnOrderable", str)
	}
	return nil
}

func (e ProjectColumnOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProjectColumnType string

const (
	ProjectColumnTypeNormalColumn   ProjectColumnType = "NormalColumn"
	ProjectColumnTypeNoStatusColumn ProjectColumnType = "NoStatusColumn"
)

var AllProjectColumnType = []ProjectColumnType{
	ProjectColumnTypeNormalColumn,
	ProjectColumnTypeNoStatusColumn,
}

func (e ProjectColumnType) IsValid() bool {
	switch e {
	case ProjectColumnTypeNormalColumn, ProjectColumnTypeNoStatusColumn:
		return true
	}
	return false
}

func (e ProjectColumnType) String() string {
	return string(e)
}

func (e *ProjectColumnType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectColumnType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectColumnType", str)
	}
	return nil
}

func (e ProjectColumnType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProjectDraftHasFilter string

const (
	ProjectDraftHasFilterCreatedBy ProjectDraftHasFilter = "createdBy"
	ProjectDraftHasFilterCreatedAt ProjectDraftHasFilter = "createdAt"
	ProjectDraftHasFilterUpdatedAt ProjectDraftHasFilter = "updatedAt"
	ProjectDraftHasFilterMessage   ProjectDraftHasFilter = "message"
	ProjectDraftHasFilterTitle     ProjectDraftHasFilter = "title"
)

var AllProjectDraftHasFilter = []ProjectDraftHasFilter{
	ProjectDraftHasFilterCreatedBy,
	ProjectDraftHasFilterCreatedAt,
	ProjectDraftHasFilterUpdatedAt,
	ProjectDraftHasFilterMessage,
	ProjectDraftHasFilterTitle,
}

func (e ProjectDraftHasFilter) IsValid() bool {
	switch e {
	case ProjectDraftHasFilterCreatedBy, ProjectDraftHasFilterCreatedAt, ProjectDraftHasFilterUpdatedAt, ProjectDraftHasFilterMessage, ProjectDraftHasFilterTitle:
		return true
	}
	return false
}

func (e ProjectDraftHasFilter) String() string {
	return string(e)
}

func (e *ProjectDraftHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectDraftHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectDraftHasFilter", str)
	}
	return nil
}

func (e ProjectDraftHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProjectDraftOrderable string

const (
	ProjectDraftOrderableCreatedAt ProjectDraftOrderable = "createdAt"
	ProjectDraftOrderableUpdatedAt ProjectDraftOrderable = "updatedAt"
	ProjectDraftOrderableMessage   ProjectDraftOrderable = "message"
	ProjectDraftOrderableTitle     ProjectDraftOrderable = "title"
)

var AllProjectDraftOrderable = []ProjectDraftOrderable{
	ProjectDraftOrderableCreatedAt,
	ProjectDraftOrderableUpdatedAt,
	ProjectDraftOrderableMessage,
	ProjectDraftOrderableTitle,
}

func (e ProjectDraftOrderable) IsValid() bool {
	switch e {
	case ProjectDraftOrderableCreatedAt, ProjectDraftOrderableUpdatedAt, ProjectDraftOrderableMessage, ProjectDraftOrderableTitle:
		return true
	}
	return false
}

func (e ProjectDraftOrderable) String() string {
	return string(e)
}

func (e *ProjectDraftOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectDraftOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectDraftOrderable", str)
	}
	return nil
}

func (e ProjectDraftOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProjectFieldHasFilter string

const (
	ProjectFieldHasFilterFieldType ProjectFieldHasFilter = "field_type"
	ProjectFieldHasFilterIsVisible ProjectFieldHasFilter = "isVisible"
	ProjectFieldHasFilterValues    ProjectFieldHasFilter = "values"
)

var AllProjectFieldHasFilter = []ProjectFieldHasFilter{
	ProjectFieldHasFilterFieldType,
	ProjectFieldHasFilterIsVisible,
	ProjectFieldHasFilterValues,
}

func (e ProjectFieldHasFilter) IsValid() bool {
	switch e {
	case ProjectFieldHasFilterFieldType, ProjectFieldHasFilterIsVisible, ProjectFieldHasFilterValues:
		return true
	}
	return false
}

func (e ProjectFieldHasFilter) String() string {
	return string(e)
}

func (e *ProjectFieldHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectFieldHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectFieldHasFilter", str)
	}
	return nil
}

func (e ProjectFieldHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProjectFieldType string

const (
	ProjectFieldTypeInt          ProjectFieldType = "INT"
	ProjectFieldTypeString       ProjectFieldType = "STRING"
	ProjectFieldTypeDate         ProjectFieldType = "DATE"
	ProjectFieldTypeSingleSelect ProjectFieldType = "SINGLE_SELECT"
)

var AllProjectFieldType = []ProjectFieldType{
	ProjectFieldTypeInt,
	ProjectFieldTypeString,
	ProjectFieldTypeDate,
	ProjectFieldTypeSingleSelect,
}

func (e ProjectFieldType) IsValid() bool {
	switch e {
	case ProjectFieldTypeInt, ProjectFieldTypeString, ProjectFieldTypeDate, ProjectFieldTypeSingleSelect:
		return true
	}
	return false
}

func (e ProjectFieldType) String() string {
	return string(e)
}

func (e *ProjectFieldType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectFieldType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectFieldType", str)
	}
	return nil
}

func (e ProjectFieldType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProjectFieldValueHasFilter string

const (
	ProjectFieldValueHasFilterField ProjectFieldValueHasFilter = "field"
	ProjectFieldValueHasFilterValue ProjectFieldValueHasFilter = "value"
	ProjectFieldValueHasFilterPos   ProjectFieldValueHasFilter = "pos"
)

var AllProjectFieldValueHasFilter = []ProjectFieldValueHasFilter{
	ProjectFieldValueHasFilterField,
	ProjectFieldValueHasFilterValue,
	ProjectFieldValueHasFilterPos,
}

func (e ProjectFieldValueHasFilter) IsValid() bool {
	switch e {
	case ProjectFieldValueHasFilterField, ProjectFieldValueHasFilterValue, ProjectFieldValueHasFilterPos:
		return true
	}
	return false
}

func (e ProjectFieldValueHasFilter) String() string {
	return string(e)
}

func (e *ProjectFieldValueHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectFieldValueHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectFieldValueHasFilter", str)
	}
	return nil
}

func (e ProjectFieldValueHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProjectFieldValueOrderable string

const (
	ProjectFieldValueOrderableValue ProjectFieldValueOrderable = "value"
	ProjectFieldValueOrderablePos   ProjectFieldValueOrderable = "pos"
)

var AllProjectFieldValueOrderable = []ProjectFieldValueOrderable{
	ProjectFieldValueOrderableValue,
	ProjectFieldValueOrderablePos,
}

func (e ProjectFieldValueOrderable) IsValid() bool {
	switch e {
	case ProjectFieldValueOrderableValue, ProjectFieldValueOrderablePos:
		return true
	}
	return false
}

func (e ProjectFieldValueOrderable) String() string {
	return string(e)
}

func (e *ProjectFieldValueOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectFieldValueOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectFieldValueOrderable", str)
	}
	return nil
}

func (e ProjectFieldValueOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProjectHasFilter string

const (
	ProjectHasFilterCreatedBy    ProjectHasFilter = "createdBy"
	ProjectHasFilterCreatedAt    ProjectHasFilter = "createdAt"
	ProjectHasFilterUpdatedAt    ProjectHasFilter = "updatedAt"
	ProjectHasFilterRootnameid   ProjectHasFilter = "rootnameid"
	ProjectHasFilterParentnameid ProjectHasFilter = "parentnameid"
	ProjectHasFilterNameid       ProjectHasFilter = "nameid"
	ProjectHasFilterName         ProjectHasFilter = "name"
	ProjectHasFilterDescription  ProjectHasFilter = "description"
	ProjectHasFilterStatus       ProjectHasFilter = "status"
	ProjectHasFilterColumns      ProjectHasFilter = "columns"
	ProjectHasFilterFields       ProjectHasFilter = "fields"
	ProjectHasFilterLeaders      ProjectHasFilter = "leaders"
	ProjectHasFilterNodes        ProjectHasFilter = "nodes"
)

var AllProjectHasFilter = []ProjectHasFilter{
	ProjectHasFilterCreatedBy,
	ProjectHasFilterCreatedAt,
	ProjectHasFilterUpdatedAt,
	ProjectHasFilterRootnameid,
	ProjectHasFilterParentnameid,
	ProjectHasFilterNameid,
	ProjectHasFilterName,
	ProjectHasFilterDescription,
	ProjectHasFilterStatus,
	ProjectHasFilterColumns,
	ProjectHasFilterFields,
	ProjectHasFilterLeaders,
	ProjectHasFilterNodes,
}

func (e ProjectHasFilter) IsValid() bool {
	switch e {
	case ProjectHasFilterCreatedBy, ProjectHasFilterCreatedAt, ProjectHasFilterUpdatedAt, ProjectHasFilterRootnameid, ProjectHasFilterParentnameid, ProjectHasFilterNameid, ProjectHasFilterName, ProjectHasFilterDescription, ProjectHasFilterStatus, ProjectHasFilterColumns, ProjectHasFilterFields, ProjectHasFilterLeaders, ProjectHasFilterNodes:
		return true
	}
	return false
}

func (e ProjectHasFilter) String() string {
	return string(e)
}

func (e *ProjectHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectHasFilter", str)
	}
	return nil
}

func (e ProjectHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProjectOrderable string

const (
	ProjectOrderableCreatedAt    ProjectOrderable = "createdAt"
	ProjectOrderableUpdatedAt    ProjectOrderable = "updatedAt"
	ProjectOrderableRootnameid   ProjectOrderable = "rootnameid"
	ProjectOrderableParentnameid ProjectOrderable = "parentnameid"
	ProjectOrderableNameid       ProjectOrderable = "nameid"
	ProjectOrderableName         ProjectOrderable = "name"
	ProjectOrderableDescription  ProjectOrderable = "description"
)

var AllProjectOrderable = []ProjectOrderable{
	ProjectOrderableCreatedAt,
	ProjectOrderableUpdatedAt,
	ProjectOrderableRootnameid,
	ProjectOrderableParentnameid,
	ProjectOrderableNameid,
	ProjectOrderableName,
	ProjectOrderableDescription,
}

func (e ProjectOrderable) IsValid() bool {
	switch e {
	case ProjectOrderableCreatedAt, ProjectOrderableUpdatedAt, ProjectOrderableRootnameid, ProjectOrderableParentnameid, ProjectOrderableNameid, ProjectOrderableName, ProjectOrderableDescription:
		return true
	}
	return false
}

func (e ProjectOrderable) String() string {
	return string(e)
}

func (e *ProjectOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectOrderable", str)
	}
	return nil
}

func (e ProjectOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProjectStatus string

const (
	ProjectStatusOpen   ProjectStatus = "Open"
	ProjectStatusClosed ProjectStatus = "Closed"
)

var AllProjectStatus = []ProjectStatus{
	ProjectStatusOpen,
	ProjectStatusClosed,
}

func (e ProjectStatus) IsValid() bool {
	switch e {
	case ProjectStatusOpen, ProjectStatusClosed:
		return true
	}
	return false
}

func (e ProjectStatus) String() string {
	return string(e)
}

func (e *ProjectStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectStatus", str)
	}
	return nil
}

func (e ProjectStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ReactionHasFilter string

const (
	ReactionHasFilterReactionid ReactionHasFilter = "reactionid"
	ReactionHasFilterUser       ReactionHasFilter = "user"
	ReactionHasFilterComment    ReactionHasFilter = "comment"
	ReactionHasFilterType       ReactionHasFilter = "type_"
)

var AllReactionHasFilter = []ReactionHasFilter{
	ReactionHasFilterReactionid,
	ReactionHasFilterUser,
	ReactionHasFilterComment,
	ReactionHasFilterType,
}

func (e ReactionHasFilter) IsValid() bool {
	switch e {
	case ReactionHasFilterReactionid, ReactionHasFilterUser, ReactionHasFilterComment, ReactionHasFilterType:
		return true
	}
	return false
}

func (e ReactionHasFilter) String() string {
	return string(e)
}

func (e *ReactionHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReactionHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReactionHasFilter", str)
	}
	return nil
}

func (e ReactionHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ReactionOrderable string

const (
	ReactionOrderableReactionid ReactionOrderable = "reactionid"
	ReactionOrderableType       ReactionOrderable = "type_"
)

var AllReactionOrderable = []ReactionOrderable{
	ReactionOrderableReactionid,
	ReactionOrderableType,
}

func (e ReactionOrderable) IsValid() bool {
	switch e {
	case ReactionOrderableReactionid, ReactionOrderableType:
		return true
	}
	return false
}

func (e ReactionOrderable) String() string {
	return string(e)
}

func (e *ReactionOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReactionOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReactionOrderable", str)
	}
	return nil
}

func (e ReactionOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RoleExtHasFilter string

const (
	RoleExtHasFilterRootnameid RoleExtHasFilter = "rootnameid"
	RoleExtHasFilterName       RoleExtHasFilter = "name"
	RoleExtHasFilterAbout      RoleExtHasFilter = "about"
	RoleExtHasFilterRoleType   RoleExtHasFilter = "role_type"
	RoleExtHasFilterColor      RoleExtHasFilter = "color"
	RoleExtHasFilterMandate    RoleExtHasFilter = "mandate"
	RoleExtHasFilterRoles      RoleExtHasFilter = "roles"
	RoleExtHasFilterNodes      RoleExtHasFilter = "nodes"
)

var AllRoleExtHasFilter = []RoleExtHasFilter{
	RoleExtHasFilterRootnameid,
	RoleExtHasFilterName,
	RoleExtHasFilterAbout,
	RoleExtHasFilterRoleType,
	RoleExtHasFilterColor,
	RoleExtHasFilterMandate,
	RoleExtHasFilterRoles,
	RoleExtHasFilterNodes,
}

func (e RoleExtHasFilter) IsValid() bool {
	switch e {
	case RoleExtHasFilterRootnameid, RoleExtHasFilterName, RoleExtHasFilterAbout, RoleExtHasFilterRoleType, RoleExtHasFilterColor, RoleExtHasFilterMandate, RoleExtHasFilterRoles, RoleExtHasFilterNodes:
		return true
	}
	return false
}

func (e RoleExtHasFilter) String() string {
	return string(e)
}

func (e *RoleExtHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RoleExtHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RoleExtHasFilter", str)
	}
	return nil
}

func (e RoleExtHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RoleExtOrderable string

const (
	RoleExtOrderableRootnameid RoleExtOrderable = "rootnameid"
	RoleExtOrderableName       RoleExtOrderable = "name"
	RoleExtOrderableAbout      RoleExtOrderable = "about"
	RoleExtOrderableColor      RoleExtOrderable = "color"
)

var AllRoleExtOrderable = []RoleExtOrderable{
	RoleExtOrderableRootnameid,
	RoleExtOrderableName,
	RoleExtOrderableAbout,
	RoleExtOrderableColor,
}

func (e RoleExtOrderable) IsValid() bool {
	switch e {
	case RoleExtOrderableRootnameid, RoleExtOrderableName, RoleExtOrderableAbout, RoleExtOrderableColor:
		return true
	}
	return false
}

func (e RoleExtOrderable) String() string {
	return string(e)
}

func (e *RoleExtOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RoleExtOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RoleExtOrderable", str)
	}
	return nil
}

func (e RoleExtOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RoleType string

const (
	RoleTypeOwner       RoleType = "Owner"
	RoleTypeMember      RoleType = "Member"
	RoleTypeGuest       RoleType = "Guest"
	RoleTypeRetired     RoleType = "Retired"
	RoleTypePending     RoleType = "Pending"
	RoleTypeCoordinator RoleType = "Coordinator"
	RoleTypePeer        RoleType = "Peer"
	RoleTypeBot         RoleType = "Bot"
)

var AllRoleType = []RoleType{
	RoleTypeOwner,
	RoleTypeMember,
	RoleTypeGuest,
	RoleTypeRetired,
	RoleTypePending,
	RoleTypeCoordinator,
	RoleTypePeer,
	RoleTypeBot,
}

func (e RoleType) IsValid() bool {
	switch e {
	case RoleTypeOwner, RoleTypeMember, RoleTypeGuest, RoleTypeRetired, RoleTypePending, RoleTypeCoordinator, RoleTypePeer, RoleTypeBot:
		return true
	}
	return false
}

func (e RoleType) String() string {
	return string(e)
}

func (e *RoleType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RoleType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RoleType", str)
	}
	return nil
}

func (e RoleType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TensionAction string

const (
	TensionActionNewRole        TensionAction = "NewRole"
	TensionActionNewCircle      TensionAction = "NewCircle"
	TensionActionNewMd          TensionAction = "NewMd"
	TensionActionEditRole       TensionAction = "EditRole"
	TensionActionEditCircle     TensionAction = "EditCircle"
	TensionActionEditMd         TensionAction = "EditMd"
	TensionActionArchivedRole   TensionAction = "ArchivedRole"
	TensionActionArchivedCircle TensionAction = "ArchivedCircle"
	TensionActionArchivedMd     TensionAction = "ArchivedMd"
)

var AllTensionAction = []TensionAction{
	TensionActionNewRole,
	TensionActionNewCircle,
	TensionActionNewMd,
	TensionActionEditRole,
	TensionActionEditCircle,
	TensionActionEditMd,
	TensionActionArchivedRole,
	TensionActionArchivedCircle,
	TensionActionArchivedMd,
}

func (e TensionAction) IsValid() bool {
	switch e {
	case TensionActionNewRole, TensionActionNewCircle, TensionActionNewMd, TensionActionEditRole, TensionActionEditCircle, TensionActionEditMd, TensionActionArchivedRole, TensionActionArchivedCircle, TensionActionArchivedMd:
		return true
	}
	return false
}

func (e TensionAction) String() string {
	return string(e)
}

func (e *TensionAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TensionAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TensionAction", str)
	}
	return nil
}

func (e TensionAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TensionEvent string

const (
	TensionEventCreated         TensionEvent = "Created"
	TensionEventReopened        TensionEvent = "Reopened"
	TensionEventClosed          TensionEvent = "Closed"
	TensionEventTitleUpdated    TensionEvent = "TitleUpdated"
	TensionEventTypeUpdated     TensionEvent = "TypeUpdated"
	TensionEventCommentPushed   TensionEvent = "CommentPushed"
	TensionEventAssigneeAdded   TensionEvent = "AssigneeAdded"
	TensionEventAssigneeRemoved TensionEvent = "AssigneeRemoved"
	TensionEventLabelAdded      TensionEvent = "LabelAdded"
	TensionEventLabelRemoved    TensionEvent = "LabelRemoved"
	TensionEventBlobCreated     TensionEvent = "BlobCreated"
	TensionEventBlobCommitted   TensionEvent = "BlobCommitted"
	TensionEventMentioned       TensionEvent = "Mentioned"
	TensionEventPinned          TensionEvent = "Pinned"
	TensionEventUnpinned        TensionEvent = "Unpinned"
	TensionEventBlobPushed      TensionEvent = "BlobPushed"
	TensionEventBlobArchived    TensionEvent = "BlobArchived"
	TensionEventBlobUnarchived  TensionEvent = "BlobUnarchived"
	TensionEventUserJoined      TensionEvent = "UserJoined"
	TensionEventUserLeft        TensionEvent = "UserLeft"
	TensionEventMemberLinked    TensionEvent = "MemberLinked"
	TensionEventMemberUnlinked  TensionEvent = "MemberUnlinked"
	TensionEventAuthority       TensionEvent = "Authority"
	TensionEventVisibility      TensionEvent = "Visibility"
	TensionEventMoved           TensionEvent = "Moved"
)

var AllTensionEvent = []TensionEvent{
	TensionEventCreated,
	TensionEventReopened,
	TensionEventClosed,
	TensionEventTitleUpdated,
	TensionEventTypeUpdated,
	TensionEventCommentPushed,
	TensionEventAssigneeAdded,
	TensionEventAssigneeRemoved,
	TensionEventLabelAdded,
	TensionEventLabelRemoved,
	TensionEventBlobCreated,
	TensionEventBlobCommitted,
	TensionEventMentioned,
	TensionEventPinned,
	TensionEventUnpinned,
	TensionEventBlobPushed,
	TensionEventBlobArchived,
	TensionEventBlobUnarchived,
	TensionEventUserJoined,
	TensionEventUserLeft,
	TensionEventMemberLinked,
	TensionEventMemberUnlinked,
	TensionEventAuthority,
	TensionEventVisibility,
	TensionEventMoved,
}

func (e TensionEvent) IsValid() bool {
	switch e {
	case TensionEventCreated, TensionEventReopened, TensionEventClosed, TensionEventTitleUpdated, TensionEventTypeUpdated, TensionEventCommentPushed, TensionEventAssigneeAdded, TensionEventAssigneeRemoved, TensionEventLabelAdded, TensionEventLabelRemoved, TensionEventBlobCreated, TensionEventBlobCommitted, TensionEventMentioned, TensionEventPinned, TensionEventUnpinned, TensionEventBlobPushed, TensionEventBlobArchived, TensionEventBlobUnarchived, TensionEventUserJoined, TensionEventUserLeft, TensionEventMemberLinked, TensionEventMemberUnlinked, TensionEventAuthority, TensionEventVisibility, TensionEventMoved:
		return true
	}
	return false
}

func (e TensionEvent) String() string {
	return string(e)
}

func (e *TensionEvent) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TensionEvent(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TensionEvent", str)
	}
	return nil
}

func (e TensionEvent) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TensionHasFilter string

const (
	TensionHasFilterCreatedBy       TensionHasFilter = "createdBy"
	TensionHasFilterCreatedAt       TensionHasFilter = "createdAt"
	TensionHasFilterUpdatedAt       TensionHasFilter = "updatedAt"
	TensionHasFilterMessage         TensionHasFilter = "message"
	TensionHasFilterEmitter         TensionHasFilter = "emitter"
	TensionHasFilterEmitterid       TensionHasFilter = "emitterid"
	TensionHasFilterReceiver        TensionHasFilter = "receiver"
	TensionHasFilterReceiverid      TensionHasFilter = "receiverid"
	TensionHasFilterTitle           TensionHasFilter = "title"
	TensionHasFilterType            TensionHasFilter = "type_"
	TensionHasFilterStatus          TensionHasFilter = "status"
	TensionHasFilterAction          TensionHasFilter = "action"
	TensionHasFilterAssignees       TensionHasFilter = "assignees"
	TensionHasFilterLabels          TensionHasFilter = "labels"
	TensionHasFilterComments        TensionHasFilter = "comments"
	TensionHasFilterBlobs           TensionHasFilter = "blobs"
	TensionHasFilterHistory         TensionHasFilter = "history"
	TensionHasFilterMentions        TensionHasFilter = "mentions"
	TensionHasFilterContracts       TensionHasFilter = "contracts"
	TensionHasFilterSubscribers     TensionHasFilter = "subscribers"
	TensionHasFilterProjectStatuses TensionHasFilter = "project_statuses"
	TensionHasFilterNComments       TensionHasFilter = "n_comments"
)

var AllTensionHasFilter = []TensionHasFilter{
	TensionHasFilterCreatedBy,
	TensionHasFilterCreatedAt,
	TensionHasFilterUpdatedAt,
	TensionHasFilterMessage,
	TensionHasFilterEmitter,
	TensionHasFilterEmitterid,
	TensionHasFilterReceiver,
	TensionHasFilterReceiverid,
	TensionHasFilterTitle,
	TensionHasFilterType,
	TensionHasFilterStatus,
	TensionHasFilterAction,
	TensionHasFilterAssignees,
	TensionHasFilterLabels,
	TensionHasFilterComments,
	TensionHasFilterBlobs,
	TensionHasFilterHistory,
	TensionHasFilterMentions,
	TensionHasFilterContracts,
	TensionHasFilterSubscribers,
	TensionHasFilterProjectStatuses,
	TensionHasFilterNComments,
}

func (e TensionHasFilter) IsValid() bool {
	switch e {
	case TensionHasFilterCreatedBy, TensionHasFilterCreatedAt, TensionHasFilterUpdatedAt, TensionHasFilterMessage, TensionHasFilterEmitter, TensionHasFilterEmitterid, TensionHasFilterReceiver, TensionHasFilterReceiverid, TensionHasFilterTitle, TensionHasFilterType, TensionHasFilterStatus, TensionHasFilterAction, TensionHasFilterAssignees, TensionHasFilterLabels, TensionHasFilterComments, TensionHasFilterBlobs, TensionHasFilterHistory, TensionHasFilterMentions, TensionHasFilterContracts, TensionHasFilterSubscribers, TensionHasFilterProjectStatuses, TensionHasFilterNComments:
		return true
	}
	return false
}

func (e TensionHasFilter) String() string {
	return string(e)
}

func (e *TensionHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TensionHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TensionHasFilter", str)
	}
	return nil
}

func (e TensionHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TensionOrderable string

const (
	TensionOrderableCreatedAt  TensionOrderable = "createdAt"
	TensionOrderableUpdatedAt  TensionOrderable = "updatedAt"
	TensionOrderableMessage    TensionOrderable = "message"
	TensionOrderableEmitterid  TensionOrderable = "emitterid"
	TensionOrderableReceiverid TensionOrderable = "receiverid"
	TensionOrderableTitle      TensionOrderable = "title"
	TensionOrderableNComments  TensionOrderable = "n_comments"
)

var AllTensionOrderable = []TensionOrderable{
	TensionOrderableCreatedAt,
	TensionOrderableUpdatedAt,
	TensionOrderableMessage,
	TensionOrderableEmitterid,
	TensionOrderableReceiverid,
	TensionOrderableTitle,
	TensionOrderableNComments,
}

func (e TensionOrderable) IsValid() bool {
	switch e {
	case TensionOrderableCreatedAt, TensionOrderableUpdatedAt, TensionOrderableMessage, TensionOrderableEmitterid, TensionOrderableReceiverid, TensionOrderableTitle, TensionOrderableNComments:
		return true
	}
	return false
}

func (e TensionOrderable) String() string {
	return string(e)
}

func (e *TensionOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TensionOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TensionOrderable", str)
	}
	return nil
}

func (e TensionOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TensionStatus string

const (
	TensionStatusOpen   TensionStatus = "Open"
	TensionStatusClosed TensionStatus = "Closed"
)

var AllTensionStatus = []TensionStatus{
	TensionStatusOpen,
	TensionStatusClosed,
}

func (e TensionStatus) IsValid() bool {
	switch e {
	case TensionStatusOpen, TensionStatusClosed:
		return true
	}
	return false
}

func (e TensionStatus) String() string {
	return string(e)
}

func (e *TensionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TensionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TensionStatus", str)
	}
	return nil
}

func (e TensionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TensionType string

const (
	TensionTypeOperational  TensionType = "Operational"
	TensionTypeGovernance   TensionType = "Governance"
	TensionTypeHelp         TensionType = "Help"
	TensionTypeAlert        TensionType = "Alert"
	TensionTypeAnnouncement TensionType = "Announcement"
)

var AllTensionType = []TensionType{
	TensionTypeOperational,
	TensionTypeGovernance,
	TensionTypeHelp,
	TensionTypeAlert,
	TensionTypeAnnouncement,
}

func (e TensionType) IsValid() bool {
	switch e {
	case TensionTypeOperational, TensionTypeGovernance, TensionTypeHelp, TensionTypeAlert, TensionTypeAnnouncement:
		return true
	}
	return false
}

func (e TensionType) String() string {
	return string(e)
}

func (e *TensionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TensionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TensionType", str)
	}
	return nil
}

func (e TensionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserEventHasFilter string

const (
	UserEventHasFilterCreatedAt UserEventHasFilter = "createdAt"
	UserEventHasFilterIsRead    UserEventHasFilter = "isRead"
	UserEventHasFilterUser      UserEventHasFilter = "user"
	UserEventHasFilterEvent     UserEventHasFilter = "event"
)

var AllUserEventHasFilter = []UserEventHasFilter{
	UserEventHasFilterCreatedAt,
	UserEventHasFilterIsRead,
	UserEventHasFilterUser,
	UserEventHasFilterEvent,
}

func (e UserEventHasFilter) IsValid() bool {
	switch e {
	case UserEventHasFilterCreatedAt, UserEventHasFilterIsRead, UserEventHasFilterUser, UserEventHasFilterEvent:
		return true
	}
	return false
}

func (e UserEventHasFilter) String() string {
	return string(e)
}

func (e *UserEventHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserEventHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserEventHasFilter", str)
	}
	return nil
}

func (e UserEventHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserEventOrderable string

const (
	UserEventOrderableCreatedAt UserEventOrderable = "createdAt"
)

var AllUserEventOrderable = []UserEventOrderable{
	UserEventOrderableCreatedAt,
}

func (e UserEventOrderable) IsValid() bool {
	switch e {
	case UserEventOrderableCreatedAt:
		return true
	}
	return false
}

func (e UserEventOrderable) String() string {
	return string(e)
}

func (e *UserEventOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserEventOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserEventOrderable", str)
	}
	return nil
}

func (e UserEventOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserHasFilter string

const (
	UserHasFilterCreatedAt        UserHasFilter = "createdAt"
	UserHasFilterLastAck          UserHasFilter = "lastAck"
	UserHasFilterUsername         UserHasFilter = "username"
	UserHasFilterName             UserHasFilter = "name"
	UserHasFilterEmail            UserHasFilter = "email"
	UserHasFilterPassword         UserHasFilter = "password"
	UserHasFilterBio              UserHasFilter = "bio"
	UserHasFilterLocation         UserHasFilter = "location"
	UserHasFilterUtc              UserHasFilter = "utc"
	UserHasFilterLinks            UserHasFilter = "links"
	UserHasFilterSkills           UserHasFilter = "skills"
	UserHasFilterNotifyByEmail    UserHasFilter = "notifyByEmail"
	UserHasFilterLang             UserHasFilter = "lang"
	UserHasFilterSubscriptions    UserHasFilter = "subscriptions"
	UserHasFilterWatching         UserHasFilter = "watching"
	UserHasFilterRights           UserHasFilter = "rights"
	UserHasFilterRoles            UserHasFilter = "roles"
	UserHasFilterTensionsCreated  UserHasFilter = "tensions_created"
	UserHasFilterTensionsAssigned UserHasFilter = "tensions_assigned"
	UserHasFilterContracts        UserHasFilter = "contracts"
	UserHasFilterReactions        UserHasFilter = "reactions"
	UserHasFilterEvents           UserHasFilter = "events"
	UserHasFilterMarkAllAsRead    UserHasFilter = "markAllAsRead"
	UserHasFilterEventCount       UserHasFilter = "event_count"
)

var AllUserHasFilter = []UserHasFilter{
	UserHasFilterCreatedAt,
	UserHasFilterLastAck,
	UserHasFilterUsername,
	UserHasFilterName,
	UserHasFilterEmail,
	UserHasFilterPassword,
	UserHasFilterBio,
	UserHasFilterLocation,
	UserHasFilterUtc,
	UserHasFilterLinks,
	UserHasFilterSkills,
	UserHasFilterNotifyByEmail,
	UserHasFilterLang,
	UserHasFilterSubscriptions,
	UserHasFilterWatching,
	UserHasFilterRights,
	UserHasFilterRoles,
	UserHasFilterTensionsCreated,
	UserHasFilterTensionsAssigned,
	UserHasFilterContracts,
	UserHasFilterReactions,
	UserHasFilterEvents,
	UserHasFilterMarkAllAsRead,
	UserHasFilterEventCount,
}

func (e UserHasFilter) IsValid() bool {
	switch e {
	case UserHasFilterCreatedAt, UserHasFilterLastAck, UserHasFilterUsername, UserHasFilterName, UserHasFilterEmail, UserHasFilterPassword, UserHasFilterBio, UserHasFilterLocation, UserHasFilterUtc, UserHasFilterLinks, UserHasFilterSkills, UserHasFilterNotifyByEmail, UserHasFilterLang, UserHasFilterSubscriptions, UserHasFilterWatching, UserHasFilterRights, UserHasFilterRoles, UserHasFilterTensionsCreated, UserHasFilterTensionsAssigned, UserHasFilterContracts, UserHasFilterReactions, UserHasFilterEvents, UserHasFilterMarkAllAsRead, UserHasFilterEventCount:
		return true
	}
	return false
}

func (e UserHasFilter) String() string {
	return string(e)
}

func (e *UserHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserHasFilter", str)
	}
	return nil
}

func (e UserHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserOrderable string

const (
	UserOrderableCreatedAt     UserOrderable = "createdAt"
	UserOrderableLastAck       UserOrderable = "lastAck"
	UserOrderableUsername      UserOrderable = "username"
	UserOrderableName          UserOrderable = "name"
	UserOrderableEmail         UserOrderable = "email"
	UserOrderablePassword      UserOrderable = "password"
	UserOrderableBio           UserOrderable = "bio"
	UserOrderableLocation      UserOrderable = "location"
	UserOrderableUtc           UserOrderable = "utc"
	UserOrderableMarkAllAsRead UserOrderable = "markAllAsRead"
)

var AllUserOrderable = []UserOrderable{
	UserOrderableCreatedAt,
	UserOrderableLastAck,
	UserOrderableUsername,
	UserOrderableName,
	UserOrderableEmail,
	UserOrderablePassword,
	UserOrderableBio,
	UserOrderableLocation,
	UserOrderableUtc,
	UserOrderableMarkAllAsRead,
}

func (e UserOrderable) IsValid() bool {
	switch e {
	case UserOrderableCreatedAt, UserOrderableLastAck, UserOrderableUsername, UserOrderableName, UserOrderableEmail, UserOrderablePassword, UserOrderableBio, UserOrderableLocation, UserOrderableUtc, UserOrderableMarkAllAsRead:
		return true
	}
	return false
}

func (e UserOrderable) String() string {
	return string(e)
}

func (e *UserOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserOrderable", str)
	}
	return nil
}

func (e UserOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserRightsHasFilter string

const (
	UserRightsHasFilterType                  UserRightsHasFilter = "type_"
	UserRightsHasFilterCanLogin              UserRightsHasFilter = "canLogin"
	UserRightsHasFilterCanCreateRoot         UserRightsHasFilter = "canCreateRoot"
	UserRightsHasFilterMaxPublicOrga         UserRightsHasFilter = "maxPublicOrga"
	UserRightsHasFilterMaxPrivateOrga        UserRightsHasFilter = "maxPrivateOrga"
	UserRightsHasFilterHasEmailNotifications UserRightsHasFilter = "hasEmailNotifications"
)

var AllUserRightsHasFilter = []UserRightsHasFilter{
	UserRightsHasFilterType,
	UserRightsHasFilterCanLogin,
	UserRightsHasFilterCanCreateRoot,
	UserRightsHasFilterMaxPublicOrga,
	UserRightsHasFilterMaxPrivateOrga,
	UserRightsHasFilterHasEmailNotifications,
}

func (e UserRightsHasFilter) IsValid() bool {
	switch e {
	case UserRightsHasFilterType, UserRightsHasFilterCanLogin, UserRightsHasFilterCanCreateRoot, UserRightsHasFilterMaxPublicOrga, UserRightsHasFilterMaxPrivateOrga, UserRightsHasFilterHasEmailNotifications:
		return true
	}
	return false
}

func (e UserRightsHasFilter) String() string {
	return string(e)
}

func (e *UserRightsHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserRightsHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserRightsHasFilter", str)
	}
	return nil
}

func (e UserRightsHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserRightsOrderable string

const (
	UserRightsOrderableMaxPublicOrga  UserRightsOrderable = "maxPublicOrga"
	UserRightsOrderableMaxPrivateOrga UserRightsOrderable = "maxPrivateOrga"
)

var AllUserRightsOrderable = []UserRightsOrderable{
	UserRightsOrderableMaxPublicOrga,
	UserRightsOrderableMaxPrivateOrga,
}

func (e UserRightsOrderable) IsValid() bool {
	switch e {
	case UserRightsOrderableMaxPublicOrga, UserRightsOrderableMaxPrivateOrga:
		return true
	}
	return false
}

func (e UserRightsOrderable) String() string {
	return string(e)
}

func (e *UserRightsOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserRightsOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserRightsOrderable", str)
	}
	return nil
}

func (e UserRightsOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserType string

const (
	UserTypeRegular UserType = "Regular"
	UserTypePro     UserType = "Pro"
	UserTypeRoot    UserType = "Root"
)

var AllUserType = []UserType{
	UserTypeRegular,
	UserTypePro,
	UserTypeRoot,
}

func (e UserType) IsValid() bool {
	switch e {
	case UserTypeRegular, UserTypePro, UserTypeRoot:
		return true
	}
	return false
}

func (e UserType) String() string {
	return string(e)
}

func (e *UserType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserType", str)
	}
	return nil
}

func (e UserType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VoteHasFilter string

const (
	VoteHasFilterCreatedBy VoteHasFilter = "createdBy"
	VoteHasFilterCreatedAt VoteHasFilter = "createdAt"
	VoteHasFilterUpdatedAt VoteHasFilter = "updatedAt"
	VoteHasFilterMessage   VoteHasFilter = "message"
	VoteHasFilterVoteid    VoteHasFilter = "voteid"
	VoteHasFilterContract  VoteHasFilter = "contract"
	VoteHasFilterNode      VoteHasFilter = "node"
	VoteHasFilterData      VoteHasFilter = "data"
)

var AllVoteHasFilter = []VoteHasFilter{
	VoteHasFilterCreatedBy,
	VoteHasFilterCreatedAt,
	VoteHasFilterUpdatedAt,
	VoteHasFilterMessage,
	VoteHasFilterVoteid,
	VoteHasFilterContract,
	VoteHasFilterNode,
	VoteHasFilterData,
}

func (e VoteHasFilter) IsValid() bool {
	switch e {
	case VoteHasFilterCreatedBy, VoteHasFilterCreatedAt, VoteHasFilterUpdatedAt, VoteHasFilterMessage, VoteHasFilterVoteid, VoteHasFilterContract, VoteHasFilterNode, VoteHasFilterData:
		return true
	}
	return false
}

func (e VoteHasFilter) String() string {
	return string(e)
}

func (e *VoteHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VoteHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VoteHasFilter", str)
	}
	return nil
}

func (e VoteHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VoteOrderable string

const (
	VoteOrderableCreatedAt VoteOrderable = "createdAt"
	VoteOrderableUpdatedAt VoteOrderable = "updatedAt"
	VoteOrderableMessage   VoteOrderable = "message"
	VoteOrderableVoteid    VoteOrderable = "voteid"
)

var AllVoteOrderable = []VoteOrderable{
	VoteOrderableCreatedAt,
	VoteOrderableUpdatedAt,
	VoteOrderableMessage,
	VoteOrderableVoteid,
}

func (e VoteOrderable) IsValid() bool {
	switch e {
	case VoteOrderableCreatedAt, VoteOrderableUpdatedAt, VoteOrderableMessage, VoteOrderableVoteid:
		return true
	}
	return false
}

func (e VoteOrderable) String() string {
	return string(e)
}

func (e *VoteOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VoteOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VoteOrderable", str)
	}
	return nil
}

func (e VoteOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
