// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fractale/fractal6.go/graph/model"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
	Auth                     func(ctx context.Context, obj interface{}, next graphql.Resolver, password *model.AuthRule, query *model.AuthRule, add *model.AuthRule, update *model.AuthRule, delete *model.AuthRule) (res interface{}, err error)
	CacheControl             func(ctx context.Context, obj interface{}, next graphql.Resolver, maxAge int) (res interface{}, err error)
	Cascade                  func(ctx context.Context, obj interface{}, next graphql.Resolver, fields []*string) (res interface{}, err error)
	Custom                   func(ctx context.Context, obj interface{}, next graphql.Resolver, http *model.CustomHTTP, dql *string) (res interface{}, err error)
	Dgraph                   func(ctx context.Context, obj interface{}, next graphql.Resolver, typeArg *string, pred *string) (res interface{}, err error)
	Generate                 func(ctx context.Context, obj interface{}, next graphql.Resolver, query *model.GenerateQueryParams, mutation *model.GenerateMutationParams, subscription *bool) (res interface{}, err error)
	HasInverse               func(ctx context.Context, obj interface{}, next graphql.Resolver, field string) (res interface{}, err error)
	Hidden                   func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addComment          func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addCommentInput     func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addContract         func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addContractInput    func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addLabel            func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addLabelInput       func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addProject          func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addProjectInput     func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addReaction         func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addReactionInput    func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addRoleExt          func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addRoleExtInput     func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addTension          func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addTensionInput     func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addUser             func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addUserInput        func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addVote             func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addVoteInput        func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteComment       func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteCommentInput  func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteContract      func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteContractInput func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteLabel         func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteLabelInput    func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteProject       func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteProjectInput  func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteReaction      func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteReactionInput func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteRoleExt       func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteRoleExtInput  func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteTension       func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteTensionInput  func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteUser          func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteUserInput     func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteVote          func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteVoteInput     func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_getCommentInput     func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_getContractInput    func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_getLabelInput       func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_getProjectInput     func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_getReactionInput    func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_getRoleExtInput     func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_getTensionInput     func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_getUserInput        func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_getVoteInput        func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_queryCommentInput   func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_queryContractInput  func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_queryLabelInput     func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_queryProjectInput   func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_queryReactionInput  func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_queryRoleExtInput   func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_queryTensionInput   func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_queryUserInput      func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_queryVoteInput      func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateComment       func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateCommentInput  func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateContract      func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateContractInput func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateLabel         func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateLabelInput    func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateProject       func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateProjectInput  func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateReaction      func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateReactionInput func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateRoleExt       func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateRoleExtInput  func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateTension       func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateTensionInput  func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateUser          func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateUserInput     func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateVote          func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateVoteInput     func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Id                       func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	IsContractValidator      func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Lambda                   func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	LambdaOnMutate           func(ctx context.Context, obj interface{}, next graphql.Resolver, add *bool, update *bool, delete *bool) (res interface{}, err error)
	Meta                     func(ctx context.Context, obj interface{}, next graphql.Resolver, f string, k *string) (res interface{}, err error)
	Private                  func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Remote                   func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	RemoteResponse           func(ctx context.Context, obj interface{}, next graphql.Resolver, name *string) (res interface{}, err error)
	Search                   func(ctx context.Context, obj interface{}, next graphql.Resolver, by []model.DgraphIndex) (res interface{}, err error)
	Secret                   func(ctx context.Context, obj interface{}, next graphql.Resolver, field string, pred *string) (res interface{}, err error)
	W_add                    func(ctx context.Context, obj interface{}, next graphql.Resolver, a string) (res interface{}, err error)
	W_alter                  func(ctx context.Context, obj interface{}, next graphql.Resolver, a string) (res interface{}, err error)
	W_meta_patch             func(ctx context.Context, obj interface{}, next graphql.Resolver, f string, k *string) (res interface{}, err error)
	W_patch                  func(ctx context.Context, obj interface{}, next graphql.Resolver, a string) (res interface{}, err error)
	W_remove                 func(ctx context.Context, obj interface{}, next graphql.Resolver, a string) (res interface{}, err error)
	W_set                    func(ctx context.Context, obj interface{}, next graphql.Resolver, a string) (res interface{}, err error)
	WithSubscription         func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	X_add                    func(ctx context.Context, obj interface{}, next graphql.Resolver, r *string, f *string, e []model.TensionEvent, n *int) (res interface{}, err error)
	X_alter                  func(ctx context.Context, obj interface{}, next graphql.Resolver, r *string, f *string, e []model.TensionEvent, n *int) (res interface{}, err error)
	X_patch                  func(ctx context.Context, obj interface{}, next graphql.Resolver, r *string, f *string, e []model.TensionEvent, n *int) (res interface{}, err error)
	X_patch_ro               func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	X_remove                 func(ctx context.Context, obj interface{}, next graphql.Resolver, r *string, f *string, e []model.TensionEvent, n *int) (res interface{}, err error)
	X_ro                     func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	X_set                    func(ctx context.Context, obj interface{}, next graphql.Resolver, r *string, f *string, e []model.TensionEvent, n *int) (res interface{}, err error)
}

type ComplexityRoot struct {
	AddBlobPayload struct {
		Blob    func(childComplexity int, filter *model.BlobFilter, order *model.BlobOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	AddCommentPayload struct {
		Comment func(childComplexity int, filter *model.CommentFilter, order *model.CommentOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	AddContractPayload struct {
		Contract func(childComplexity int, filter *model.ContractFilter, order *model.ContractOrder, first *int, offset *int) int
		NumUids  func(childComplexity int) int
	}

	AddEventCountPayload struct {
		EventCount func(childComplexity int, filter *model.EventCountFilter, order *model.EventCountOrder, first *int, offset *int) int
		NumUids    func(childComplexity int) int
	}

	AddEventFragmentPayload struct {
		EventFragment func(childComplexity int, filter *model.EventFragmentFilter, order *model.EventFragmentOrder, first *int, offset *int) int
		NumUids       func(childComplexity int) int
	}

	AddEventPayload struct {
		Event   func(childComplexity int, filter *model.EventFilter, order *model.EventOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	AddLabelPayload struct {
		Label   func(childComplexity int, filter *model.LabelFilter, order *model.LabelOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	AddMandatePayload struct {
		Mandate func(childComplexity int, filter *model.MandateFilter, order *model.MandateOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	AddNodeFragmentPayload struct {
		NodeFragment func(childComplexity int, filter *model.NodeFragmentFilter, order *model.NodeFragmentOrder, first *int, offset *int) int
		NumUids      func(childComplexity int) int
	}

	AddNodePayload struct {
		Node    func(childComplexity int, filter *model.NodeFilter, order *model.NodeOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	AddNotifPayload struct {
		Notif   func(childComplexity int, filter *model.NotifFilter, order *model.NotifOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	AddPendingUserPayload struct {
		NumUids     func(childComplexity int) int
		PendingUser func(childComplexity int, filter *model.PendingUserFilter, order *model.PendingUserOrder, first *int, offset *int) int
	}

	AddProjectCardPayload struct {
		NumUids     func(childComplexity int) int
		ProjectCard func(childComplexity int, filter *model.ProjectCardFilter, order *model.ProjectCardOrder, first *int, offset *int) int
	}

	AddProjectColumnPayload struct {
		NumUids       func(childComplexity int) int
		ProjectColumn func(childComplexity int, filter *model.ProjectColumnFilter, order *model.ProjectColumnOrder, first *int, offset *int) int
	}

	AddProjectDraftPayload struct {
		NumUids      func(childComplexity int) int
		ProjectDraft func(childComplexity int, filter *model.ProjectDraftFilter, order *model.ProjectDraftOrder, first *int, offset *int) int
	}

	AddProjectFieldPayload struct {
		NumUids      func(childComplexity int) int
		ProjectField func(childComplexity int, filter *model.ProjectFieldFilter, first *int, offset *int) int
	}

	AddProjectFieldValuePayload struct {
		NumUids           func(childComplexity int) int
		ProjectFieldValue func(childComplexity int, filter *model.ProjectFieldValueFilter, order *model.ProjectFieldValueOrder, first *int, offset *int) int
	}

	AddProjectPayload struct {
		NumUids func(childComplexity int) int
		Project func(childComplexity int, filter *model.ProjectFilter, order *model.ProjectOrder, first *int, offset *int) int
	}

	AddReactionPayload struct {
		NumUids  func(childComplexity int) int
		Reaction func(childComplexity int, filter *model.ReactionFilter, order *model.ReactionOrder, first *int, offset *int) int
	}

	AddRoleExtPayload struct {
		NumUids func(childComplexity int) int
		RoleExt func(childComplexity int, filter *model.RoleExtFilter, order *model.RoleExtOrder, first *int, offset *int) int
	}

	AddTensionPayload struct {
		NumUids func(childComplexity int) int
		Tension func(childComplexity int, filter *model.TensionFilter, order *model.TensionOrder, first *int, offset *int) int
	}

	AddUserEventPayload struct {
		NumUids   func(childComplexity int) int
		UserEvent func(childComplexity int, filter *model.UserEventFilter, order *model.UserEventOrder, first *int, offset *int) int
	}

	AddUserPayload struct {
		NumUids func(childComplexity int) int
		User    func(childComplexity int, filter *model.UserFilter, order *model.UserOrder, first *int, offset *int) int
	}

	AddUserRightsPayload struct {
		NumUids    func(childComplexity int) int
		UserRights func(childComplexity int, filter *model.UserRightsFilter, order *model.UserRightsOrder, first *int, offset *int) int
	}

	AddVotePayload struct {
		NumUids func(childComplexity int) int
		Vote    func(childComplexity int, filter *model.VoteFilter, order *model.VoteOrder, first *int, offset *int) int
	}

	Blob struct {
		ArchivedFlag func(childComplexity int) int
		BlobType     func(childComplexity int) int
		CreatedAt    func(childComplexity int) int
		CreatedBy    func(childComplexity int, filter *model.UserFilter) int
		ID           func(childComplexity int) int
		Md           func(childComplexity int) int
		Message      func(childComplexity int) int
		Node         func(childComplexity int, filter *model.NodeFragmentFilter) int
		PushedFlag   func(childComplexity int) int
		Tension      func(childComplexity int, filter *model.TensionFilter) int
		UpdatedAt    func(childComplexity int) int
	}

	BlobAggregateResult struct {
		ArchivedFlagMax func(childComplexity int) int
		ArchivedFlagMin func(childComplexity int) int
		Count           func(childComplexity int) int
		CreatedAtMax    func(childComplexity int) int
		CreatedAtMin    func(childComplexity int) int
		MdMax           func(childComplexity int) int
		MdMin           func(childComplexity int) int
		MessageMax      func(childComplexity int) int
		MessageMin      func(childComplexity int) int
		PushedFlagMax   func(childComplexity int) int
		PushedFlagMin   func(childComplexity int) int
		UpdatedAtMax    func(childComplexity int) int
		UpdatedAtMin    func(childComplexity int) int
	}

	Comment struct {
		CreatedAt          func(childComplexity int) int
		CreatedBy          func(childComplexity int, filter *model.UserFilter) int
		ID                 func(childComplexity int) int
		Message            func(childComplexity int) int
		Reactions          func(childComplexity int, filter *model.ReactionFilter, order *model.ReactionOrder, first *int, offset *int) int
		ReactionsAggregate func(childComplexity int, filter *model.ReactionFilter) int
		UpdatedAt          func(childComplexity int) int
	}

	CommentAggregateResult struct {
		Count        func(childComplexity int) int
		CreatedAtMax func(childComplexity int) int
		CreatedAtMin func(childComplexity int) int
		MessageMax   func(childComplexity int) int
		MessageMin   func(childComplexity int) int
		UpdatedAtMax func(childComplexity int) int
		UpdatedAtMin func(childComplexity int) int
	}

	Contract struct {
		Candidates                 func(childComplexity int, filter *model.UserFilter, order *model.UserOrder, first *int, offset *int) int
		CandidatesAggregate        func(childComplexity int, filter *model.UserFilter) int
		ClosedAt                   func(childComplexity int) int
		Comments                   func(childComplexity int, filter *model.CommentFilter, order *model.CommentOrder, first *int, offset *int) int
		CommentsAggregate          func(childComplexity int, filter *model.CommentFilter) int
		ContractType               func(childComplexity int) int
		Contractid                 func(childComplexity int) int
		CreatedAt                  func(childComplexity int) int
		CreatedBy                  func(childComplexity int, filter *model.UserFilter) int
		Event                      func(childComplexity int, filter *model.EventFragmentFilter) int
		ID                         func(childComplexity int) int
		IsValidator                func(childComplexity int) int
		Message                    func(childComplexity int) int
		Participants               func(childComplexity int, filter *model.VoteFilter, order *model.VoteOrder, first *int, offset *int) int
		ParticipantsAggregate      func(childComplexity int, filter *model.VoteFilter) int
		PendingCandidates          func(childComplexity int, filter *model.PendingUserFilter, order *model.PendingUserOrder, first *int, offset *int) int
		PendingCandidatesAggregate func(childComplexity int, filter *model.PendingUserFilter) int
		Status                     func(childComplexity int) int
		Tension                    func(childComplexity int, filter *model.TensionFilter) int
		UpdatedAt                  func(childComplexity int) int
	}

	ContractAggregateResult struct {
		ClosedAtMax   func(childComplexity int) int
		ClosedAtMin   func(childComplexity int) int
		ContractidMax func(childComplexity int) int
		ContractidMin func(childComplexity int) int
		Count         func(childComplexity int) int
		CreatedAtMax  func(childComplexity int) int
		CreatedAtMin  func(childComplexity int) int
		MessageMax    func(childComplexity int) int
		MessageMin    func(childComplexity int) int
		UpdatedAtMax  func(childComplexity int) int
		UpdatedAtMin  func(childComplexity int) int
	}

	DeleteBlobPayload struct {
		Blob    func(childComplexity int, filter *model.BlobFilter, order *model.BlobOrder, first *int, offset *int) int
		Msg     func(childComplexity int) int
		NumUids func(childComplexity int) int
	}

	DeleteCommentPayload struct {
		Comment func(childComplexity int, filter *model.CommentFilter, order *model.CommentOrder, first *int, offset *int) int
		Msg     func(childComplexity int) int
		NumUids func(childComplexity int) int
	}

	DeleteContractPayload struct {
		Contract func(childComplexity int, filter *model.ContractFilter, order *model.ContractOrder, first *int, offset *int) int
		Msg      func(childComplexity int) int
		NumUids  func(childComplexity int) int
	}

	DeleteEventCountPayload struct {
		EventCount func(childComplexity int, filter *model.EventCountFilter, order *model.EventCountOrder, first *int, offset *int) int
		Msg        func(childComplexity int) int
		NumUids    func(childComplexity int) int
	}

	DeleteEventFragmentPayload struct {
		EventFragment func(childComplexity int, filter *model.EventFragmentFilter, order *model.EventFragmentOrder, first *int, offset *int) int
		Msg           func(childComplexity int) int
		NumUids       func(childComplexity int) int
	}

	DeleteEventPayload struct {
		Event   func(childComplexity int, filter *model.EventFilter, order *model.EventOrder, first *int, offset *int) int
		Msg     func(childComplexity int) int
		NumUids func(childComplexity int) int
	}

	DeleteLabelPayload struct {
		Label   func(childComplexity int, filter *model.LabelFilter, order *model.LabelOrder, first *int, offset *int) int
		Msg     func(childComplexity int) int
		NumUids func(childComplexity int) int
	}

	DeleteMandatePayload struct {
		Mandate func(childComplexity int, filter *model.MandateFilter, order *model.MandateOrder, first *int, offset *int) int
		Msg     func(childComplexity int) int
		NumUids func(childComplexity int) int
	}

	DeleteNodeFragmentPayload struct {
		Msg          func(childComplexity int) int
		NodeFragment func(childComplexity int, filter *model.NodeFragmentFilter, order *model.NodeFragmentOrder, first *int, offset *int) int
		NumUids      func(childComplexity int) int
	}

	DeleteNodePayload struct {
		Msg     func(childComplexity int) int
		Node    func(childComplexity int, filter *model.NodeFilter, order *model.NodeOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	DeleteNotifPayload struct {
		Msg     func(childComplexity int) int
		Notif   func(childComplexity int, filter *model.NotifFilter, order *model.NotifOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	DeletePendingUserPayload struct {
		Msg         func(childComplexity int) int
		NumUids     func(childComplexity int) int
		PendingUser func(childComplexity int, filter *model.PendingUserFilter, order *model.PendingUserOrder, first *int, offset *int) int
	}

	DeletePostPayload struct {
		Msg     func(childComplexity int) int
		NumUids func(childComplexity int) int
		Post    func(childComplexity int, filter *model.PostFilter, order *model.PostOrder, first *int, offset *int) int
	}

	DeleteProjectCardPayload struct {
		Msg         func(childComplexity int) int
		NumUids     func(childComplexity int) int
		ProjectCard func(childComplexity int, filter *model.ProjectCardFilter, order *model.ProjectCardOrder, first *int, offset *int) int
	}

	DeleteProjectColumnPayload struct {
		Msg           func(childComplexity int) int
		NumUids       func(childComplexity int) int
		ProjectColumn func(childComplexity int, filter *model.ProjectColumnFilter, order *model.ProjectColumnOrder, first *int, offset *int) int
	}

	DeleteProjectDraftPayload struct {
		Msg          func(childComplexity int) int
		NumUids      func(childComplexity int) int
		ProjectDraft func(childComplexity int, filter *model.ProjectDraftFilter, order *model.ProjectDraftOrder, first *int, offset *int) int
	}

	DeleteProjectFieldPayload struct {
		Msg          func(childComplexity int) int
		NumUids      func(childComplexity int) int
		ProjectField func(childComplexity int, filter *model.ProjectFieldFilter, first *int, offset *int) int
	}

	DeleteProjectFieldValuePayload struct {
		Msg               func(childComplexity int) int
		NumUids           func(childComplexity int) int
		ProjectFieldValue func(childComplexity int, filter *model.ProjectFieldValueFilter, order *model.ProjectFieldValueOrder, first *int, offset *int) int
	}

	DeleteProjectPayload struct {
		Msg     func(childComplexity int) int
		NumUids func(childComplexity int) int
		Project func(childComplexity int, filter *model.ProjectFilter, order *model.ProjectOrder, first *int, offset *int) int
	}

	DeleteReactionPayload struct {
		Msg      func(childComplexity int) int
		NumUids  func(childComplexity int) int
		Reaction func(childComplexity int, filter *model.ReactionFilter, order *model.ReactionOrder, first *int, offset *int) int
	}

	DeleteRoleExtPayload struct {
		Msg     func(childComplexity int) int
		NumUids func(childComplexity int) int
		RoleExt func(childComplexity int, filter *model.RoleExtFilter, order *model.RoleExtOrder, first *int, offset *int) int
	}

	DeleteTensionPayload struct {
		Msg     func(childComplexity int) int
		NumUids func(childComplexity int) int
		Tension func(childComplexity int, filter *model.TensionFilter, order *model.TensionOrder, first *int, offset *int) int
	}

	DeleteUserEventPayload struct {
		Msg       func(childComplexity int) int
		NumUids   func(childComplexity int) int
		UserEvent func(childComplexity int, filter *model.UserEventFilter, order *model.UserEventOrder, first *int, offset *int) int
	}

	DeleteUserPayload struct {
		Msg     func(childComplexity int) int
		NumUids func(childComplexity int) int
		User    func(childComplexity int, filter *model.UserFilter, order *model.UserOrder, first *int, offset *int) int
	}

	DeleteUserRightsPayload struct {
		Msg        func(childComplexity int) int
		NumUids    func(childComplexity int) int
		UserRights func(childComplexity int, filter *model.UserRightsFilter, order *model.UserRightsOrder, first *int, offset *int) int
	}

	DeleteVotePayload struct {
		Msg     func(childComplexity int) int
		NumUids func(childComplexity int) int
		Vote    func(childComplexity int, filter *model.VoteFilter, order *model.VoteOrder, first *int, offset *int) int
	}

	Event struct {
		CreatedAt func(childComplexity int) int
		CreatedBy func(childComplexity int, filter *model.UserFilter) int
		EventType func(childComplexity int) int
		ID        func(childComplexity int) int
		Mentioned func(childComplexity int, filter *model.TensionFilter) int
		Message   func(childComplexity int) int
		New       func(childComplexity int) int
		Old       func(childComplexity int) int
		Tension   func(childComplexity int, filter *model.TensionFilter) int
		UpdatedAt func(childComplexity int) int
	}

	EventAggregateResult struct {
		Count        func(childComplexity int) int
		CreatedAtMax func(childComplexity int) int
		CreatedAtMin func(childComplexity int) int
		MessageMax   func(childComplexity int) int
		MessageMin   func(childComplexity int) int
		NewMax       func(childComplexity int) int
		NewMin       func(childComplexity int) int
		OldMax       func(childComplexity int) int
		OldMin       func(childComplexity int) int
		UpdatedAtMax func(childComplexity int) int
		UpdatedAtMin func(childComplexity int) int
	}

	EventCount struct {
		AssignedTensions func(childComplexity int) int
		PendingContracts func(childComplexity int) int
		UnreadEvents     func(childComplexity int) int
	}

	EventCountAggregateResult struct {
		AssignedTensionsAvg func(childComplexity int) int
		AssignedTensionsMax func(childComplexity int) int
		AssignedTensionsMin func(childComplexity int) int
		AssignedTensionsSum func(childComplexity int) int
		Count               func(childComplexity int) int
		PendingContractsAvg func(childComplexity int) int
		PendingContractsMax func(childComplexity int) int
		PendingContractsMin func(childComplexity int) int
		PendingContractsSum func(childComplexity int) int
		UnreadEventsAvg     func(childComplexity int) int
		UnreadEventsMax     func(childComplexity int) int
		UnreadEventsMin     func(childComplexity int) int
		UnreadEventsSum     func(childComplexity int) int
	}

	EventFragment struct {
		EventType func(childComplexity int) int
		New       func(childComplexity int) int
		Old       func(childComplexity int) int
	}

	EventFragmentAggregateResult struct {
		Count  func(childComplexity int) int
		NewMax func(childComplexity int) int
		NewMin func(childComplexity int) int
		OldMax func(childComplexity int) int
		OldMin func(childComplexity int) int
	}

	Label struct {
		Color             func(childComplexity int) int
		Description       func(childComplexity int) int
		ID                func(childComplexity int) int
		Name              func(childComplexity int) int
		Nodes             func(childComplexity int, filter *model.NodeFilter, order *model.NodeOrder, first *int, offset *int) int
		NodesAggregate    func(childComplexity int, filter *model.NodeFilter) int
		Rootnameid        func(childComplexity int) int
		Tensions          func(childComplexity int, filter *model.TensionFilter, order *model.TensionOrder, first *int, offset *int) int
		TensionsAggregate func(childComplexity int, filter *model.TensionFilter) int
	}

	LabelAggregateResult struct {
		ColorMax       func(childComplexity int) int
		ColorMin       func(childComplexity int) int
		Count          func(childComplexity int) int
		DescriptionMax func(childComplexity int) int
		DescriptionMin func(childComplexity int) int
		NameMax        func(childComplexity int) int
		NameMin        func(childComplexity int) int
		RootnameidMax  func(childComplexity int) int
		RootnameidMin  func(childComplexity int) int
	}

	Mandate struct {
		Domains          func(childComplexity int) int
		ID               func(childComplexity int) int
		Policies         func(childComplexity int) int
		Purpose          func(childComplexity int) int
		Responsabilities func(childComplexity int) int
	}

	MandateAggregateResult struct {
		Count               func(childComplexity int) int
		DomainsMax          func(childComplexity int) int
		DomainsMin          func(childComplexity int) int
		PoliciesMax         func(childComplexity int) int
		PoliciesMin         func(childComplexity int) int
		PurposeMax          func(childComplexity int) int
		PurposeMin          func(childComplexity int) int
		ResponsabilitiesMax func(childComplexity int) int
		ResponsabilitiesMin func(childComplexity int) int
	}

	MultiPolygon struct {
		Polygons func(childComplexity int) int
	}

	Mutation struct {
		AddBlob                 func(childComplexity int, input []*model.AddBlobInput) int
		AddComment              func(childComplexity int, input []*model.AddCommentInput) int
		AddContract             func(childComplexity int, input []*model.AddContractInput, upsert *bool) int
		AddEvent                func(childComplexity int, input []*model.AddEventInput) int
		AddEventCount           func(childComplexity int, input []*model.AddEventCountInput) int
		AddEventFragment        func(childComplexity int, input []*model.AddEventFragmentInput) int
		AddLabel                func(childComplexity int, input []*model.AddLabelInput) int
		AddMandate              func(childComplexity int, input []*model.AddMandateInput) int
		AddNode                 func(childComplexity int, input []*model.AddNodeInput, upsert *bool) int
		AddNodeFragment         func(childComplexity int, input []*model.AddNodeFragmentInput) int
		AddNotif                func(childComplexity int, input []*model.AddNotifInput) int
		AddPendingUser          func(childComplexity int, input []*model.AddPendingUserInput, upsert *bool) int
		AddProject              func(childComplexity int, input []*model.AddProjectInput) int
		AddProjectCard          func(childComplexity int, input []*model.AddProjectCardInput) int
		AddProjectColumn        func(childComplexity int, input []*model.AddProjectColumnInput) int
		AddProjectDraft         func(childComplexity int, input []*model.AddProjectDraftInput) int
		AddProjectField         func(childComplexity int, input []*model.AddProjectFieldInput) int
		AddProjectFieldValue    func(childComplexity int, input []*model.AddProjectFieldValueInput) int
		AddReaction             func(childComplexity int, input []*model.AddReactionInput, upsert *bool) int
		AddRoleExt              func(childComplexity int, input []*model.AddRoleExtInput) int
		AddTension              func(childComplexity int, input []*model.AddTensionInput) int
		AddUser                 func(childComplexity int, input []*model.AddUserInput, upsert *bool) int
		AddUserEvent            func(childComplexity int, input []*model.AddUserEventInput) int
		AddUserRights           func(childComplexity int, input []*model.AddUserRightsInput) int
		AddVote                 func(childComplexity int, input []*model.AddVoteInput, upsert *bool) int
		DeleteBlob              func(childComplexity int, filter model.BlobFilter) int
		DeleteComment           func(childComplexity int, filter model.CommentFilter) int
		DeleteContract          func(childComplexity int, filter model.ContractFilter) int
		DeleteEvent             func(childComplexity int, filter model.EventFilter) int
		DeleteEventCount        func(childComplexity int, filter model.EventCountFilter) int
		DeleteEventFragment     func(childComplexity int, filter model.EventFragmentFilter) int
		DeleteLabel             func(childComplexity int, filter model.LabelFilter) int
		DeleteMandate           func(childComplexity int, filter model.MandateFilter) int
		DeleteNode              func(childComplexity int, filter model.NodeFilter) int
		DeleteNodeFragment      func(childComplexity int, filter model.NodeFragmentFilter) int
		DeleteNotif             func(childComplexity int, filter model.NotifFilter) int
		DeletePendingUser       func(childComplexity int, filter model.PendingUserFilter) int
		DeletePost              func(childComplexity int, filter model.PostFilter) int
		DeleteProject           func(childComplexity int, filter model.ProjectFilter) int
		DeleteProjectCard       func(childComplexity int, filter model.ProjectCardFilter) int
		DeleteProjectColumn     func(childComplexity int, filter model.ProjectColumnFilter) int
		DeleteProjectDraft      func(childComplexity int, filter model.ProjectDraftFilter) int
		DeleteProjectField      func(childComplexity int, filter model.ProjectFieldFilter) int
		DeleteProjectFieldValue func(childComplexity int, filter model.ProjectFieldValueFilter) int
		DeleteReaction          func(childComplexity int, filter model.ReactionFilter) int
		DeleteRoleExt           func(childComplexity int, filter model.RoleExtFilter) int
		DeleteTension           func(childComplexity int, filter model.TensionFilter) int
		DeleteUser              func(childComplexity int, filter model.UserFilter) int
		DeleteUserEvent         func(childComplexity int, filter model.UserEventFilter) int
		DeleteUserRights        func(childComplexity int, filter model.UserRightsFilter) int
		DeleteVote              func(childComplexity int, filter model.VoteFilter) int
		UpdateBlob              func(childComplexity int, input model.UpdateBlobInput) int
		UpdateComment           func(childComplexity int, input model.UpdateCommentInput) int
		UpdateContract          func(childComplexity int, input model.UpdateContractInput) int
		UpdateEvent             func(childComplexity int, input model.UpdateEventInput) int
		UpdateEventCount        func(childComplexity int, input model.UpdateEventCountInput) int
		UpdateEventFragment     func(childComplexity int, input model.UpdateEventFragmentInput) int
		UpdateLabel             func(childComplexity int, input model.UpdateLabelInput) int
		UpdateMandate           func(childComplexity int, input model.UpdateMandateInput) int
		UpdateNode              func(childComplexity int, input model.UpdateNodeInput) int
		UpdateNodeFragment      func(childComplexity int, input model.UpdateNodeFragmentInput) int
		UpdateNotif             func(childComplexity int, input model.UpdateNotifInput) int
		UpdatePendingUser       func(childComplexity int, input model.UpdatePendingUserInput) int
		UpdatePost              func(childComplexity int, input model.UpdatePostInput) int
		UpdateProject           func(childComplexity int, input model.UpdateProjectInput) int
		UpdateProjectCard       func(childComplexity int, input model.UpdateProjectCardInput) int
		UpdateProjectColumn     func(childComplexity int, input model.UpdateProjectColumnInput) int
		UpdateProjectDraft      func(childComplexity int, input model.UpdateProjectDraftInput) int
		UpdateProjectField      func(childComplexity int, input model.UpdateProjectFieldInput) int
		UpdateProjectFieldValue func(childComplexity int, input model.UpdateProjectFieldValueInput) int
		UpdateReaction          func(childComplexity int, input model.UpdateReactionInput) int
		UpdateRoleExt           func(childComplexity int, input model.UpdateRoleExtInput) int
		UpdateTension           func(childComplexity int, input model.UpdateTensionInput) int
		UpdateUser              func(childComplexity int, input model.UpdateUserInput) int
		UpdateUserEvent         func(childComplexity int, input model.UpdateUserEventInput) int
		UpdateUserRights        func(childComplexity int, input model.UpdateUserRightsInput) int
		UpdateVote              func(childComplexity int, input model.UpdateVoteInput) int
	}

	Node struct {
		About                  func(childComplexity int) int
		Children               func(childComplexity int, filter *model.NodeFilter, order *model.NodeOrder, first *int, offset *int) int
		ChildrenAggregate      func(childComplexity int, filter *model.NodeFilter) int
		Color                  func(childComplexity int) int
		Contracts              func(childComplexity int, filter *model.VoteFilter, order *model.VoteOrder, first *int, offset *int) int
		ContractsAggregate     func(childComplexity int, filter *model.VoteFilter) int
		CreatedAt              func(childComplexity int) int
		CreatedBy              func(childComplexity int, filter *model.UserFilter) int
		EventsHistory          func(childComplexity int, filter *model.EventFilter, order *model.EventOrder, first *int, offset *int) int
		EventsHistoryAggregate func(childComplexity int, filter *model.EventFilter) int
		FirstLink              func(childComplexity int, filter *model.UserFilter) int
		GuestCanCreateTension  func(childComplexity int) int
		ID                     func(childComplexity int) int
		IsArchived             func(childComplexity int) int
		IsPersonal             func(childComplexity int) int
		IsRoot                 func(childComplexity int) int
		Labels                 func(childComplexity int, filter *model.LabelFilter, order *model.LabelOrder, first *int, offset *int) int
		LabelsAggregate        func(childComplexity int, filter *model.LabelFilter) int
		Mode                   func(childComplexity int) int
		Name                   func(childComplexity int) int
		Nameid                 func(childComplexity int) int
		Parent                 func(childComplexity int, filter *model.NodeFilter) int
		Pinned                 func(childComplexity int, filter *model.TensionFilter, order *model.TensionOrder, first *int, offset *int) int
		PinnedAggregate        func(childComplexity int, filter *model.TensionFilter) int
		Projects               func(childComplexity int, filter *model.ProjectFilter, order *model.ProjectOrder, first *int, offset *int) int
		ProjectsAggregate      func(childComplexity int, filter *model.ProjectFilter) int
		Rights                 func(childComplexity int) int
		RoleExt                func(childComplexity int, filter *model.RoleExtFilter) int
		RoleType               func(childComplexity int) int
		Roles                  func(childComplexity int, filter *model.RoleExtFilter, order *model.RoleExtOrder, first *int, offset *int) int
		RolesAggregate         func(childComplexity int, filter *model.RoleExtFilter) int
		Rootnameid             func(childComplexity int) int
		Skills                 func(childComplexity int) int
		Source                 func(childComplexity int, filter *model.BlobFilter) int
		TensionsIn             func(childComplexity int, filter *model.TensionFilter, order *model.TensionOrder, first *int, offset *int) int
		TensionsInAggregate    func(childComplexity int, filter *model.TensionFilter) int
		TensionsOut            func(childComplexity int, filter *model.TensionFilter, order *model.TensionOrder, first *int, offset *int) int
		TensionsOutAggregate   func(childComplexity int, filter *model.TensionFilter) int
		Type                   func(childComplexity int) int
		UpdatedAt              func(childComplexity int) int
		UserCanJoin            func(childComplexity int) int
		Visibility             func(childComplexity int) int
		Watchers               func(childComplexity int, filter *model.UserFilter, order *model.UserOrder, first *int, offset *int) int
		WatchersAggregate      func(childComplexity int, filter *model.UserFilter) int
	}

	NodeAggregateResult struct {
		AboutMax      func(childComplexity int) int
		AboutMin      func(childComplexity int) int
		ColorMax      func(childComplexity int) int
		ColorMin      func(childComplexity int) int
		Count         func(childComplexity int) int
		CreatedAtMax  func(childComplexity int) int
		CreatedAtMin  func(childComplexity int) int
		NameMax       func(childComplexity int) int
		NameMin       func(childComplexity int) int
		NameidMax     func(childComplexity int) int
		NameidMin     func(childComplexity int) int
		RightsAvg     func(childComplexity int) int
		RightsMax     func(childComplexity int) int
		RightsMin     func(childComplexity int) int
		RightsSum     func(childComplexity int) int
		RootnameidMax func(childComplexity int) int
		RootnameidMin func(childComplexity int) int
		UpdatedAtMax  func(childComplexity int) int
		UpdatedAtMin  func(childComplexity int) int
	}

	NodeFragment struct {
		About      func(childComplexity int) int
		Color      func(childComplexity int) int
		FirstLink  func(childComplexity int) int
		ID         func(childComplexity int) int
		Mandate    func(childComplexity int, filter *model.MandateFilter) int
		Mode       func(childComplexity int) int
		Name       func(childComplexity int) int
		Nameid     func(childComplexity int) int
		RoleExt    func(childComplexity int) int
		RoleType   func(childComplexity int) int
		Skills     func(childComplexity int) int
		Type       func(childComplexity int) int
		Visibility func(childComplexity int) int
	}

	NodeFragmentAggregateResult struct {
		AboutMax     func(childComplexity int) int
		AboutMin     func(childComplexity int) int
		ColorMax     func(childComplexity int) int
		ColorMin     func(childComplexity int) int
		Count        func(childComplexity int) int
		FirstLinkMax func(childComplexity int) int
		FirstLinkMin func(childComplexity int) int
		NameMax      func(childComplexity int) int
		NameMin      func(childComplexity int) int
		NameidMax    func(childComplexity int) int
		NameidMin    func(childComplexity int) int
		RoleExtMax   func(childComplexity int) int
		RoleExtMin   func(childComplexity int) int
	}

	Notif struct {
		Contract  func(childComplexity int, filter *model.ContractFilter) int
		CreatedAt func(childComplexity int) int
		CreatedBy func(childComplexity int, filter *model.UserFilter) int
		ID        func(childComplexity int) int
		Link      func(childComplexity int) int
		Message   func(childComplexity int) int
		Tension   func(childComplexity int, filter *model.TensionFilter) int
		UpdatedAt func(childComplexity int) int
	}

	NotifAggregateResult struct {
		Count        func(childComplexity int) int
		CreatedAtMax func(childComplexity int) int
		CreatedAtMin func(childComplexity int) int
		LinkMax      func(childComplexity int) int
		LinkMin      func(childComplexity int) int
		MessageMax   func(childComplexity int) int
		MessageMin   func(childComplexity int) int
		UpdatedAtMax func(childComplexity int) int
		UpdatedAtMin func(childComplexity int) int
	}

	PendingUser struct {
		Contracts          func(childComplexity int, filter *model.ContractFilter, order *model.ContractOrder, first *int, offset *int) int
		ContractsAggregate func(childComplexity int, filter *model.ContractFilter) int
		Email              func(childComplexity int) int
		EmailToken         func(childComplexity int) int
		ID                 func(childComplexity int) int
		Password           func(childComplexity int) int
		Subscribe          func(childComplexity int) int
		Token              func(childComplexity int) int
		UpdatedAt          func(childComplexity int) int
		Username           func(childComplexity int) int
	}

	PendingUserAggregateResult struct {
		Count         func(childComplexity int) int
		EmailMax      func(childComplexity int) int
		EmailMin      func(childComplexity int) int
		EmailTokenMax func(childComplexity int) int
		EmailTokenMin func(childComplexity int) int
		PasswordMax   func(childComplexity int) int
		PasswordMin   func(childComplexity int) int
		TokenMax      func(childComplexity int) int
		TokenMin      func(childComplexity int) int
		UpdatedAtMax  func(childComplexity int) int
		UpdatedAtMin  func(childComplexity int) int
		UsernameMax   func(childComplexity int) int
		UsernameMin   func(childComplexity int) int
	}

	Point struct {
		Latitude  func(childComplexity int) int
		Longitude func(childComplexity int) int
	}

	PointList struct {
		Points func(childComplexity int) int
	}

	Polygon struct {
		Coordinates func(childComplexity int) int
	}

	Post struct {
		CreatedAt func(childComplexity int) int
		CreatedBy func(childComplexity int, filter *model.UserFilter) int
		ID        func(childComplexity int) int
		Message   func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	PostAggregateResult struct {
		Count        func(childComplexity int) int
		CreatedAtMax func(childComplexity int) int
		CreatedAtMin func(childComplexity int) int
		MessageMax   func(childComplexity int) int
		MessageMin   func(childComplexity int) int
		UpdatedAtMax func(childComplexity int) int
		UpdatedAtMin func(childComplexity int) int
	}

	Project struct {
		Columns          func(childComplexity int, filter *model.ProjectColumnFilter, order *model.ProjectColumnOrder, first *int, offset *int) int
		ColumnsAggregate func(childComplexity int, filter *model.ProjectColumnFilter) int
		CreatedAt        func(childComplexity int) int
		CreatedBy        func(childComplexity int, filter *model.UserFilter) int
		Description      func(childComplexity int) int
		Fields           func(childComplexity int, filter *model.ProjectFieldFilter, first *int, offset *int) int
		FieldsAggregate  func(childComplexity int, filter *model.ProjectFieldFilter) int
		ID               func(childComplexity int) int
		Leaders          func(childComplexity int, filter *model.NodeFilter, order *model.NodeOrder, first *int, offset *int) int
		LeadersAggregate func(childComplexity int, filter *model.NodeFilter) int
		Name             func(childComplexity int) int
		Nameid           func(childComplexity int) int
		Nodes            func(childComplexity int, filter *model.NodeFilter, order *model.NodeOrder, first *int, offset *int) int
		NodesAggregate   func(childComplexity int, filter *model.NodeFilter) int
		Parentnameid     func(childComplexity int) int
		Rootnameid       func(childComplexity int) int
		Status           func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
	}

	ProjectAggregateResult struct {
		Count           func(childComplexity int) int
		CreatedAtMax    func(childComplexity int) int
		CreatedAtMin    func(childComplexity int) int
		DescriptionMax  func(childComplexity int) int
		DescriptionMin  func(childComplexity int) int
		NameMax         func(childComplexity int) int
		NameMin         func(childComplexity int) int
		NameidMax       func(childComplexity int) int
		NameidMin       func(childComplexity int) int
		ParentnameidMax func(childComplexity int) int
		ParentnameidMin func(childComplexity int) int
		RootnameidMax   func(childComplexity int) int
		RootnameidMin   func(childComplexity int) int
		UpdatedAtMax    func(childComplexity int) int
		UpdatedAtMin    func(childComplexity int) int
	}

	ProjectCard struct {
		Card            func(childComplexity int, filter *model.CardKindFilter) int
		ID              func(childComplexity int) int
		Pc              func(childComplexity int, filter *model.ProjectColumnFilter) int
		Pos             func(childComplexity int) int
		Values          func(childComplexity int, filter *model.ProjectFieldValueFilter, order *model.ProjectFieldValueOrder, first *int, offset *int) int
		ValuesAggregate func(childComplexity int, filter *model.ProjectFieldValueFilter) int
	}

	ProjectCardAggregateResult struct {
		Count  func(childComplexity int) int
		PosAvg func(childComplexity int) int
		PosMax func(childComplexity int) int
		PosMin func(childComplexity int) int
		PosSum func(childComplexity int) int
	}

	ProjectColumn struct {
		Cards             func(childComplexity int, filter *model.ProjectCardFilter, order *model.ProjectCardOrder, first *int, offset *int) int
		CardsAggregate    func(childComplexity int, filter *model.ProjectCardFilter) int
		ColType           func(childComplexity int) int
		Color             func(childComplexity int) int
		Description       func(childComplexity int) int
		ID                func(childComplexity int) int
		Name              func(childComplexity int) int
		Pos               func(childComplexity int) int
		Project           func(childComplexity int, filter *model.ProjectFilter) int
		Tensions          func(childComplexity int, filter *model.TensionFilter, order *model.TensionOrder, first *int, offset *int) int
		TensionsAggregate func(childComplexity int, filter *model.TensionFilter) int
	}

	ProjectColumnAggregateResult struct {
		ColorMax       func(childComplexity int) int
		ColorMin       func(childComplexity int) int
		Count          func(childComplexity int) int
		DescriptionMax func(childComplexity int) int
		DescriptionMin func(childComplexity int) int
		NameMax        func(childComplexity int) int
		NameMin        func(childComplexity int) int
		PosAvg         func(childComplexity int) int
		PosMax         func(childComplexity int) int
		PosMin         func(childComplexity int) int
		PosSum         func(childComplexity int) int
	}

	ProjectDraft struct {
		CreatedAt func(childComplexity int) int
		CreatedBy func(childComplexity int, filter *model.UserFilter) int
		ID        func(childComplexity int) int
		Message   func(childComplexity int) int
		Title     func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	ProjectDraftAggregateResult struct {
		Count        func(childComplexity int) int
		CreatedAtMax func(childComplexity int) int
		CreatedAtMin func(childComplexity int) int
		MessageMax   func(childComplexity int) int
		MessageMin   func(childComplexity int) int
		TitleMax     func(childComplexity int) int
		TitleMin     func(childComplexity int) int
		UpdatedAtMax func(childComplexity int) int
		UpdatedAtMin func(childComplexity int) int
	}

	ProjectField struct {
		FieldType       func(childComplexity int) int
		IsVisible       func(childComplexity int) int
		Values          func(childComplexity int, filter *model.ProjectFieldValueFilter, order *model.ProjectFieldValueOrder, first *int, offset *int) int
		ValuesAggregate func(childComplexity int, filter *model.ProjectFieldValueFilter) int
	}

	ProjectFieldAggregateResult struct {
		Count func(childComplexity int) int
	}

	ProjectFieldValue struct {
		Field func(childComplexity int, filter *model.ProjectFieldFilter) int
		Pos   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	ProjectFieldValueAggregateResult struct {
		Count    func(childComplexity int) int
		PosAvg   func(childComplexity int) int
		PosMax   func(childComplexity int) int
		PosMin   func(childComplexity int) int
		PosSum   func(childComplexity int) int
		ValueMax func(childComplexity int) int
		ValueMin func(childComplexity int) int
	}

	Query struct {
		AggregateBlob              func(childComplexity int, filter *model.BlobFilter) int
		AggregateComment           func(childComplexity int, filter *model.CommentFilter) int
		AggregateContract          func(childComplexity int, filter *model.ContractFilter) int
		AggregateEvent             func(childComplexity int, filter *model.EventFilter) int
		AggregateEventCount        func(childComplexity int, filter *model.EventCountFilter) int
		AggregateEventFragment     func(childComplexity int, filter *model.EventFragmentFilter) int
		AggregateLabel             func(childComplexity int, filter *model.LabelFilter) int
		AggregateMandate           func(childComplexity int, filter *model.MandateFilter) int
		AggregateNode              func(childComplexity int, filter *model.NodeFilter) int
		AggregateNodeFragment      func(childComplexity int, filter *model.NodeFragmentFilter) int
		AggregateNotif             func(childComplexity int, filter *model.NotifFilter) int
		AggregatePendingUser       func(childComplexity int, filter *model.PendingUserFilter) int
		AggregatePost              func(childComplexity int, filter *model.PostFilter) int
		AggregateProject           func(childComplexity int, filter *model.ProjectFilter) int
		AggregateProjectCard       func(childComplexity int, filter *model.ProjectCardFilter) int
		AggregateProjectColumn     func(childComplexity int, filter *model.ProjectColumnFilter) int
		AggregateProjectDraft      func(childComplexity int, filter *model.ProjectDraftFilter) int
		AggregateProjectField      func(childComplexity int, filter *model.ProjectFieldFilter) int
		AggregateProjectFieldValue func(childComplexity int, filter *model.ProjectFieldValueFilter) int
		AggregateReaction          func(childComplexity int, filter *model.ReactionFilter) int
		AggregateRoleExt           func(childComplexity int, filter *model.RoleExtFilter) int
		AggregateTension           func(childComplexity int, filter *model.TensionFilter) int
		AggregateUser              func(childComplexity int, filter *model.UserFilter) int
		AggregateUserEvent         func(childComplexity int, filter *model.UserEventFilter) int
		AggregateUserRights        func(childComplexity int, filter *model.UserRightsFilter) int
		AggregateVote              func(childComplexity int, filter *model.VoteFilter) int
		GetBlob                    func(childComplexity int, id string) int
		GetComment                 func(childComplexity int, id string) int
		GetContract                func(childComplexity int, id *string, contractid *string) int
		GetEvent                   func(childComplexity int, id string) int
		GetLabel                   func(childComplexity int, id string) int
		GetMandate                 func(childComplexity int, id string) int
		GetNode                    func(childComplexity int, id *string, nameid *string) int
		GetNodeFragment            func(childComplexity int, id string) int
		GetNotif                   func(childComplexity int, id string) int
		GetPendingUser             func(childComplexity int, id *string, username *string, email *string) int
		GetPost                    func(childComplexity int, id string) int
		GetProject                 func(childComplexity int, id string) int
		GetProjectCard             func(childComplexity int, id string) int
		GetProjectColumn           func(childComplexity int, id string) int
		GetProjectDraft            func(childComplexity int, id string) int
		GetReaction                func(childComplexity int, id *string, reactionid *string) int
		GetRoleExt                 func(childComplexity int, id string) int
		GetTension                 func(childComplexity int, id string) int
		GetUser                    func(childComplexity int, id *string, username *string, email *string) int
		GetUserEvent               func(childComplexity int, id string) int
		GetVote                    func(childComplexity int, id *string, voteid *string) int
		QueryBlob                  func(childComplexity int, filter *model.BlobFilter, order *model.BlobOrder, first *int, offset *int) int
		QueryComment               func(childComplexity int, filter *model.CommentFilter, order *model.CommentOrder, first *int, offset *int) int
		QueryContract              func(childComplexity int, filter *model.ContractFilter, order *model.ContractOrder, first *int, offset *int) int
		QueryEvent                 func(childComplexity int, filter *model.EventFilter, order *model.EventOrder, first *int, offset *int) int
		QueryEventCount            func(childComplexity int, filter *model.EventCountFilter, order *model.EventCountOrder, first *int, offset *int) int
		QueryEventFragment         func(childComplexity int, filter *model.EventFragmentFilter, order *model.EventFragmentOrder, first *int, offset *int) int
		QueryLabel                 func(childComplexity int, filter *model.LabelFilter, order *model.LabelOrder, first *int, offset *int) int
		QueryMandate               func(childComplexity int, filter *model.MandateFilter, order *model.MandateOrder, first *int, offset *int) int
		QueryNode                  func(childComplexity int, filter *model.NodeFilter, order *model.NodeOrder, first *int, offset *int) int
		QueryNodeFragment          func(childComplexity int, filter *model.NodeFragmentFilter, order *model.NodeFragmentOrder, first *int, offset *int) int
		QueryNotif                 func(childComplexity int, filter *model.NotifFilter, order *model.NotifOrder, first *int, offset *int) int
		QueryPendingUser           func(childComplexity int, filter *model.PendingUserFilter, order *model.PendingUserOrder, first *int, offset *int) int
		QueryPost                  func(childComplexity int, filter *model.PostFilter, order *model.PostOrder, first *int, offset *int) int
		QueryProject               func(childComplexity int, filter *model.ProjectFilter, order *model.ProjectOrder, first *int, offset *int) int
		QueryProjectCard           func(childComplexity int, filter *model.ProjectCardFilter, order *model.ProjectCardOrder, first *int, offset *int) int
		QueryProjectColumn         func(childComplexity int, filter *model.ProjectColumnFilter, order *model.ProjectColumnOrder, first *int, offset *int) int
		QueryProjectDraft          func(childComplexity int, filter *model.ProjectDraftFilter, order *model.ProjectDraftOrder, first *int, offset *int) int
		QueryProjectField          func(childComplexity int, filter *model.ProjectFieldFilter, first *int, offset *int) int
		QueryProjectFieldValue     func(childComplexity int, filter *model.ProjectFieldValueFilter, order *model.ProjectFieldValueOrder, first *int, offset *int) int
		QueryReaction              func(childComplexity int, filter *model.ReactionFilter, order *model.ReactionOrder, first *int, offset *int) int
		QueryRoleExt               func(childComplexity int, filter *model.RoleExtFilter, order *model.RoleExtOrder, first *int, offset *int) int
		QueryTension               func(childComplexity int, filter *model.TensionFilter, order *model.TensionOrder, first *int, offset *int) int
		QueryUser                  func(childComplexity int, filter *model.UserFilter, order *model.UserOrder, first *int, offset *int) int
		QueryUserEvent             func(childComplexity int, filter *model.UserEventFilter, order *model.UserEventOrder, first *int, offset *int) int
		QueryUserRights            func(childComplexity int, filter *model.UserRightsFilter, order *model.UserRightsOrder, first *int, offset *int) int
		QueryVote                  func(childComplexity int, filter *model.VoteFilter, order *model.VoteOrder, first *int, offset *int) int
	}

	Reaction struct {
		Comment    func(childComplexity int, filter *model.CommentFilter) int
		ID         func(childComplexity int) int
		Reactionid func(childComplexity int) int
		Type       func(childComplexity int) int
		User       func(childComplexity int, filter *model.UserFilter) int
	}

	ReactionAggregateResult struct {
		Count         func(childComplexity int) int
		ReactionidMax func(childComplexity int) int
		ReactionidMin func(childComplexity int) int
		TypeAvg       func(childComplexity int) int
		TypeMax       func(childComplexity int) int
		TypeMin       func(childComplexity int) int
		TypeSum       func(childComplexity int) int
	}

	RoleExt struct {
		About          func(childComplexity int) int
		Color          func(childComplexity int) int
		ID             func(childComplexity int) int
		Mandate        func(childComplexity int, filter *model.MandateFilter) int
		Name           func(childComplexity int) int
		Nodes          func(childComplexity int, filter *model.NodeFilter, order *model.NodeOrder, first *int, offset *int) int
		NodesAggregate func(childComplexity int, filter *model.NodeFilter) int
		RoleType       func(childComplexity int) int
		Roles          func(childComplexity int, filter *model.NodeFilter, order *model.NodeOrder, first *int, offset *int) int
		RolesAggregate func(childComplexity int, filter *model.NodeFilter) int
		Rootnameid     func(childComplexity int) int
	}

	RoleExtAggregateResult struct {
		AboutMax      func(childComplexity int) int
		AboutMin      func(childComplexity int) int
		ColorMax      func(childComplexity int) int
		ColorMin      func(childComplexity int) int
		Count         func(childComplexity int) int
		NameMax       func(childComplexity int) int
		NameMin       func(childComplexity int) int
		RootnameidMax func(childComplexity int) int
		RootnameidMin func(childComplexity int) int
	}

	Tension struct {
		Action                   func(childComplexity int) int
		Assignees                func(childComplexity int, filter *model.UserFilter, order *model.UserOrder, first *int, offset *int) int
		AssigneesAggregate       func(childComplexity int, filter *model.UserFilter) int
		Blobs                    func(childComplexity int, filter *model.BlobFilter, order *model.BlobOrder, first *int, offset *int) int
		BlobsAggregate           func(childComplexity int, filter *model.BlobFilter) int
		Comments                 func(childComplexity int, filter *model.CommentFilter, order *model.CommentOrder, first *int, offset *int) int
		CommentsAggregate        func(childComplexity int, filter *model.CommentFilter) int
		Contracts                func(childComplexity int, filter *model.ContractFilter, order *model.ContractOrder, first *int, offset *int) int
		ContractsAggregate       func(childComplexity int, filter *model.ContractFilter) int
		CreatedAt                func(childComplexity int) int
		CreatedBy                func(childComplexity int, filter *model.UserFilter) int
		Emitter                  func(childComplexity int, filter *model.NodeFilter) int
		Emitterid                func(childComplexity int) int
		History                  func(childComplexity int, filter *model.EventFilter, order *model.EventOrder, first *int, offset *int) int
		HistoryAggregate         func(childComplexity int, filter *model.EventFilter) int
		ID                       func(childComplexity int) int
		Labels                   func(childComplexity int, filter *model.LabelFilter, order *model.LabelOrder, first *int, offset *int) int
		LabelsAggregate          func(childComplexity int, filter *model.LabelFilter) int
		Mentions                 func(childComplexity int, filter *model.EventFilter, order *model.EventOrder, first *int, offset *int) int
		MentionsAggregate        func(childComplexity int, filter *model.EventFilter) int
		Message                  func(childComplexity int) int
		NComments                func(childComplexity int) int
		ProjectStatuses          func(childComplexity int, filter *model.ProjectColumnFilter, order *model.ProjectColumnOrder, first *int, offset *int) int
		ProjectStatusesAggregate func(childComplexity int, filter *model.ProjectColumnFilter) int
		Receiver                 func(childComplexity int, filter *model.NodeFilter) int
		Receiverid               func(childComplexity int) int
		Status                   func(childComplexity int) int
		Subscribers              func(childComplexity int, filter *model.UserFilter, order *model.UserOrder, first *int, offset *int) int
		SubscribersAggregate     func(childComplexity int, filter *model.UserFilter) int
		Title                    func(childComplexity int) int
		Type                     func(childComplexity int) int
		UpdatedAt                func(childComplexity int) int
	}

	TensionAggregateResult struct {
		Count         func(childComplexity int) int
		CreatedAtMax  func(childComplexity int) int
		CreatedAtMin  func(childComplexity int) int
		EmitteridMax  func(childComplexity int) int
		EmitteridMin  func(childComplexity int) int
		MessageMax    func(childComplexity int) int
		MessageMin    func(childComplexity int) int
		NCommentsAvg  func(childComplexity int) int
		NCommentsMax  func(childComplexity int) int
		NCommentsMin  func(childComplexity int) int
		NCommentsSum  func(childComplexity int) int
		ReceiveridMax func(childComplexity int) int
		ReceiveridMin func(childComplexity int) int
		TitleMax      func(childComplexity int) int
		TitleMin      func(childComplexity int) int
		UpdatedAtMax  func(childComplexity int) int
		UpdatedAtMin  func(childComplexity int) int
	}

	UpdateBlobPayload struct {
		Blob    func(childComplexity int, filter *model.BlobFilter, order *model.BlobOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	UpdateCommentPayload struct {
		Comment func(childComplexity int, filter *model.CommentFilter, order *model.CommentOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	UpdateContractPayload struct {
		Contract func(childComplexity int, filter *model.ContractFilter, order *model.ContractOrder, first *int, offset *int) int
		NumUids  func(childComplexity int) int
	}

	UpdateEventCountPayload struct {
		EventCount func(childComplexity int, filter *model.EventCountFilter, order *model.EventCountOrder, first *int, offset *int) int
		NumUids    func(childComplexity int) int
	}

	UpdateEventFragmentPayload struct {
		EventFragment func(childComplexity int, filter *model.EventFragmentFilter, order *model.EventFragmentOrder, first *int, offset *int) int
		NumUids       func(childComplexity int) int
	}

	UpdateEventPayload struct {
		Event   func(childComplexity int, filter *model.EventFilter, order *model.EventOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	UpdateLabelPayload struct {
		Label   func(childComplexity int, filter *model.LabelFilter, order *model.LabelOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	UpdateMandatePayload struct {
		Mandate func(childComplexity int, filter *model.MandateFilter, order *model.MandateOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	UpdateNodeFragmentPayload struct {
		NodeFragment func(childComplexity int, filter *model.NodeFragmentFilter, order *model.NodeFragmentOrder, first *int, offset *int) int
		NumUids      func(childComplexity int) int
	}

	UpdateNodePayload struct {
		Node    func(childComplexity int, filter *model.NodeFilter, order *model.NodeOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	UpdateNotifPayload struct {
		Notif   func(childComplexity int, filter *model.NotifFilter, order *model.NotifOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	UpdatePendingUserPayload struct {
		NumUids     func(childComplexity int) int
		PendingUser func(childComplexity int, filter *model.PendingUserFilter, order *model.PendingUserOrder, first *int, offset *int) int
	}

	UpdatePostPayload struct {
		NumUids func(childComplexity int) int
		Post    func(childComplexity int, filter *model.PostFilter, order *model.PostOrder, first *int, offset *int) int
	}

	UpdateProjectCardPayload struct {
		NumUids     func(childComplexity int) int
		ProjectCard func(childComplexity int, filter *model.ProjectCardFilter, order *model.ProjectCardOrder, first *int, offset *int) int
	}

	UpdateProjectColumnPayload struct {
		NumUids       func(childComplexity int) int
		ProjectColumn func(childComplexity int, filter *model.ProjectColumnFilter, order *model.ProjectColumnOrder, first *int, offset *int) int
	}

	UpdateProjectDraftPayload struct {
		NumUids      func(childComplexity int) int
		ProjectDraft func(childComplexity int, filter *model.ProjectDraftFilter, order *model.ProjectDraftOrder, first *int, offset *int) int
	}

	UpdateProjectFieldPayload struct {
		NumUids      func(childComplexity int) int
		ProjectField func(childComplexity int, filter *model.ProjectFieldFilter, first *int, offset *int) int
	}

	UpdateProjectFieldValuePayload struct {
		NumUids           func(childComplexity int) int
		ProjectFieldValue func(childComplexity int, filter *model.ProjectFieldValueFilter, order *model.ProjectFieldValueOrder, first *int, offset *int) int
	}

	UpdateProjectPayload struct {
		NumUids func(childComplexity int) int
		Project func(childComplexity int, filter *model.ProjectFilter, order *model.ProjectOrder, first *int, offset *int) int
	}

	UpdateReactionPayload struct {
		NumUids  func(childComplexity int) int
		Reaction func(childComplexity int, filter *model.ReactionFilter, order *model.ReactionOrder, first *int, offset *int) int
	}

	UpdateRoleExtPayload struct {
		NumUids func(childComplexity int) int
		RoleExt func(childComplexity int, filter *model.RoleExtFilter, order *model.RoleExtOrder, first *int, offset *int) int
	}

	UpdateTensionPayload struct {
		NumUids func(childComplexity int) int
		Tension func(childComplexity int, filter *model.TensionFilter, order *model.TensionOrder, first *int, offset *int) int
	}

	UpdateUserEventPayload struct {
		NumUids   func(childComplexity int) int
		UserEvent func(childComplexity int, filter *model.UserEventFilter, order *model.UserEventOrder, first *int, offset *int) int
	}

	UpdateUserPayload struct {
		NumUids func(childComplexity int) int
		User    func(childComplexity int, filter *model.UserFilter, order *model.UserOrder, first *int, offset *int) int
	}

	UpdateUserRightsPayload struct {
		NumUids    func(childComplexity int) int
		UserRights func(childComplexity int, filter *model.UserRightsFilter, order *model.UserRightsOrder, first *int, offset *int) int
	}

	UpdateVotePayload struct {
		NumUids func(childComplexity int) int
		Vote    func(childComplexity int, filter *model.VoteFilter, order *model.VoteOrder, first *int, offset *int) int
	}

	User struct {
		Bio                       func(childComplexity int) int
		Contracts                 func(childComplexity int, filter *model.ContractFilter, order *model.ContractOrder, first *int, offset *int) int
		ContractsAggregate        func(childComplexity int, filter *model.ContractFilter) int
		CreatedAt                 func(childComplexity int) int
		Email                     func(childComplexity int) int
		EventCount                func(childComplexity int, filter *model.EventCountFilter) int
		Events                    func(childComplexity int, filter *model.UserEventFilter, order *model.UserEventOrder, first *int, offset *int) int
		EventsAggregate           func(childComplexity int, filter *model.UserEventFilter) int
		ID                        func(childComplexity int) int
		Lang                      func(childComplexity int) int
		LastAck                   func(childComplexity int) int
		Links                     func(childComplexity int) int
		Location                  func(childComplexity int) int
		MarkAllAsRead             func(childComplexity int) int
		Name                      func(childComplexity int) int
		NotifyByEmail             func(childComplexity int) int
		Password                  func(childComplexity int) int
		Reactions                 func(childComplexity int, filter *model.ReactionFilter, order *model.ReactionOrder, first *int, offset *int) int
		ReactionsAggregate        func(childComplexity int, filter *model.ReactionFilter) int
		Rights                    func(childComplexity int, filter *model.UserRightsFilter) int
		Roles                     func(childComplexity int, filter *model.NodeFilter, order *model.NodeOrder, first *int, offset *int) int
		RolesAggregate            func(childComplexity int, filter *model.NodeFilter) int
		Skills                    func(childComplexity int) int
		Subscriptions             func(childComplexity int, filter *model.TensionFilter, order *model.TensionOrder, first *int, offset *int) int
		SubscriptionsAggregate    func(childComplexity int, filter *model.TensionFilter) int
		TensionsAssigned          func(childComplexity int, filter *model.TensionFilter, order *model.TensionOrder, first *int, offset *int) int
		TensionsAssignedAggregate func(childComplexity int, filter *model.TensionFilter) int
		TensionsCreated           func(childComplexity int, filter *model.TensionFilter, order *model.TensionOrder, first *int, offset *int) int
		TensionsCreatedAggregate  func(childComplexity int, filter *model.TensionFilter) int
		Username                  func(childComplexity int) int
		Utc                       func(childComplexity int) int
		Watching                  func(childComplexity int, filter *model.NodeFilter, order *model.NodeOrder, first *int, offset *int) int
		WatchingAggregate         func(childComplexity int, filter *model.NodeFilter) int
	}

	UserAggregateResult struct {
		BioMax           func(childComplexity int) int
		BioMin           func(childComplexity int) int
		Count            func(childComplexity int) int
		CreatedAtMax     func(childComplexity int) int
		CreatedAtMin     func(childComplexity int) int
		EmailMax         func(childComplexity int) int
		EmailMin         func(childComplexity int) int
		LastAckMax       func(childComplexity int) int
		LastAckMin       func(childComplexity int) int
		LocationMax      func(childComplexity int) int
		LocationMin      func(childComplexity int) int
		MarkAllAsReadMax func(childComplexity int) int
		MarkAllAsReadMin func(childComplexity int) int
		NameMax          func(childComplexity int) int
		NameMin          func(childComplexity int) int
		PasswordMax      func(childComplexity int) int
		PasswordMin      func(childComplexity int) int
		UsernameMax      func(childComplexity int) int
		UsernameMin      func(childComplexity int) int
		UtcMax           func(childComplexity int) int
		UtcMin           func(childComplexity int) int
	}

	UserEvent struct {
		CreatedAt func(childComplexity int) int
		Event     func(childComplexity int, filter *model.EventKindFilter, first *int, offset *int) int
		ID        func(childComplexity int) int
		IsRead    func(childComplexity int) int
		User      func(childComplexity int, filter *model.UserFilter) int
	}

	UserEventAggregateResult struct {
		Count        func(childComplexity int) int
		CreatedAtMax func(childComplexity int) int
		CreatedAtMin func(childComplexity int) int
	}

	UserRights struct {
		CanCreateRoot         func(childComplexity int) int
		CanLogin              func(childComplexity int) int
		HasEmailNotifications func(childComplexity int) int
		MaxPrivateOrga        func(childComplexity int) int
		MaxPublicOrga         func(childComplexity int) int
		Type                  func(childComplexity int) int
	}

	UserRightsAggregateResult struct {
		Count             func(childComplexity int) int
		MaxPrivateOrgaAvg func(childComplexity int) int
		MaxPrivateOrgaMax func(childComplexity int) int
		MaxPrivateOrgaMin func(childComplexity int) int
		MaxPrivateOrgaSum func(childComplexity int) int
		MaxPublicOrgaAvg  func(childComplexity int) int
		MaxPublicOrgaMax  func(childComplexity int) int
		MaxPublicOrgaMin  func(childComplexity int) int
		MaxPublicOrgaSum  func(childComplexity int) int
	}

	Vote struct {
		Contract  func(childComplexity int, filter *model.ContractFilter) int
		CreatedAt func(childComplexity int) int
		CreatedBy func(childComplexity int, filter *model.UserFilter) int
		Data      func(childComplexity int) int
		ID        func(childComplexity int) int
		Message   func(childComplexity int) int
		Node      func(childComplexity int, filter *model.NodeFilter) int
		UpdatedAt func(childComplexity int) int
		Voteid    func(childComplexity int) int
	}

	VoteAggregateResult struct {
		Count        func(childComplexity int) int
		CreatedAtMax func(childComplexity int) int
		CreatedAtMin func(childComplexity int) int
		MessageMax   func(childComplexity int) int
		MessageMin   func(childComplexity int) int
		UpdatedAtMax func(childComplexity int) int
		UpdatedAtMin func(childComplexity int) int
		VoteidMax    func(childComplexity int) int
		VoteidMin    func(childComplexity int) int
	}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "AddBlobPayload.blob":
		if e.complexity.AddBlobPayload.Blob == nil {
			break
		}

		args, err := ec.field_AddBlobPayload_blob_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddBlobPayload.Blob(childComplexity, args["filter"].(*model.BlobFilter), args["order"].(*model.BlobOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddBlobPayload.numUids":
		if e.complexity.AddBlobPayload.NumUids == nil {
			break
		}

		return e.complexity.AddBlobPayload.NumUids(childComplexity), true

	case "AddCommentPayload.comment":
		if e.complexity.AddCommentPayload.Comment == nil {
			break
		}

		args, err := ec.field_AddCommentPayload_comment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddCommentPayload.Comment(childComplexity, args["filter"].(*model.CommentFilter), args["order"].(*model.CommentOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddCommentPayload.numUids":
		if e.complexity.AddCommentPayload.NumUids == nil {
			break
		}

		return e.complexity.AddCommentPayload.NumUids(childComplexity), true

	case "AddContractPayload.contract":
		if e.complexity.AddContractPayload.Contract == nil {
			break
		}

		args, err := ec.field_AddContractPayload_contract_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddContractPayload.Contract(childComplexity, args["filter"].(*model.ContractFilter), args["order"].(*model.ContractOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddContractPayload.numUids":
		if e.complexity.AddContractPayload.NumUids == nil {
			break
		}

		return e.complexity.AddContractPayload.NumUids(childComplexity), true

	case "AddEventCountPayload.eventCount":
		if e.complexity.AddEventCountPayload.EventCount == nil {
			break
		}

		args, err := ec.field_AddEventCountPayload_eventCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddEventCountPayload.EventCount(childComplexity, args["filter"].(*model.EventCountFilter), args["order"].(*model.EventCountOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddEventCountPayload.numUids":
		if e.complexity.AddEventCountPayload.NumUids == nil {
			break
		}

		return e.complexity.AddEventCountPayload.NumUids(childComplexity), true

	case "AddEventFragmentPayload.eventFragment":
		if e.complexity.AddEventFragmentPayload.EventFragment == nil {
			break
		}

		args, err := ec.field_AddEventFragmentPayload_eventFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddEventFragmentPayload.EventFragment(childComplexity, args["filter"].(*model.EventFragmentFilter), args["order"].(*model.EventFragmentOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddEventFragmentPayload.numUids":
		if e.complexity.AddEventFragmentPayload.NumUids == nil {
			break
		}

		return e.complexity.AddEventFragmentPayload.NumUids(childComplexity), true

	case "AddEventPayload.event":
		if e.complexity.AddEventPayload.Event == nil {
			break
		}

		args, err := ec.field_AddEventPayload_event_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddEventPayload.Event(childComplexity, args["filter"].(*model.EventFilter), args["order"].(*model.EventOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddEventPayload.numUids":
		if e.complexity.AddEventPayload.NumUids == nil {
			break
		}

		return e.complexity.AddEventPayload.NumUids(childComplexity), true

	case "AddLabelPayload.label":
		if e.complexity.AddLabelPayload.Label == nil {
			break
		}

		args, err := ec.field_AddLabelPayload_label_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddLabelPayload.Label(childComplexity, args["filter"].(*model.LabelFilter), args["order"].(*model.LabelOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddLabelPayload.numUids":
		if e.complexity.AddLabelPayload.NumUids == nil {
			break
		}

		return e.complexity.AddLabelPayload.NumUids(childComplexity), true

	case "AddMandatePayload.mandate":
		if e.complexity.AddMandatePayload.Mandate == nil {
			break
		}

		args, err := ec.field_AddMandatePayload_mandate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddMandatePayload.Mandate(childComplexity, args["filter"].(*model.MandateFilter), args["order"].(*model.MandateOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddMandatePayload.numUids":
		if e.complexity.AddMandatePayload.NumUids == nil {
			break
		}

		return e.complexity.AddMandatePayload.NumUids(childComplexity), true

	case "AddNodeFragmentPayload.nodeFragment":
		if e.complexity.AddNodeFragmentPayload.NodeFragment == nil {
			break
		}

		args, err := ec.field_AddNodeFragmentPayload_nodeFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddNodeFragmentPayload.NodeFragment(childComplexity, args["filter"].(*model.NodeFragmentFilter), args["order"].(*model.NodeFragmentOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddNodeFragmentPayload.numUids":
		if e.complexity.AddNodeFragmentPayload.NumUids == nil {
			break
		}

		return e.complexity.AddNodeFragmentPayload.NumUids(childComplexity), true

	case "AddNodePayload.node":
		if e.complexity.AddNodePayload.Node == nil {
			break
		}

		args, err := ec.field_AddNodePayload_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddNodePayload.Node(childComplexity, args["filter"].(*model.NodeFilter), args["order"].(*model.NodeOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddNodePayload.numUids":
		if e.complexity.AddNodePayload.NumUids == nil {
			break
		}

		return e.complexity.AddNodePayload.NumUids(childComplexity), true

	case "AddNotifPayload.notif":
		if e.complexity.AddNotifPayload.Notif == nil {
			break
		}

		args, err := ec.field_AddNotifPayload_notif_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddNotifPayload.Notif(childComplexity, args["filter"].(*model.NotifFilter), args["order"].(*model.NotifOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddNotifPayload.numUids":
		if e.complexity.AddNotifPayload.NumUids == nil {
			break
		}

		return e.complexity.AddNotifPayload.NumUids(childComplexity), true

	case "AddPendingUserPayload.numUids":
		if e.complexity.AddPendingUserPayload.NumUids == nil {
			break
		}

		return e.complexity.AddPendingUserPayload.NumUids(childComplexity), true

	case "AddPendingUserPayload.pendingUser":
		if e.complexity.AddPendingUserPayload.PendingUser == nil {
			break
		}

		args, err := ec.field_AddPendingUserPayload_pendingUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddPendingUserPayload.PendingUser(childComplexity, args["filter"].(*model.PendingUserFilter), args["order"].(*model.PendingUserOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddProjectCardPayload.numUids":
		if e.complexity.AddProjectCardPayload.NumUids == nil {
			break
		}

		return e.complexity.AddProjectCardPayload.NumUids(childComplexity), true

	case "AddProjectCardPayload.projectCard":
		if e.complexity.AddProjectCardPayload.ProjectCard == nil {
			break
		}

		args, err := ec.field_AddProjectCardPayload_projectCard_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddProjectCardPayload.ProjectCard(childComplexity, args["filter"].(*model.ProjectCardFilter), args["order"].(*model.ProjectCardOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddProjectColumnPayload.numUids":
		if e.complexity.AddProjectColumnPayload.NumUids == nil {
			break
		}

		return e.complexity.AddProjectColumnPayload.NumUids(childComplexity), true

	case "AddProjectColumnPayload.projectColumn":
		if e.complexity.AddProjectColumnPayload.ProjectColumn == nil {
			break
		}

		args, err := ec.field_AddProjectColumnPayload_projectColumn_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddProjectColumnPayload.ProjectColumn(childComplexity, args["filter"].(*model.ProjectColumnFilter), args["order"].(*model.ProjectColumnOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddProjectDraftPayload.numUids":
		if e.complexity.AddProjectDraftPayload.NumUids == nil {
			break
		}

		return e.complexity.AddProjectDraftPayload.NumUids(childComplexity), true

	case "AddProjectDraftPayload.projectDraft":
		if e.complexity.AddProjectDraftPayload.ProjectDraft == nil {
			break
		}

		args, err := ec.field_AddProjectDraftPayload_projectDraft_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddProjectDraftPayload.ProjectDraft(childComplexity, args["filter"].(*model.ProjectDraftFilter), args["order"].(*model.ProjectDraftOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddProjectFieldPayload.numUids":
		if e.complexity.AddProjectFieldPayload.NumUids == nil {
			break
		}

		return e.complexity.AddProjectFieldPayload.NumUids(childComplexity), true

	case "AddProjectFieldPayload.projectField":
		if e.complexity.AddProjectFieldPayload.ProjectField == nil {
			break
		}

		args, err := ec.field_AddProjectFieldPayload_projectField_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddProjectFieldPayload.ProjectField(childComplexity, args["filter"].(*model.ProjectFieldFilter), args["first"].(*int), args["offset"].(*int)), true

	case "AddProjectFieldValuePayload.numUids":
		if e.complexity.AddProjectFieldValuePayload.NumUids == nil {
			break
		}

		return e.complexity.AddProjectFieldValuePayload.NumUids(childComplexity), true

	case "AddProjectFieldValuePayload.projectFieldValue":
		if e.complexity.AddProjectFieldValuePayload.ProjectFieldValue == nil {
			break
		}

		args, err := ec.field_AddProjectFieldValuePayload_projectFieldValue_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddProjectFieldValuePayload.ProjectFieldValue(childComplexity, args["filter"].(*model.ProjectFieldValueFilter), args["order"].(*model.ProjectFieldValueOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddProjectPayload.numUids":
		if e.complexity.AddProjectPayload.NumUids == nil {
			break
		}

		return e.complexity.AddProjectPayload.NumUids(childComplexity), true

	case "AddProjectPayload.project":
		if e.complexity.AddProjectPayload.Project == nil {
			break
		}

		args, err := ec.field_AddProjectPayload_project_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddProjectPayload.Project(childComplexity, args["filter"].(*model.ProjectFilter), args["order"].(*model.ProjectOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddReactionPayload.numUids":
		if e.complexity.AddReactionPayload.NumUids == nil {
			break
		}

		return e.complexity.AddReactionPayload.NumUids(childComplexity), true

	case "AddReactionPayload.reaction":
		if e.complexity.AddReactionPayload.Reaction == nil {
			break
		}

		args, err := ec.field_AddReactionPayload_reaction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddReactionPayload.Reaction(childComplexity, args["filter"].(*model.ReactionFilter), args["order"].(*model.ReactionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddRoleExtPayload.numUids":
		if e.complexity.AddRoleExtPayload.NumUids == nil {
			break
		}

		return e.complexity.AddRoleExtPayload.NumUids(childComplexity), true

	case "AddRoleExtPayload.roleExt":
		if e.complexity.AddRoleExtPayload.RoleExt == nil {
			break
		}

		args, err := ec.field_AddRoleExtPayload_roleExt_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddRoleExtPayload.RoleExt(childComplexity, args["filter"].(*model.RoleExtFilter), args["order"].(*model.RoleExtOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddTensionPayload.numUids":
		if e.complexity.AddTensionPayload.NumUids == nil {
			break
		}

		return e.complexity.AddTensionPayload.NumUids(childComplexity), true

	case "AddTensionPayload.tension":
		if e.complexity.AddTensionPayload.Tension == nil {
			break
		}

		args, err := ec.field_AddTensionPayload_tension_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddTensionPayload.Tension(childComplexity, args["filter"].(*model.TensionFilter), args["order"].(*model.TensionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddUserEventPayload.numUids":
		if e.complexity.AddUserEventPayload.NumUids == nil {
			break
		}

		return e.complexity.AddUserEventPayload.NumUids(childComplexity), true

	case "AddUserEventPayload.userEvent":
		if e.complexity.AddUserEventPayload.UserEvent == nil {
			break
		}

		args, err := ec.field_AddUserEventPayload_userEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddUserEventPayload.UserEvent(childComplexity, args["filter"].(*model.UserEventFilter), args["order"].(*model.UserEventOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddUserPayload.numUids":
		if e.complexity.AddUserPayload.NumUids == nil {
			break
		}

		return e.complexity.AddUserPayload.NumUids(childComplexity), true

	case "AddUserPayload.user":
		if e.complexity.AddUserPayload.User == nil {
			break
		}

		args, err := ec.field_AddUserPayload_user_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddUserPayload.User(childComplexity, args["filter"].(*model.UserFilter), args["order"].(*model.UserOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddUserRightsPayload.numUids":
		if e.complexity.AddUserRightsPayload.NumUids == nil {
			break
		}

		return e.complexity.AddUserRightsPayload.NumUids(childComplexity), true

	case "AddUserRightsPayload.userRights":
		if e.complexity.AddUserRightsPayload.UserRights == nil {
			break
		}

		args, err := ec.field_AddUserRightsPayload_userRights_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddUserRightsPayload.UserRights(childComplexity, args["filter"].(*model.UserRightsFilter), args["order"].(*model.UserRightsOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddVotePayload.numUids":
		if e.complexity.AddVotePayload.NumUids == nil {
			break
		}

		return e.complexity.AddVotePayload.NumUids(childComplexity), true

	case "AddVotePayload.vote":
		if e.complexity.AddVotePayload.Vote == nil {
			break
		}

		args, err := ec.field_AddVotePayload_vote_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddVotePayload.Vote(childComplexity, args["filter"].(*model.VoteFilter), args["order"].(*model.VoteOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Blob.archivedFlag":
		if e.complexity.Blob.ArchivedFlag == nil {
			break
		}

		return e.complexity.Blob.ArchivedFlag(childComplexity), true

	case "Blob.blob_type":
		if e.complexity.Blob.BlobType == nil {
			break
		}

		return e.complexity.Blob.BlobType(childComplexity), true

	case "Blob.createdAt":
		if e.complexity.Blob.CreatedAt == nil {
			break
		}

		return e.complexity.Blob.CreatedAt(childComplexity), true

	case "Blob.createdBy":
		if e.complexity.Blob.CreatedBy == nil {
			break
		}

		args, err := ec.field_Blob_createdBy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Blob.CreatedBy(childComplexity, args["filter"].(*model.UserFilter)), true

	case "Blob.id":
		if e.complexity.Blob.ID == nil {
			break
		}

		return e.complexity.Blob.ID(childComplexity), true

	case "Blob.md":
		if e.complexity.Blob.Md == nil {
			break
		}

		return e.complexity.Blob.Md(childComplexity), true

	case "Blob.message":
		if e.complexity.Blob.Message == nil {
			break
		}

		return e.complexity.Blob.Message(childComplexity), true

	case "Blob.node":
		if e.complexity.Blob.Node == nil {
			break
		}

		args, err := ec.field_Blob_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Blob.Node(childComplexity, args["filter"].(*model.NodeFragmentFilter)), true

	case "Blob.pushedFlag":
		if e.complexity.Blob.PushedFlag == nil {
			break
		}

		return e.complexity.Blob.PushedFlag(childComplexity), true

	case "Blob.tension":
		if e.complexity.Blob.Tension == nil {
			break
		}

		args, err := ec.field_Blob_tension_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Blob.Tension(childComplexity, args["filter"].(*model.TensionFilter)), true

	case "Blob.updatedAt":
		if e.complexity.Blob.UpdatedAt == nil {
			break
		}

		return e.complexity.Blob.UpdatedAt(childComplexity), true

	case "BlobAggregateResult.archivedFlagMax":
		if e.complexity.BlobAggregateResult.ArchivedFlagMax == nil {
			break
		}

		return e.complexity.BlobAggregateResult.ArchivedFlagMax(childComplexity), true

	case "BlobAggregateResult.archivedFlagMin":
		if e.complexity.BlobAggregateResult.ArchivedFlagMin == nil {
			break
		}

		return e.complexity.BlobAggregateResult.ArchivedFlagMin(childComplexity), true

	case "BlobAggregateResult.count":
		if e.complexity.BlobAggregateResult.Count == nil {
			break
		}

		return e.complexity.BlobAggregateResult.Count(childComplexity), true

	case "BlobAggregateResult.createdAtMax":
		if e.complexity.BlobAggregateResult.CreatedAtMax == nil {
			break
		}

		return e.complexity.BlobAggregateResult.CreatedAtMax(childComplexity), true

	case "BlobAggregateResult.createdAtMin":
		if e.complexity.BlobAggregateResult.CreatedAtMin == nil {
			break
		}

		return e.complexity.BlobAggregateResult.CreatedAtMin(childComplexity), true

	case "BlobAggregateResult.mdMax":
		if e.complexity.BlobAggregateResult.MdMax == nil {
			break
		}

		return e.complexity.BlobAggregateResult.MdMax(childComplexity), true

	case "BlobAggregateResult.mdMin":
		if e.complexity.BlobAggregateResult.MdMin == nil {
			break
		}

		return e.complexity.BlobAggregateResult.MdMin(childComplexity), true

	case "BlobAggregateResult.messageMax":
		if e.complexity.BlobAggregateResult.MessageMax == nil {
			break
		}

		return e.complexity.BlobAggregateResult.MessageMax(childComplexity), true

	case "BlobAggregateResult.messageMin":
		if e.complexity.BlobAggregateResult.MessageMin == nil {
			break
		}

		return e.complexity.BlobAggregateResult.MessageMin(childComplexity), true

	case "BlobAggregateResult.pushedFlagMax":
		if e.complexity.BlobAggregateResult.PushedFlagMax == nil {
			break
		}

		return e.complexity.BlobAggregateResult.PushedFlagMax(childComplexity), true

	case "BlobAggregateResult.pushedFlagMin":
		if e.complexity.BlobAggregateResult.PushedFlagMin == nil {
			break
		}

		return e.complexity.BlobAggregateResult.PushedFlagMin(childComplexity), true

	case "BlobAggregateResult.updatedAtMax":
		if e.complexity.BlobAggregateResult.UpdatedAtMax == nil {
			break
		}

		return e.complexity.BlobAggregateResult.UpdatedAtMax(childComplexity), true

	case "BlobAggregateResult.updatedAtMin":
		if e.complexity.BlobAggregateResult.UpdatedAtMin == nil {
			break
		}

		return e.complexity.BlobAggregateResult.UpdatedAtMin(childComplexity), true

	case "Comment.createdAt":
		if e.complexity.Comment.CreatedAt == nil {
			break
		}

		return e.complexity.Comment.CreatedAt(childComplexity), true

	case "Comment.createdBy":
		if e.complexity.Comment.CreatedBy == nil {
			break
		}

		args, err := ec.field_Comment_createdBy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Comment.CreatedBy(childComplexity, args["filter"].(*model.UserFilter)), true

	case "Comment.id":
		if e.complexity.Comment.ID == nil {
			break
		}

		return e.complexity.Comment.ID(childComplexity), true

	case "Comment.message":
		if e.complexity.Comment.Message == nil {
			break
		}

		return e.complexity.Comment.Message(childComplexity), true

	case "Comment.reactions":
		if e.complexity.Comment.Reactions == nil {
			break
		}

		args, err := ec.field_Comment_reactions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Comment.Reactions(childComplexity, args["filter"].(*model.ReactionFilter), args["order"].(*model.ReactionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Comment.reactionsAggregate":
		if e.complexity.Comment.ReactionsAggregate == nil {
			break
		}

		args, err := ec.field_Comment_reactionsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Comment.ReactionsAggregate(childComplexity, args["filter"].(*model.ReactionFilter)), true

	case "Comment.updatedAt":
		if e.complexity.Comment.UpdatedAt == nil {
			break
		}

		return e.complexity.Comment.UpdatedAt(childComplexity), true

	case "CommentAggregateResult.count":
		if e.complexity.CommentAggregateResult.Count == nil {
			break
		}

		return e.complexity.CommentAggregateResult.Count(childComplexity), true

	case "CommentAggregateResult.createdAtMax":
		if e.complexity.CommentAggregateResult.CreatedAtMax == nil {
			break
		}

		return e.complexity.CommentAggregateResult.CreatedAtMax(childComplexity), true

	case "CommentAggregateResult.createdAtMin":
		if e.complexity.CommentAggregateResult.CreatedAtMin == nil {
			break
		}

		return e.complexity.CommentAggregateResult.CreatedAtMin(childComplexity), true

	case "CommentAggregateResult.messageMax":
		if e.complexity.CommentAggregateResult.MessageMax == nil {
			break
		}

		return e.complexity.CommentAggregateResult.MessageMax(childComplexity), true

	case "CommentAggregateResult.messageMin":
		if e.complexity.CommentAggregateResult.MessageMin == nil {
			break
		}

		return e.complexity.CommentAggregateResult.MessageMin(childComplexity), true

	case "CommentAggregateResult.updatedAtMax":
		if e.complexity.CommentAggregateResult.UpdatedAtMax == nil {
			break
		}

		return e.complexity.CommentAggregateResult.UpdatedAtMax(childComplexity), true

	case "CommentAggregateResult.updatedAtMin":
		if e.complexity.CommentAggregateResult.UpdatedAtMin == nil {
			break
		}

		return e.complexity.CommentAggregateResult.UpdatedAtMin(childComplexity), true

	case "Contract.candidates":
		if e.complexity.Contract.Candidates == nil {
			break
		}

		args, err := ec.field_Contract_candidates_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Contract.Candidates(childComplexity, args["filter"].(*model.UserFilter), args["order"].(*model.UserOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Contract.candidatesAggregate":
		if e.complexity.Contract.CandidatesAggregate == nil {
			break
		}

		args, err := ec.field_Contract_candidatesAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Contract.CandidatesAggregate(childComplexity, args["filter"].(*model.UserFilter)), true

	case "Contract.closedAt":
		if e.complexity.Contract.ClosedAt == nil {
			break
		}

		return e.complexity.Contract.ClosedAt(childComplexity), true

	case "Contract.comments":
		if e.complexity.Contract.Comments == nil {
			break
		}

		args, err := ec.field_Contract_comments_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Contract.Comments(childComplexity, args["filter"].(*model.CommentFilter), args["order"].(*model.CommentOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Contract.commentsAggregate":
		if e.complexity.Contract.CommentsAggregate == nil {
			break
		}

		args, err := ec.field_Contract_commentsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Contract.CommentsAggregate(childComplexity, args["filter"].(*model.CommentFilter)), true

	case "Contract.contract_type":
		if e.complexity.Contract.ContractType == nil {
			break
		}

		return e.complexity.Contract.ContractType(childComplexity), true

	case "Contract.contractid":
		if e.complexity.Contract.Contractid == nil {
			break
		}

		return e.complexity.Contract.Contractid(childComplexity), true

	case "Contract.createdAt":
		if e.complexity.Contract.CreatedAt == nil {
			break
		}

		return e.complexity.Contract.CreatedAt(childComplexity), true

	case "Contract.createdBy":
		if e.complexity.Contract.CreatedBy == nil {
			break
		}

		args, err := ec.field_Contract_createdBy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Contract.CreatedBy(childComplexity, args["filter"].(*model.UserFilter)), true

	case "Contract.event":
		if e.complexity.Contract.Event == nil {
			break
		}

		args, err := ec.field_Contract_event_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Contract.Event(childComplexity, args["filter"].(*model.EventFragmentFilter)), true

	case "Contract.id":
		if e.complexity.Contract.ID == nil {
			break
		}

		return e.complexity.Contract.ID(childComplexity), true

	case "Contract.isValidator":
		if e.complexity.Contract.IsValidator == nil {
			break
		}

		return e.complexity.Contract.IsValidator(childComplexity), true

	case "Contract.message":
		if e.complexity.Contract.Message == nil {
			break
		}

		return e.complexity.Contract.Message(childComplexity), true

	case "Contract.participants":
		if e.complexity.Contract.Participants == nil {
			break
		}

		args, err := ec.field_Contract_participants_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Contract.Participants(childComplexity, args["filter"].(*model.VoteFilter), args["order"].(*model.VoteOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Contract.participantsAggregate":
		if e.complexity.Contract.ParticipantsAggregate == nil {
			break
		}

		args, err := ec.field_Contract_participantsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Contract.ParticipantsAggregate(childComplexity, args["filter"].(*model.VoteFilter)), true

	case "Contract.pending_candidates":
		if e.complexity.Contract.PendingCandidates == nil {
			break
		}

		args, err := ec.field_Contract_pending_candidates_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Contract.PendingCandidates(childComplexity, args["filter"].(*model.PendingUserFilter), args["order"].(*model.PendingUserOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Contract.pending_candidatesAggregate":
		if e.complexity.Contract.PendingCandidatesAggregate == nil {
			break
		}

		args, err := ec.field_Contract_pending_candidatesAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Contract.PendingCandidatesAggregate(childComplexity, args["filter"].(*model.PendingUserFilter)), true

	case "Contract.status":
		if e.complexity.Contract.Status == nil {
			break
		}

		return e.complexity.Contract.Status(childComplexity), true

	case "Contract.tension":
		if e.complexity.Contract.Tension == nil {
			break
		}

		args, err := ec.field_Contract_tension_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Contract.Tension(childComplexity, args["filter"].(*model.TensionFilter)), true

	case "Contract.updatedAt":
		if e.complexity.Contract.UpdatedAt == nil {
			break
		}

		return e.complexity.Contract.UpdatedAt(childComplexity), true

	case "ContractAggregateResult.closedAtMax":
		if e.complexity.ContractAggregateResult.ClosedAtMax == nil {
			break
		}

		return e.complexity.ContractAggregateResult.ClosedAtMax(childComplexity), true

	case "ContractAggregateResult.closedAtMin":
		if e.complexity.ContractAggregateResult.ClosedAtMin == nil {
			break
		}

		return e.complexity.ContractAggregateResult.ClosedAtMin(childComplexity), true

	case "ContractAggregateResult.contractidMax":
		if e.complexity.ContractAggregateResult.ContractidMax == nil {
			break
		}

		return e.complexity.ContractAggregateResult.ContractidMax(childComplexity), true

	case "ContractAggregateResult.contractidMin":
		if e.complexity.ContractAggregateResult.ContractidMin == nil {
			break
		}

		return e.complexity.ContractAggregateResult.ContractidMin(childComplexity), true

	case "ContractAggregateResult.count":
		if e.complexity.ContractAggregateResult.Count == nil {
			break
		}

		return e.complexity.ContractAggregateResult.Count(childComplexity), true

	case "ContractAggregateResult.createdAtMax":
		if e.complexity.ContractAggregateResult.CreatedAtMax == nil {
			break
		}

		return e.complexity.ContractAggregateResult.CreatedAtMax(childComplexity), true

	case "ContractAggregateResult.createdAtMin":
		if e.complexity.ContractAggregateResult.CreatedAtMin == nil {
			break
		}

		return e.complexity.ContractAggregateResult.CreatedAtMin(childComplexity), true

	case "ContractAggregateResult.messageMax":
		if e.complexity.ContractAggregateResult.MessageMax == nil {
			break
		}

		return e.complexity.ContractAggregateResult.MessageMax(childComplexity), true

	case "ContractAggregateResult.messageMin":
		if e.complexity.ContractAggregateResult.MessageMin == nil {
			break
		}

		return e.complexity.ContractAggregateResult.MessageMin(childComplexity), true

	case "ContractAggregateResult.updatedAtMax":
		if e.complexity.ContractAggregateResult.UpdatedAtMax == nil {
			break
		}

		return e.complexity.ContractAggregateResult.UpdatedAtMax(childComplexity), true

	case "ContractAggregateResult.updatedAtMin":
		if e.complexity.ContractAggregateResult.UpdatedAtMin == nil {
			break
		}

		return e.complexity.ContractAggregateResult.UpdatedAtMin(childComplexity), true

	case "DeleteBlobPayload.blob":
		if e.complexity.DeleteBlobPayload.Blob == nil {
			break
		}

		args, err := ec.field_DeleteBlobPayload_blob_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteBlobPayload.Blob(childComplexity, args["filter"].(*model.BlobFilter), args["order"].(*model.BlobOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteBlobPayload.msg":
		if e.complexity.DeleteBlobPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteBlobPayload.Msg(childComplexity), true

	case "DeleteBlobPayload.numUids":
		if e.complexity.DeleteBlobPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteBlobPayload.NumUids(childComplexity), true

	case "DeleteCommentPayload.comment":
		if e.complexity.DeleteCommentPayload.Comment == nil {
			break
		}

		args, err := ec.field_DeleteCommentPayload_comment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteCommentPayload.Comment(childComplexity, args["filter"].(*model.CommentFilter), args["order"].(*model.CommentOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteCommentPayload.msg":
		if e.complexity.DeleteCommentPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteCommentPayload.Msg(childComplexity), true

	case "DeleteCommentPayload.numUids":
		if e.complexity.DeleteCommentPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteCommentPayload.NumUids(childComplexity), true

	case "DeleteContractPayload.contract":
		if e.complexity.DeleteContractPayload.Contract == nil {
			break
		}

		args, err := ec.field_DeleteContractPayload_contract_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteContractPayload.Contract(childComplexity, args["filter"].(*model.ContractFilter), args["order"].(*model.ContractOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteContractPayload.msg":
		if e.complexity.DeleteContractPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteContractPayload.Msg(childComplexity), true

	case "DeleteContractPayload.numUids":
		if e.complexity.DeleteContractPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteContractPayload.NumUids(childComplexity), true

	case "DeleteEventCountPayload.eventCount":
		if e.complexity.DeleteEventCountPayload.EventCount == nil {
			break
		}

		args, err := ec.field_DeleteEventCountPayload_eventCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteEventCountPayload.EventCount(childComplexity, args["filter"].(*model.EventCountFilter), args["order"].(*model.EventCountOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteEventCountPayload.msg":
		if e.complexity.DeleteEventCountPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteEventCountPayload.Msg(childComplexity), true

	case "DeleteEventCountPayload.numUids":
		if e.complexity.DeleteEventCountPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteEventCountPayload.NumUids(childComplexity), true

	case "DeleteEventFragmentPayload.eventFragment":
		if e.complexity.DeleteEventFragmentPayload.EventFragment == nil {
			break
		}

		args, err := ec.field_DeleteEventFragmentPayload_eventFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteEventFragmentPayload.EventFragment(childComplexity, args["filter"].(*model.EventFragmentFilter), args["order"].(*model.EventFragmentOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteEventFragmentPayload.msg":
		if e.complexity.DeleteEventFragmentPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteEventFragmentPayload.Msg(childComplexity), true

	case "DeleteEventFragmentPayload.numUids":
		if e.complexity.DeleteEventFragmentPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteEventFragmentPayload.NumUids(childComplexity), true

	case "DeleteEventPayload.event":
		if e.complexity.DeleteEventPayload.Event == nil {
			break
		}

		args, err := ec.field_DeleteEventPayload_event_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteEventPayload.Event(childComplexity, args["filter"].(*model.EventFilter), args["order"].(*model.EventOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteEventPayload.msg":
		if e.complexity.DeleteEventPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteEventPayload.Msg(childComplexity), true

	case "DeleteEventPayload.numUids":
		if e.complexity.DeleteEventPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteEventPayload.NumUids(childComplexity), true

	case "DeleteLabelPayload.label":
		if e.complexity.DeleteLabelPayload.Label == nil {
			break
		}

		args, err := ec.field_DeleteLabelPayload_label_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteLabelPayload.Label(childComplexity, args["filter"].(*model.LabelFilter), args["order"].(*model.LabelOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteLabelPayload.msg":
		if e.complexity.DeleteLabelPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteLabelPayload.Msg(childComplexity), true

	case "DeleteLabelPayload.numUids":
		if e.complexity.DeleteLabelPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteLabelPayload.NumUids(childComplexity), true

	case "DeleteMandatePayload.mandate":
		if e.complexity.DeleteMandatePayload.Mandate == nil {
			break
		}

		args, err := ec.field_DeleteMandatePayload_mandate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteMandatePayload.Mandate(childComplexity, args["filter"].(*model.MandateFilter), args["order"].(*model.MandateOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteMandatePayload.msg":
		if e.complexity.DeleteMandatePayload.Msg == nil {
			break
		}

		return e.complexity.DeleteMandatePayload.Msg(childComplexity), true

	case "DeleteMandatePayload.numUids":
		if e.complexity.DeleteMandatePayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteMandatePayload.NumUids(childComplexity), true

	case "DeleteNodeFragmentPayload.msg":
		if e.complexity.DeleteNodeFragmentPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteNodeFragmentPayload.Msg(childComplexity), true

	case "DeleteNodeFragmentPayload.nodeFragment":
		if e.complexity.DeleteNodeFragmentPayload.NodeFragment == nil {
			break
		}

		args, err := ec.field_DeleteNodeFragmentPayload_nodeFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteNodeFragmentPayload.NodeFragment(childComplexity, args["filter"].(*model.NodeFragmentFilter), args["order"].(*model.NodeFragmentOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteNodeFragmentPayload.numUids":
		if e.complexity.DeleteNodeFragmentPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteNodeFragmentPayload.NumUids(childComplexity), true

	case "DeleteNodePayload.msg":
		if e.complexity.DeleteNodePayload.Msg == nil {
			break
		}

		return e.complexity.DeleteNodePayload.Msg(childComplexity), true

	case "DeleteNodePayload.node":
		if e.complexity.DeleteNodePayload.Node == nil {
			break
		}

		args, err := ec.field_DeleteNodePayload_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteNodePayload.Node(childComplexity, args["filter"].(*model.NodeFilter), args["order"].(*model.NodeOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteNodePayload.numUids":
		if e.complexity.DeleteNodePayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteNodePayload.NumUids(childComplexity), true

	case "DeleteNotifPayload.msg":
		if e.complexity.DeleteNotifPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteNotifPayload.Msg(childComplexity), true

	case "DeleteNotifPayload.notif":
		if e.complexity.DeleteNotifPayload.Notif == nil {
			break
		}

		args, err := ec.field_DeleteNotifPayload_notif_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteNotifPayload.Notif(childComplexity, args["filter"].(*model.NotifFilter), args["order"].(*model.NotifOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteNotifPayload.numUids":
		if e.complexity.DeleteNotifPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteNotifPayload.NumUids(childComplexity), true

	case "DeletePendingUserPayload.msg":
		if e.complexity.DeletePendingUserPayload.Msg == nil {
			break
		}

		return e.complexity.DeletePendingUserPayload.Msg(childComplexity), true

	case "DeletePendingUserPayload.numUids":
		if e.complexity.DeletePendingUserPayload.NumUids == nil {
			break
		}

		return e.complexity.DeletePendingUserPayload.NumUids(childComplexity), true

	case "DeletePendingUserPayload.pendingUser":
		if e.complexity.DeletePendingUserPayload.PendingUser == nil {
			break
		}

		args, err := ec.field_DeletePendingUserPayload_pendingUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeletePendingUserPayload.PendingUser(childComplexity, args["filter"].(*model.PendingUserFilter), args["order"].(*model.PendingUserOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeletePostPayload.msg":
		if e.complexity.DeletePostPayload.Msg == nil {
			break
		}

		return e.complexity.DeletePostPayload.Msg(childComplexity), true

	case "DeletePostPayload.numUids":
		if e.complexity.DeletePostPayload.NumUids == nil {
			break
		}

		return e.complexity.DeletePostPayload.NumUids(childComplexity), true

	case "DeletePostPayload.post":
		if e.complexity.DeletePostPayload.Post == nil {
			break
		}

		args, err := ec.field_DeletePostPayload_post_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeletePostPayload.Post(childComplexity, args["filter"].(*model.PostFilter), args["order"].(*model.PostOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteProjectCardPayload.msg":
		if e.complexity.DeleteProjectCardPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteProjectCardPayload.Msg(childComplexity), true

	case "DeleteProjectCardPayload.numUids":
		if e.complexity.DeleteProjectCardPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteProjectCardPayload.NumUids(childComplexity), true

	case "DeleteProjectCardPayload.projectCard":
		if e.complexity.DeleteProjectCardPayload.ProjectCard == nil {
			break
		}

		args, err := ec.field_DeleteProjectCardPayload_projectCard_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteProjectCardPayload.ProjectCard(childComplexity, args["filter"].(*model.ProjectCardFilter), args["order"].(*model.ProjectCardOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteProjectColumnPayload.msg":
		if e.complexity.DeleteProjectColumnPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteProjectColumnPayload.Msg(childComplexity), true

	case "DeleteProjectColumnPayload.numUids":
		if e.complexity.DeleteProjectColumnPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteProjectColumnPayload.NumUids(childComplexity), true

	case "DeleteProjectColumnPayload.projectColumn":
		if e.complexity.DeleteProjectColumnPayload.ProjectColumn == nil {
			break
		}

		args, err := ec.field_DeleteProjectColumnPayload_projectColumn_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteProjectColumnPayload.ProjectColumn(childComplexity, args["filter"].(*model.ProjectColumnFilter), args["order"].(*model.ProjectColumnOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteProjectDraftPayload.msg":
		if e.complexity.DeleteProjectDraftPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteProjectDraftPayload.Msg(childComplexity), true

	case "DeleteProjectDraftPayload.numUids":
		if e.complexity.DeleteProjectDraftPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteProjectDraftPayload.NumUids(childComplexity), true

	case "DeleteProjectDraftPayload.projectDraft":
		if e.complexity.DeleteProjectDraftPayload.ProjectDraft == nil {
			break
		}

		args, err := ec.field_DeleteProjectDraftPayload_projectDraft_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteProjectDraftPayload.ProjectDraft(childComplexity, args["filter"].(*model.ProjectDraftFilter), args["order"].(*model.ProjectDraftOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteProjectFieldPayload.msg":
		if e.complexity.DeleteProjectFieldPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteProjectFieldPayload.Msg(childComplexity), true

	case "DeleteProjectFieldPayload.numUids":
		if e.complexity.DeleteProjectFieldPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteProjectFieldPayload.NumUids(childComplexity), true

	case "DeleteProjectFieldPayload.projectField":
		if e.complexity.DeleteProjectFieldPayload.ProjectField == nil {
			break
		}

		args, err := ec.field_DeleteProjectFieldPayload_projectField_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteProjectFieldPayload.ProjectField(childComplexity, args["filter"].(*model.ProjectFieldFilter), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteProjectFieldValuePayload.msg":
		if e.complexity.DeleteProjectFieldValuePayload.Msg == nil {
			break
		}

		return e.complexity.DeleteProjectFieldValuePayload.Msg(childComplexity), true

	case "DeleteProjectFieldValuePayload.numUids":
		if e.complexity.DeleteProjectFieldValuePayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteProjectFieldValuePayload.NumUids(childComplexity), true

	case "DeleteProjectFieldValuePayload.projectFieldValue":
		if e.complexity.DeleteProjectFieldValuePayload.ProjectFieldValue == nil {
			break
		}

		args, err := ec.field_DeleteProjectFieldValuePayload_projectFieldValue_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteProjectFieldValuePayload.ProjectFieldValue(childComplexity, args["filter"].(*model.ProjectFieldValueFilter), args["order"].(*model.ProjectFieldValueOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteProjectPayload.msg":
		if e.complexity.DeleteProjectPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteProjectPayload.Msg(childComplexity), true

	case "DeleteProjectPayload.numUids":
		if e.complexity.DeleteProjectPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteProjectPayload.NumUids(childComplexity), true

	case "DeleteProjectPayload.project":
		if e.complexity.DeleteProjectPayload.Project == nil {
			break
		}

		args, err := ec.field_DeleteProjectPayload_project_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteProjectPayload.Project(childComplexity, args["filter"].(*model.ProjectFilter), args["order"].(*model.ProjectOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteReactionPayload.msg":
		if e.complexity.DeleteReactionPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteReactionPayload.Msg(childComplexity), true

	case "DeleteReactionPayload.numUids":
		if e.complexity.DeleteReactionPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteReactionPayload.NumUids(childComplexity), true

	case "DeleteReactionPayload.reaction":
		if e.complexity.DeleteReactionPayload.Reaction == nil {
			break
		}

		args, err := ec.field_DeleteReactionPayload_reaction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteReactionPayload.Reaction(childComplexity, args["filter"].(*model.ReactionFilter), args["order"].(*model.ReactionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteRoleExtPayload.msg":
		if e.complexity.DeleteRoleExtPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteRoleExtPayload.Msg(childComplexity), true

	case "DeleteRoleExtPayload.numUids":
		if e.complexity.DeleteRoleExtPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteRoleExtPayload.NumUids(childComplexity), true

	case "DeleteRoleExtPayload.roleExt":
		if e.complexity.DeleteRoleExtPayload.RoleExt == nil {
			break
		}

		args, err := ec.field_DeleteRoleExtPayload_roleExt_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteRoleExtPayload.RoleExt(childComplexity, args["filter"].(*model.RoleExtFilter), args["order"].(*model.RoleExtOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteTensionPayload.msg":
		if e.complexity.DeleteTensionPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteTensionPayload.Msg(childComplexity), true

	case "DeleteTensionPayload.numUids":
		if e.complexity.DeleteTensionPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteTensionPayload.NumUids(childComplexity), true

	case "DeleteTensionPayload.tension":
		if e.complexity.DeleteTensionPayload.Tension == nil {
			break
		}

		args, err := ec.field_DeleteTensionPayload_tension_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteTensionPayload.Tension(childComplexity, args["filter"].(*model.TensionFilter), args["order"].(*model.TensionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteUserEventPayload.msg":
		if e.complexity.DeleteUserEventPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteUserEventPayload.Msg(childComplexity), true

	case "DeleteUserEventPayload.numUids":
		if e.complexity.DeleteUserEventPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteUserEventPayload.NumUids(childComplexity), true

	case "DeleteUserEventPayload.userEvent":
		if e.complexity.DeleteUserEventPayload.UserEvent == nil {
			break
		}

		args, err := ec.field_DeleteUserEventPayload_userEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteUserEventPayload.UserEvent(childComplexity, args["filter"].(*model.UserEventFilter), args["order"].(*model.UserEventOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteUserPayload.msg":
		if e.complexity.DeleteUserPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteUserPayload.Msg(childComplexity), true

	case "DeleteUserPayload.numUids":
		if e.complexity.DeleteUserPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteUserPayload.NumUids(childComplexity), true

	case "DeleteUserPayload.user":
		if e.complexity.DeleteUserPayload.User == nil {
			break
		}

		args, err := ec.field_DeleteUserPayload_user_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteUserPayload.User(childComplexity, args["filter"].(*model.UserFilter), args["order"].(*model.UserOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteUserRightsPayload.msg":
		if e.complexity.DeleteUserRightsPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteUserRightsPayload.Msg(childComplexity), true

	case "DeleteUserRightsPayload.numUids":
		if e.complexity.DeleteUserRightsPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteUserRightsPayload.NumUids(childComplexity), true

	case "DeleteUserRightsPayload.userRights":
		if e.complexity.DeleteUserRightsPayload.UserRights == nil {
			break
		}

		args, err := ec.field_DeleteUserRightsPayload_userRights_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteUserRightsPayload.UserRights(childComplexity, args["filter"].(*model.UserRightsFilter), args["order"].(*model.UserRightsOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteVotePayload.msg":
		if e.complexity.DeleteVotePayload.Msg == nil {
			break
		}

		return e.complexity.DeleteVotePayload.Msg(childComplexity), true

	case "DeleteVotePayload.numUids":
		if e.complexity.DeleteVotePayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteVotePayload.NumUids(childComplexity), true

	case "DeleteVotePayload.vote":
		if e.complexity.DeleteVotePayload.Vote == nil {
			break
		}

		args, err := ec.field_DeleteVotePayload_vote_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteVotePayload.Vote(childComplexity, args["filter"].(*model.VoteFilter), args["order"].(*model.VoteOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Event.createdAt":
		if e.complexity.Event.CreatedAt == nil {
			break
		}

		return e.complexity.Event.CreatedAt(childComplexity), true

	case "Event.createdBy":
		if e.complexity.Event.CreatedBy == nil {
			break
		}

		args, err := ec.field_Event_createdBy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Event.CreatedBy(childComplexity, args["filter"].(*model.UserFilter)), true

	case "Event.event_type":
		if e.complexity.Event.EventType == nil {
			break
		}

		return e.complexity.Event.EventType(childComplexity), true

	case "Event.id":
		if e.complexity.Event.ID == nil {
			break
		}

		return e.complexity.Event.ID(childComplexity), true

	case "Event.mentioned":
		if e.complexity.Event.Mentioned == nil {
			break
		}

		args, err := ec.field_Event_mentioned_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Event.Mentioned(childComplexity, args["filter"].(*model.TensionFilter)), true

	case "Event.message":
		if e.complexity.Event.Message == nil {
			break
		}

		return e.complexity.Event.Message(childComplexity), true

	case "Event.new":
		if e.complexity.Event.New == nil {
			break
		}

		return e.complexity.Event.New(childComplexity), true

	case "Event.old":
		if e.complexity.Event.Old == nil {
			break
		}

		return e.complexity.Event.Old(childComplexity), true

	case "Event.tension":
		if e.complexity.Event.Tension == nil {
			break
		}

		args, err := ec.field_Event_tension_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Event.Tension(childComplexity, args["filter"].(*model.TensionFilter)), true

	case "Event.updatedAt":
		if e.complexity.Event.UpdatedAt == nil {
			break
		}

		return e.complexity.Event.UpdatedAt(childComplexity), true

	case "EventAggregateResult.count":
		if e.complexity.EventAggregateResult.Count == nil {
			break
		}

		return e.complexity.EventAggregateResult.Count(childComplexity), true

	case "EventAggregateResult.createdAtMax":
		if e.complexity.EventAggregateResult.CreatedAtMax == nil {
			break
		}

		return e.complexity.EventAggregateResult.CreatedAtMax(childComplexity), true

	case "EventAggregateResult.createdAtMin":
		if e.complexity.EventAggregateResult.CreatedAtMin == nil {
			break
		}

		return e.complexity.EventAggregateResult.CreatedAtMin(childComplexity), true

	case "EventAggregateResult.messageMax":
		if e.complexity.EventAggregateResult.MessageMax == nil {
			break
		}

		return e.complexity.EventAggregateResult.MessageMax(childComplexity), true

	case "EventAggregateResult.messageMin":
		if e.complexity.EventAggregateResult.MessageMin == nil {
			break
		}

		return e.complexity.EventAggregateResult.MessageMin(childComplexity), true

	case "EventAggregateResult.newMax":
		if e.complexity.EventAggregateResult.NewMax == nil {
			break
		}

		return e.complexity.EventAggregateResult.NewMax(childComplexity), true

	case "EventAggregateResult.newMin":
		if e.complexity.EventAggregateResult.NewMin == nil {
			break
		}

		return e.complexity.EventAggregateResult.NewMin(childComplexity), true

	case "EventAggregateResult.oldMax":
		if e.complexity.EventAggregateResult.OldMax == nil {
			break
		}

		return e.complexity.EventAggregateResult.OldMax(childComplexity), true

	case "EventAggregateResult.oldMin":
		if e.complexity.EventAggregateResult.OldMin == nil {
			break
		}

		return e.complexity.EventAggregateResult.OldMin(childComplexity), true

	case "EventAggregateResult.updatedAtMax":
		if e.complexity.EventAggregateResult.UpdatedAtMax == nil {
			break
		}

		return e.complexity.EventAggregateResult.UpdatedAtMax(childComplexity), true

	case "EventAggregateResult.updatedAtMin":
		if e.complexity.EventAggregateResult.UpdatedAtMin == nil {
			break
		}

		return e.complexity.EventAggregateResult.UpdatedAtMin(childComplexity), true

	case "EventCount.assigned_tensions":
		if e.complexity.EventCount.AssignedTensions == nil {
			break
		}

		return e.complexity.EventCount.AssignedTensions(childComplexity), true

	case "EventCount.pending_contracts":
		if e.complexity.EventCount.PendingContracts == nil {
			break
		}

		return e.complexity.EventCount.PendingContracts(childComplexity), true

	case "EventCount.unread_events":
		if e.complexity.EventCount.UnreadEvents == nil {
			break
		}

		return e.complexity.EventCount.UnreadEvents(childComplexity), true

	case "EventCountAggregateResult.assigned_tensionsAvg":
		if e.complexity.EventCountAggregateResult.AssignedTensionsAvg == nil {
			break
		}

		return e.complexity.EventCountAggregateResult.AssignedTensionsAvg(childComplexity), true

	case "EventCountAggregateResult.assigned_tensionsMax":
		if e.complexity.EventCountAggregateResult.AssignedTensionsMax == nil {
			break
		}

		return e.complexity.EventCountAggregateResult.AssignedTensionsMax(childComplexity), true

	case "EventCountAggregateResult.assigned_tensionsMin":
		if e.complexity.EventCountAggregateResult.AssignedTensionsMin == nil {
			break
		}

		return e.complexity.EventCountAggregateResult.AssignedTensionsMin(childComplexity), true

	case "EventCountAggregateResult.assigned_tensionsSum":
		if e.complexity.EventCountAggregateResult.AssignedTensionsSum == nil {
			break
		}

		return e.complexity.EventCountAggregateResult.AssignedTensionsSum(childComplexity), true

	case "EventCountAggregateResult.count":
		if e.complexity.EventCountAggregateResult.Count == nil {
			break
		}

		return e.complexity.EventCountAggregateResult.Count(childComplexity), true

	case "EventCountAggregateResult.pending_contractsAvg":
		if e.complexity.EventCountAggregateResult.PendingContractsAvg == nil {
			break
		}

		return e.complexity.EventCountAggregateResult.PendingContractsAvg(childComplexity), true

	case "EventCountAggregateResult.pending_contractsMax":
		if e.complexity.EventCountAggregateResult.PendingContractsMax == nil {
			break
		}

		return e.complexity.EventCountAggregateResult.PendingContractsMax(childComplexity), true

	case "EventCountAggregateResult.pending_contractsMin":
		if e.complexity.EventCountAggregateResult.PendingContractsMin == nil {
			break
		}

		return e.complexity.EventCountAggregateResult.PendingContractsMin(childComplexity), true

	case "EventCountAggregateResult.pending_contractsSum":
		if e.complexity.EventCountAggregateResult.PendingContractsSum == nil {
			break
		}

		return e.complexity.EventCountAggregateResult.PendingContractsSum(childComplexity), true

	case "EventCountAggregateResult.unread_eventsAvg":
		if e.complexity.EventCountAggregateResult.UnreadEventsAvg == nil {
			break
		}

		return e.complexity.EventCountAggregateResult.UnreadEventsAvg(childComplexity), true

	case "EventCountAggregateResult.unread_eventsMax":
		if e.complexity.EventCountAggregateResult.UnreadEventsMax == nil {
			break
		}

		return e.complexity.EventCountAggregateResult.UnreadEventsMax(childComplexity), true

	case "EventCountAggregateResult.unread_eventsMin":
		if e.complexity.EventCountAggregateResult.UnreadEventsMin == nil {
			break
		}

		return e.complexity.EventCountAggregateResult.UnreadEventsMin(childComplexity), true

	case "EventCountAggregateResult.unread_eventsSum":
		if e.complexity.EventCountAggregateResult.UnreadEventsSum == nil {
			break
		}

		return e.complexity.EventCountAggregateResult.UnreadEventsSum(childComplexity), true

	case "EventFragment.event_type":
		if e.complexity.EventFragment.EventType == nil {
			break
		}

		return e.complexity.EventFragment.EventType(childComplexity), true

	case "EventFragment.new":
		if e.complexity.EventFragment.New == nil {
			break
		}

		return e.complexity.EventFragment.New(childComplexity), true

	case "EventFragment.old":
		if e.complexity.EventFragment.Old == nil {
			break
		}

		return e.complexity.EventFragment.Old(childComplexity), true

	case "EventFragmentAggregateResult.count":
		if e.complexity.EventFragmentAggregateResult.Count == nil {
			break
		}

		return e.complexity.EventFragmentAggregateResult.Count(childComplexity), true

	case "EventFragmentAggregateResult.newMax":
		if e.complexity.EventFragmentAggregateResult.NewMax == nil {
			break
		}

		return e.complexity.EventFragmentAggregateResult.NewMax(childComplexity), true

	case "EventFragmentAggregateResult.newMin":
		if e.complexity.EventFragmentAggregateResult.NewMin == nil {
			break
		}

		return e.complexity.EventFragmentAggregateResult.NewMin(childComplexity), true

	case "EventFragmentAggregateResult.oldMax":
		if e.complexity.EventFragmentAggregateResult.OldMax == nil {
			break
		}

		return e.complexity.EventFragmentAggregateResult.OldMax(childComplexity), true

	case "EventFragmentAggregateResult.oldMin":
		if e.complexity.EventFragmentAggregateResult.OldMin == nil {
			break
		}

		return e.complexity.EventFragmentAggregateResult.OldMin(childComplexity), true

	case "Label.color":
		if e.complexity.Label.Color == nil {
			break
		}

		return e.complexity.Label.Color(childComplexity), true

	case "Label.description":
		if e.complexity.Label.Description == nil {
			break
		}

		return e.complexity.Label.Description(childComplexity), true

	case "Label.id":
		if e.complexity.Label.ID == nil {
			break
		}

		return e.complexity.Label.ID(childComplexity), true

	case "Label.name":
		if e.complexity.Label.Name == nil {
			break
		}

		return e.complexity.Label.Name(childComplexity), true

	case "Label.nodes":
		if e.complexity.Label.Nodes == nil {
			break
		}

		args, err := ec.field_Label_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Label.Nodes(childComplexity, args["filter"].(*model.NodeFilter), args["order"].(*model.NodeOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Label.nodesAggregate":
		if e.complexity.Label.NodesAggregate == nil {
			break
		}

		args, err := ec.field_Label_nodesAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Label.NodesAggregate(childComplexity, args["filter"].(*model.NodeFilter)), true

	case "Label.rootnameid":
		if e.complexity.Label.Rootnameid == nil {
			break
		}

		return e.complexity.Label.Rootnameid(childComplexity), true

	case "Label.tensions":
		if e.complexity.Label.Tensions == nil {
			break
		}

		args, err := ec.field_Label_tensions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Label.Tensions(childComplexity, args["filter"].(*model.TensionFilter), args["order"].(*model.TensionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Label.tensionsAggregate":
		if e.complexity.Label.TensionsAggregate == nil {
			break
		}

		args, err := ec.field_Label_tensionsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Label.TensionsAggregate(childComplexity, args["filter"].(*model.TensionFilter)), true

	case "LabelAggregateResult.colorMax":
		if e.complexity.LabelAggregateResult.ColorMax == nil {
			break
		}

		return e.complexity.LabelAggregateResult.ColorMax(childComplexity), true

	case "LabelAggregateResult.colorMin":
		if e.complexity.LabelAggregateResult.ColorMin == nil {
			break
		}

		return e.complexity.LabelAggregateResult.ColorMin(childComplexity), true

	case "LabelAggregateResult.count":
		if e.complexity.LabelAggregateResult.Count == nil {
			break
		}

		return e.complexity.LabelAggregateResult.Count(childComplexity), true

	case "LabelAggregateResult.descriptionMax":
		if e.complexity.LabelAggregateResult.DescriptionMax == nil {
			break
		}

		return e.complexity.LabelAggregateResult.DescriptionMax(childComplexity), true

	case "LabelAggregateResult.descriptionMin":
		if e.complexity.LabelAggregateResult.DescriptionMin == nil {
			break
		}

		return e.complexity.LabelAggregateResult.DescriptionMin(childComplexity), true

	case "LabelAggregateResult.nameMax":
		if e.complexity.LabelAggregateResult.NameMax == nil {
			break
		}

		return e.complexity.LabelAggregateResult.NameMax(childComplexity), true

	case "LabelAggregateResult.nameMin":
		if e.complexity.LabelAggregateResult.NameMin == nil {
			break
		}

		return e.complexity.LabelAggregateResult.NameMin(childComplexity), true

	case "LabelAggregateResult.rootnameidMax":
		if e.complexity.LabelAggregateResult.RootnameidMax == nil {
			break
		}

		return e.complexity.LabelAggregateResult.RootnameidMax(childComplexity), true

	case "LabelAggregateResult.rootnameidMin":
		if e.complexity.LabelAggregateResult.RootnameidMin == nil {
			break
		}

		return e.complexity.LabelAggregateResult.RootnameidMin(childComplexity), true

	case "Mandate.domains":
		if e.complexity.Mandate.Domains == nil {
			break
		}

		return e.complexity.Mandate.Domains(childComplexity), true

	case "Mandate.id":
		if e.complexity.Mandate.ID == nil {
			break
		}

		return e.complexity.Mandate.ID(childComplexity), true

	case "Mandate.policies":
		if e.complexity.Mandate.Policies == nil {
			break
		}

		return e.complexity.Mandate.Policies(childComplexity), true

	case "Mandate.purpose":
		if e.complexity.Mandate.Purpose == nil {
			break
		}

		return e.complexity.Mandate.Purpose(childComplexity), true

	case "Mandate.responsabilities":
		if e.complexity.Mandate.Responsabilities == nil {
			break
		}

		return e.complexity.Mandate.Responsabilities(childComplexity), true

	case "MandateAggregateResult.count":
		if e.complexity.MandateAggregateResult.Count == nil {
			break
		}

		return e.complexity.MandateAggregateResult.Count(childComplexity), true

	case "MandateAggregateResult.domainsMax":
		if e.complexity.MandateAggregateResult.DomainsMax == nil {
			break
		}

		return e.complexity.MandateAggregateResult.DomainsMax(childComplexity), true

	case "MandateAggregateResult.domainsMin":
		if e.complexity.MandateAggregateResult.DomainsMin == nil {
			break
		}

		return e.complexity.MandateAggregateResult.DomainsMin(childComplexity), true

	case "MandateAggregateResult.policiesMax":
		if e.complexity.MandateAggregateResult.PoliciesMax == nil {
			break
		}

		return e.complexity.MandateAggregateResult.PoliciesMax(childComplexity), true

	case "MandateAggregateResult.policiesMin":
		if e.complexity.MandateAggregateResult.PoliciesMin == nil {
			break
		}

		return e.complexity.MandateAggregateResult.PoliciesMin(childComplexity), true

	case "MandateAggregateResult.purposeMax":
		if e.complexity.MandateAggregateResult.PurposeMax == nil {
			break
		}

		return e.complexity.MandateAggregateResult.PurposeMax(childComplexity), true

	case "MandateAggregateResult.purposeMin":
		if e.complexity.MandateAggregateResult.PurposeMin == nil {
			break
		}

		return e.complexity.MandateAggregateResult.PurposeMin(childComplexity), true

	case "MandateAggregateResult.responsabilitiesMax":
		if e.complexity.MandateAggregateResult.ResponsabilitiesMax == nil {
			break
		}

		return e.complexity.MandateAggregateResult.ResponsabilitiesMax(childComplexity), true

	case "MandateAggregateResult.responsabilitiesMin":
		if e.complexity.MandateAggregateResult.ResponsabilitiesMin == nil {
			break
		}

		return e.complexity.MandateAggregateResult.ResponsabilitiesMin(childComplexity), true

	case "MultiPolygon.polygons":
		if e.complexity.MultiPolygon.Polygons == nil {
			break
		}

		return e.complexity.MultiPolygon.Polygons(childComplexity), true

	case "Mutation.addBlob":
		if e.complexity.Mutation.AddBlob == nil {
			break
		}

		args, err := ec.field_Mutation_addBlob_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddBlob(childComplexity, args["input"].([]*model.AddBlobInput)), true

	case "Mutation.addComment":
		if e.complexity.Mutation.AddComment == nil {
			break
		}

		args, err := ec.field_Mutation_addComment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddComment(childComplexity, args["input"].([]*model.AddCommentInput)), true

	case "Mutation.addContract":
		if e.complexity.Mutation.AddContract == nil {
			break
		}

		args, err := ec.field_Mutation_addContract_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddContract(childComplexity, args["input"].([]*model.AddContractInput), args["upsert"].(*bool)), true

	case "Mutation.addEvent":
		if e.complexity.Mutation.AddEvent == nil {
			break
		}

		args, err := ec.field_Mutation_addEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddEvent(childComplexity, args["input"].([]*model.AddEventInput)), true

	case "Mutation.addEventCount":
		if e.complexity.Mutation.AddEventCount == nil {
			break
		}

		args, err := ec.field_Mutation_addEventCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddEventCount(childComplexity, args["input"].([]*model.AddEventCountInput)), true

	case "Mutation.addEventFragment":
		if e.complexity.Mutation.AddEventFragment == nil {
			break
		}

		args, err := ec.field_Mutation_addEventFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddEventFragment(childComplexity, args["input"].([]*model.AddEventFragmentInput)), true

	case "Mutation.addLabel":
		if e.complexity.Mutation.AddLabel == nil {
			break
		}

		args, err := ec.field_Mutation_addLabel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddLabel(childComplexity, args["input"].([]*model.AddLabelInput)), true

	case "Mutation.addMandate":
		if e.complexity.Mutation.AddMandate == nil {
			break
		}

		args, err := ec.field_Mutation_addMandate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddMandate(childComplexity, args["input"].([]*model.AddMandateInput)), true

	case "Mutation.addNode":
		if e.complexity.Mutation.AddNode == nil {
			break
		}

		args, err := ec.field_Mutation_addNode_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddNode(childComplexity, args["input"].([]*model.AddNodeInput), args["upsert"].(*bool)), true

	case "Mutation.addNodeFragment":
		if e.complexity.Mutation.AddNodeFragment == nil {
			break
		}

		args, err := ec.field_Mutation_addNodeFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddNodeFragment(childComplexity, args["input"].([]*model.AddNodeFragmentInput)), true

	case "Mutation.addNotif":
		if e.complexity.Mutation.AddNotif == nil {
			break
		}

		args, err := ec.field_Mutation_addNotif_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddNotif(childComplexity, args["input"].([]*model.AddNotifInput)), true

	case "Mutation.addPendingUser":
		if e.complexity.Mutation.AddPendingUser == nil {
			break
		}

		args, err := ec.field_Mutation_addPendingUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddPendingUser(childComplexity, args["input"].([]*model.AddPendingUserInput), args["upsert"].(*bool)), true

	case "Mutation.addProject":
		if e.complexity.Mutation.AddProject == nil {
			break
		}

		args, err := ec.field_Mutation_addProject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddProject(childComplexity, args["input"].([]*model.AddProjectInput)), true

	case "Mutation.addProjectCard":
		if e.complexity.Mutation.AddProjectCard == nil {
			break
		}

		args, err := ec.field_Mutation_addProjectCard_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddProjectCard(childComplexity, args["input"].([]*model.AddProjectCardInput)), true

	case "Mutation.addProjectColumn":
		if e.complexity.Mutation.AddProjectColumn == nil {
			break
		}

		args, err := ec.field_Mutation_addProjectColumn_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddProjectColumn(childComplexity, args["input"].([]*model.AddProjectColumnInput)), true

	case "Mutation.addProjectDraft":
		if e.complexity.Mutation.AddProjectDraft == nil {
			break
		}

		args, err := ec.field_Mutation_addProjectDraft_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddProjectDraft(childComplexity, args["input"].([]*model.AddProjectDraftInput)), true

	case "Mutation.addProjectField":
		if e.complexity.Mutation.AddProjectField == nil {
			break
		}

		args, err := ec.field_Mutation_addProjectField_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddProjectField(childComplexity, args["input"].([]*model.AddProjectFieldInput)), true

	case "Mutation.addProjectFieldValue":
		if e.complexity.Mutation.AddProjectFieldValue == nil {
			break
		}

		args, err := ec.field_Mutation_addProjectFieldValue_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddProjectFieldValue(childComplexity, args["input"].([]*model.AddProjectFieldValueInput)), true

	case "Mutation.addReaction":
		if e.complexity.Mutation.AddReaction == nil {
			break
		}

		args, err := ec.field_Mutation_addReaction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddReaction(childComplexity, args["input"].([]*model.AddReactionInput), args["upsert"].(*bool)), true

	case "Mutation.addRoleExt":
		if e.complexity.Mutation.AddRoleExt == nil {
			break
		}

		args, err := ec.field_Mutation_addRoleExt_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddRoleExt(childComplexity, args["input"].([]*model.AddRoleExtInput)), true

	case "Mutation.addTension":
		if e.complexity.Mutation.AddTension == nil {
			break
		}

		args, err := ec.field_Mutation_addTension_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddTension(childComplexity, args["input"].([]*model.AddTensionInput)), true

	case "Mutation.addUser":
		if e.complexity.Mutation.AddUser == nil {
			break
		}

		args, err := ec.field_Mutation_addUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddUser(childComplexity, args["input"].([]*model.AddUserInput), args["upsert"].(*bool)), true

	case "Mutation.addUserEvent":
		if e.complexity.Mutation.AddUserEvent == nil {
			break
		}

		args, err := ec.field_Mutation_addUserEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddUserEvent(childComplexity, args["input"].([]*model.AddUserEventInput)), true

	case "Mutation.addUserRights":
		if e.complexity.Mutation.AddUserRights == nil {
			break
		}

		args, err := ec.field_Mutation_addUserRights_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddUserRights(childComplexity, args["input"].([]*model.AddUserRightsInput)), true

	case "Mutation.addVote":
		if e.complexity.Mutation.AddVote == nil {
			break
		}

		args, err := ec.field_Mutation_addVote_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddVote(childComplexity, args["input"].([]*model.AddVoteInput), args["upsert"].(*bool)), true

	case "Mutation.deleteBlob":
		if e.complexity.Mutation.DeleteBlob == nil {
			break
		}

		args, err := ec.field_Mutation_deleteBlob_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteBlob(childComplexity, args["filter"].(model.BlobFilter)), true

	case "Mutation.deleteComment":
		if e.complexity.Mutation.DeleteComment == nil {
			break
		}

		args, err := ec.field_Mutation_deleteComment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteComment(childComplexity, args["filter"].(model.CommentFilter)), true

	case "Mutation.deleteContract":
		if e.complexity.Mutation.DeleteContract == nil {
			break
		}

		args, err := ec.field_Mutation_deleteContract_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteContract(childComplexity, args["filter"].(model.ContractFilter)), true

	case "Mutation.deleteEvent":
		if e.complexity.Mutation.DeleteEvent == nil {
			break
		}

		args, err := ec.field_Mutation_deleteEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteEvent(childComplexity, args["filter"].(model.EventFilter)), true

	case "Mutation.deleteEventCount":
		if e.complexity.Mutation.DeleteEventCount == nil {
			break
		}

		args, err := ec.field_Mutation_deleteEventCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteEventCount(childComplexity, args["filter"].(model.EventCountFilter)), true

	case "Mutation.deleteEventFragment":
		if e.complexity.Mutation.DeleteEventFragment == nil {
			break
		}

		args, err := ec.field_Mutation_deleteEventFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteEventFragment(childComplexity, args["filter"].(model.EventFragmentFilter)), true

	case "Mutation.deleteLabel":
		if e.complexity.Mutation.DeleteLabel == nil {
			break
		}

		args, err := ec.field_Mutation_deleteLabel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteLabel(childComplexity, args["filter"].(model.LabelFilter)), true

	case "Mutation.deleteMandate":
		if e.complexity.Mutation.DeleteMandate == nil {
			break
		}

		args, err := ec.field_Mutation_deleteMandate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteMandate(childComplexity, args["filter"].(model.MandateFilter)), true

	case "Mutation.deleteNode":
		if e.complexity.Mutation.DeleteNode == nil {
			break
		}

		args, err := ec.field_Mutation_deleteNode_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteNode(childComplexity, args["filter"].(model.NodeFilter)), true

	case "Mutation.deleteNodeFragment":
		if e.complexity.Mutation.DeleteNodeFragment == nil {
			break
		}

		args, err := ec.field_Mutation_deleteNodeFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteNodeFragment(childComplexity, args["filter"].(model.NodeFragmentFilter)), true

	case "Mutation.deleteNotif":
		if e.complexity.Mutation.DeleteNotif == nil {
			break
		}

		args, err := ec.field_Mutation_deleteNotif_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteNotif(childComplexity, args["filter"].(model.NotifFilter)), true

	case "Mutation.deletePendingUser":
		if e.complexity.Mutation.DeletePendingUser == nil {
			break
		}

		args, err := ec.field_Mutation_deletePendingUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeletePendingUser(childComplexity, args["filter"].(model.PendingUserFilter)), true

	case "Mutation.deletePost":
		if e.complexity.Mutation.DeletePost == nil {
			break
		}

		args, err := ec.field_Mutation_deletePost_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeletePost(childComplexity, args["filter"].(model.PostFilter)), true

	case "Mutation.deleteProject":
		if e.complexity.Mutation.DeleteProject == nil {
			break
		}

		args, err := ec.field_Mutation_deleteProject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteProject(childComplexity, args["filter"].(model.ProjectFilter)), true

	case "Mutation.deleteProjectCard":
		if e.complexity.Mutation.DeleteProjectCard == nil {
			break
		}

		args, err := ec.field_Mutation_deleteProjectCard_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteProjectCard(childComplexity, args["filter"].(model.ProjectCardFilter)), true

	case "Mutation.deleteProjectColumn":
		if e.complexity.Mutation.DeleteProjectColumn == nil {
			break
		}

		args, err := ec.field_Mutation_deleteProjectColumn_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteProjectColumn(childComplexity, args["filter"].(model.ProjectColumnFilter)), true

	case "Mutation.deleteProjectDraft":
		if e.complexity.Mutation.DeleteProjectDraft == nil {
			break
		}

		args, err := ec.field_Mutation_deleteProjectDraft_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteProjectDraft(childComplexity, args["filter"].(model.ProjectDraftFilter)), true

	case "Mutation.deleteProjectField":
		if e.complexity.Mutation.DeleteProjectField == nil {
			break
		}

		args, err := ec.field_Mutation_deleteProjectField_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteProjectField(childComplexity, args["filter"].(model.ProjectFieldFilter)), true

	case "Mutation.deleteProjectFieldValue":
		if e.complexity.Mutation.DeleteProjectFieldValue == nil {
			break
		}

		args, err := ec.field_Mutation_deleteProjectFieldValue_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteProjectFieldValue(childComplexity, args["filter"].(model.ProjectFieldValueFilter)), true

	case "Mutation.deleteReaction":
		if e.complexity.Mutation.DeleteReaction == nil {
			break
		}

		args, err := ec.field_Mutation_deleteReaction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteReaction(childComplexity, args["filter"].(model.ReactionFilter)), true

	case "Mutation.deleteRoleExt":
		if e.complexity.Mutation.DeleteRoleExt == nil {
			break
		}

		args, err := ec.field_Mutation_deleteRoleExt_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteRoleExt(childComplexity, args["filter"].(model.RoleExtFilter)), true

	case "Mutation.deleteTension":
		if e.complexity.Mutation.DeleteTension == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTension_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTension(childComplexity, args["filter"].(model.TensionFilter)), true

	case "Mutation.deleteUser":
		if e.complexity.Mutation.DeleteUser == nil {
			break
		}

		args, err := ec.field_Mutation_deleteUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteUser(childComplexity, args["filter"].(model.UserFilter)), true

	case "Mutation.deleteUserEvent":
		if e.complexity.Mutation.DeleteUserEvent == nil {
			break
		}

		args, err := ec.field_Mutation_deleteUserEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteUserEvent(childComplexity, args["filter"].(model.UserEventFilter)), true

	case "Mutation.deleteUserRights":
		if e.complexity.Mutation.DeleteUserRights == nil {
			break
		}

		args, err := ec.field_Mutation_deleteUserRights_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteUserRights(childComplexity, args["filter"].(model.UserRightsFilter)), true

	case "Mutation.deleteVote":
		if e.complexity.Mutation.DeleteVote == nil {
			break
		}

		args, err := ec.field_Mutation_deleteVote_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteVote(childComplexity, args["filter"].(model.VoteFilter)), true

	case "Mutation.updateBlob":
		if e.complexity.Mutation.UpdateBlob == nil {
			break
		}

		args, err := ec.field_Mutation_updateBlob_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateBlob(childComplexity, args["input"].(model.UpdateBlobInput)), true

	case "Mutation.updateComment":
		if e.complexity.Mutation.UpdateComment == nil {
			break
		}

		args, err := ec.field_Mutation_updateComment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateComment(childComplexity, args["input"].(model.UpdateCommentInput)), true

	case "Mutation.updateContract":
		if e.complexity.Mutation.UpdateContract == nil {
			break
		}

		args, err := ec.field_Mutation_updateContract_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateContract(childComplexity, args["input"].(model.UpdateContractInput)), true

	case "Mutation.updateEvent":
		if e.complexity.Mutation.UpdateEvent == nil {
			break
		}

		args, err := ec.field_Mutation_updateEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEvent(childComplexity, args["input"].(model.UpdateEventInput)), true

	case "Mutation.updateEventCount":
		if e.complexity.Mutation.UpdateEventCount == nil {
			break
		}

		args, err := ec.field_Mutation_updateEventCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEventCount(childComplexity, args["input"].(model.UpdateEventCountInput)), true

	case "Mutation.updateEventFragment":
		if e.complexity.Mutation.UpdateEventFragment == nil {
			break
		}

		args, err := ec.field_Mutation_updateEventFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEventFragment(childComplexity, args["input"].(model.UpdateEventFragmentInput)), true

	case "Mutation.updateLabel":
		if e.complexity.Mutation.UpdateLabel == nil {
			break
		}

		args, err := ec.field_Mutation_updateLabel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateLabel(childComplexity, args["input"].(model.UpdateLabelInput)), true

	case "Mutation.updateMandate":
		if e.complexity.Mutation.UpdateMandate == nil {
			break
		}

		args, err := ec.field_Mutation_updateMandate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMandate(childComplexity, args["input"].(model.UpdateMandateInput)), true

	case "Mutation.updateNode":
		if e.complexity.Mutation.UpdateNode == nil {
			break
		}

		args, err := ec.field_Mutation_updateNode_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateNode(childComplexity, args["input"].(model.UpdateNodeInput)), true

	case "Mutation.updateNodeFragment":
		if e.complexity.Mutation.UpdateNodeFragment == nil {
			break
		}

		args, err := ec.field_Mutation_updateNodeFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateNodeFragment(childComplexity, args["input"].(model.UpdateNodeFragmentInput)), true

	case "Mutation.updateNotif":
		if e.complexity.Mutation.UpdateNotif == nil {
			break
		}

		args, err := ec.field_Mutation_updateNotif_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateNotif(childComplexity, args["input"].(model.UpdateNotifInput)), true

	case "Mutation.updatePendingUser":
		if e.complexity.Mutation.UpdatePendingUser == nil {
			break
		}

		args, err := ec.field_Mutation_updatePendingUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePendingUser(childComplexity, args["input"].(model.UpdatePendingUserInput)), true

	case "Mutation.updatePost":
		if e.complexity.Mutation.UpdatePost == nil {
			break
		}

		args, err := ec.field_Mutation_updatePost_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePost(childComplexity, args["input"].(model.UpdatePostInput)), true

	case "Mutation.updateProject":
		if e.complexity.Mutation.UpdateProject == nil {
			break
		}

		args, err := ec.field_Mutation_updateProject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateProject(childComplexity, args["input"].(model.UpdateProjectInput)), true

	case "Mutation.updateProjectCard":
		if e.complexity.Mutation.UpdateProjectCard == nil {
			break
		}

		args, err := ec.field_Mutation_updateProjectCard_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateProjectCard(childComplexity, args["input"].(model.UpdateProjectCardInput)), true

	case "Mutation.updateProjectColumn":
		if e.complexity.Mutation.UpdateProjectColumn == nil {
			break
		}

		args, err := ec.field_Mutation_updateProjectColumn_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateProjectColumn(childComplexity, args["input"].(model.UpdateProjectColumnInput)), true

	case "Mutation.updateProjectDraft":
		if e.complexity.Mutation.UpdateProjectDraft == nil {
			break
		}

		args, err := ec.field_Mutation_updateProjectDraft_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateProjectDraft(childComplexity, args["input"].(model.UpdateProjectDraftInput)), true

	case "Mutation.updateProjectField":
		if e.complexity.Mutation.UpdateProjectField == nil {
			break
		}

		args, err := ec.field_Mutation_updateProjectField_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateProjectField(childComplexity, args["input"].(model.UpdateProjectFieldInput)), true

	case "Mutation.updateProjectFieldValue":
		if e.complexity.Mutation.UpdateProjectFieldValue == nil {
			break
		}

		args, err := ec.field_Mutation_updateProjectFieldValue_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateProjectFieldValue(childComplexity, args["input"].(model.UpdateProjectFieldValueInput)), true

	case "Mutation.updateReaction":
		if e.complexity.Mutation.UpdateReaction == nil {
			break
		}

		args, err := ec.field_Mutation_updateReaction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateReaction(childComplexity, args["input"].(model.UpdateReactionInput)), true

	case "Mutation.updateRoleExt":
		if e.complexity.Mutation.UpdateRoleExt == nil {
			break
		}

		args, err := ec.field_Mutation_updateRoleExt_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateRoleExt(childComplexity, args["input"].(model.UpdateRoleExtInput)), true

	case "Mutation.updateTension":
		if e.complexity.Mutation.UpdateTension == nil {
			break
		}

		args, err := ec.field_Mutation_updateTension_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTension(childComplexity, args["input"].(model.UpdateTensionInput)), true

	case "Mutation.updateUser":
		if e.complexity.Mutation.UpdateUser == nil {
			break
		}

		args, err := ec.field_Mutation_updateUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUser(childComplexity, args["input"].(model.UpdateUserInput)), true

	case "Mutation.updateUserEvent":
		if e.complexity.Mutation.UpdateUserEvent == nil {
			break
		}

		args, err := ec.field_Mutation_updateUserEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUserEvent(childComplexity, args["input"].(model.UpdateUserEventInput)), true

	case "Mutation.updateUserRights":
		if e.complexity.Mutation.UpdateUserRights == nil {
			break
		}

		args, err := ec.field_Mutation_updateUserRights_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUserRights(childComplexity, args["input"].(model.UpdateUserRightsInput)), true

	case "Mutation.updateVote":
		if e.complexity.Mutation.UpdateVote == nil {
			break
		}

		args, err := ec.field_Mutation_updateVote_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateVote(childComplexity, args["input"].(model.UpdateVoteInput)), true

	case "Node.about":
		if e.complexity.Node.About == nil {
			break
		}

		return e.complexity.Node.About(childComplexity), true

	case "Node.children":
		if e.complexity.Node.Children == nil {
			break
		}

		args, err := ec.field_Node_children_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.Children(childComplexity, args["filter"].(*model.NodeFilter), args["order"].(*model.NodeOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Node.childrenAggregate":
		if e.complexity.Node.ChildrenAggregate == nil {
			break
		}

		args, err := ec.field_Node_childrenAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.ChildrenAggregate(childComplexity, args["filter"].(*model.NodeFilter)), true

	case "Node.color":
		if e.complexity.Node.Color == nil {
			break
		}

		return e.complexity.Node.Color(childComplexity), true

	case "Node.contracts":
		if e.complexity.Node.Contracts == nil {
			break
		}

		args, err := ec.field_Node_contracts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.Contracts(childComplexity, args["filter"].(*model.VoteFilter), args["order"].(*model.VoteOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Node.contractsAggregate":
		if e.complexity.Node.ContractsAggregate == nil {
			break
		}

		args, err := ec.field_Node_contractsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.ContractsAggregate(childComplexity, args["filter"].(*model.VoteFilter)), true

	case "Node.createdAt":
		if e.complexity.Node.CreatedAt == nil {
			break
		}

		return e.complexity.Node.CreatedAt(childComplexity), true

	case "Node.createdBy":
		if e.complexity.Node.CreatedBy == nil {
			break
		}

		args, err := ec.field_Node_createdBy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.CreatedBy(childComplexity, args["filter"].(*model.UserFilter)), true

	case "Node.events_history":
		if e.complexity.Node.EventsHistory == nil {
			break
		}

		args, err := ec.field_Node_events_history_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.EventsHistory(childComplexity, args["filter"].(*model.EventFilter), args["order"].(*model.EventOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Node.events_historyAggregate":
		if e.complexity.Node.EventsHistoryAggregate == nil {
			break
		}

		args, err := ec.field_Node_events_historyAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.EventsHistoryAggregate(childComplexity, args["filter"].(*model.EventFilter)), true

	case "Node.first_link":
		if e.complexity.Node.FirstLink == nil {
			break
		}

		args, err := ec.field_Node_first_link_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.FirstLink(childComplexity, args["filter"].(*model.UserFilter)), true

	case "Node.guestCanCreateTension":
		if e.complexity.Node.GuestCanCreateTension == nil {
			break
		}

		return e.complexity.Node.GuestCanCreateTension(childComplexity), true

	case "Node.id":
		if e.complexity.Node.ID == nil {
			break
		}

		return e.complexity.Node.ID(childComplexity), true

	case "Node.isArchived":
		if e.complexity.Node.IsArchived == nil {
			break
		}

		return e.complexity.Node.IsArchived(childComplexity), true

	case "Node.isPersonal":
		if e.complexity.Node.IsPersonal == nil {
			break
		}

		return e.complexity.Node.IsPersonal(childComplexity), true

	case "Node.isRoot":
		if e.complexity.Node.IsRoot == nil {
			break
		}

		return e.complexity.Node.IsRoot(childComplexity), true

	case "Node.labels":
		if e.complexity.Node.Labels == nil {
			break
		}

		args, err := ec.field_Node_labels_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.Labels(childComplexity, args["filter"].(*model.LabelFilter), args["order"].(*model.LabelOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Node.labelsAggregate":
		if e.complexity.Node.LabelsAggregate == nil {
			break
		}

		args, err := ec.field_Node_labelsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.LabelsAggregate(childComplexity, args["filter"].(*model.LabelFilter)), true

	case "Node.mode":
		if e.complexity.Node.Mode == nil {
			break
		}

		return e.complexity.Node.Mode(childComplexity), true

	case "Node.name":
		if e.complexity.Node.Name == nil {
			break
		}

		return e.complexity.Node.Name(childComplexity), true

	case "Node.nameid":
		if e.complexity.Node.Nameid == nil {
			break
		}

		return e.complexity.Node.Nameid(childComplexity), true

	case "Node.parent":
		if e.complexity.Node.Parent == nil {
			break
		}

		args, err := ec.field_Node_parent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.Parent(childComplexity, args["filter"].(*model.NodeFilter)), true

	case "Node.pinned":
		if e.complexity.Node.Pinned == nil {
			break
		}

		args, err := ec.field_Node_pinned_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.Pinned(childComplexity, args["filter"].(*model.TensionFilter), args["order"].(*model.TensionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Node.pinnedAggregate":
		if e.complexity.Node.PinnedAggregate == nil {
			break
		}

		args, err := ec.field_Node_pinnedAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.PinnedAggregate(childComplexity, args["filter"].(*model.TensionFilter)), true

	case "Node.projects":
		if e.complexity.Node.Projects == nil {
			break
		}

		args, err := ec.field_Node_projects_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.Projects(childComplexity, args["filter"].(*model.ProjectFilter), args["order"].(*model.ProjectOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Node.projectsAggregate":
		if e.complexity.Node.ProjectsAggregate == nil {
			break
		}

		args, err := ec.field_Node_projectsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.ProjectsAggregate(childComplexity, args["filter"].(*model.ProjectFilter)), true

	case "Node.rights":
		if e.complexity.Node.Rights == nil {
			break
		}

		return e.complexity.Node.Rights(childComplexity), true

	case "Node.role_ext":
		if e.complexity.Node.RoleExt == nil {
			break
		}

		args, err := ec.field_Node_role_ext_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.RoleExt(childComplexity, args["filter"].(*model.RoleExtFilter)), true

	case "Node.role_type":
		if e.complexity.Node.RoleType == nil {
			break
		}

		return e.complexity.Node.RoleType(childComplexity), true

	case "Node.roles":
		if e.complexity.Node.Roles == nil {
			break
		}

		args, err := ec.field_Node_roles_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.Roles(childComplexity, args["filter"].(*model.RoleExtFilter), args["order"].(*model.RoleExtOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Node.rolesAggregate":
		if e.complexity.Node.RolesAggregate == nil {
			break
		}

		args, err := ec.field_Node_rolesAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.RolesAggregate(childComplexity, args["filter"].(*model.RoleExtFilter)), true

	case "Node.rootnameid":
		if e.complexity.Node.Rootnameid == nil {
			break
		}

		return e.complexity.Node.Rootnameid(childComplexity), true

	case "Node.skills":
		if e.complexity.Node.Skills == nil {
			break
		}

		return e.complexity.Node.Skills(childComplexity), true

	case "Node.source":
		if e.complexity.Node.Source == nil {
			break
		}

		args, err := ec.field_Node_source_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.Source(childComplexity, args["filter"].(*model.BlobFilter)), true

	case "Node.tensions_in":
		if e.complexity.Node.TensionsIn == nil {
			break
		}

		args, err := ec.field_Node_tensions_in_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.TensionsIn(childComplexity, args["filter"].(*model.TensionFilter), args["order"].(*model.TensionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Node.tensions_inAggregate":
		if e.complexity.Node.TensionsInAggregate == nil {
			break
		}

		args, err := ec.field_Node_tensions_inAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.TensionsInAggregate(childComplexity, args["filter"].(*model.TensionFilter)), true

	case "Node.tensions_out":
		if e.complexity.Node.TensionsOut == nil {
			break
		}

		args, err := ec.field_Node_tensions_out_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.TensionsOut(childComplexity, args["filter"].(*model.TensionFilter), args["order"].(*model.TensionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Node.tensions_outAggregate":
		if e.complexity.Node.TensionsOutAggregate == nil {
			break
		}

		args, err := ec.field_Node_tensions_outAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.TensionsOutAggregate(childComplexity, args["filter"].(*model.TensionFilter)), true

	case "Node.type_":
		if e.complexity.Node.Type == nil {
			break
		}

		return e.complexity.Node.Type(childComplexity), true

	case "Node.updatedAt":
		if e.complexity.Node.UpdatedAt == nil {
			break
		}

		return e.complexity.Node.UpdatedAt(childComplexity), true

	case "Node.userCanJoin":
		if e.complexity.Node.UserCanJoin == nil {
			break
		}

		return e.complexity.Node.UserCanJoin(childComplexity), true

	case "Node.visibility":
		if e.complexity.Node.Visibility == nil {
			break
		}

		return e.complexity.Node.Visibility(childComplexity), true

	case "Node.watchers":
		if e.complexity.Node.Watchers == nil {
			break
		}

		args, err := ec.field_Node_watchers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.Watchers(childComplexity, args["filter"].(*model.UserFilter), args["order"].(*model.UserOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Node.watchersAggregate":
		if e.complexity.Node.WatchersAggregate == nil {
			break
		}

		args, err := ec.field_Node_watchersAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.WatchersAggregate(childComplexity, args["filter"].(*model.UserFilter)), true

	case "NodeAggregateResult.aboutMax":
		if e.complexity.NodeAggregateResult.AboutMax == nil {
			break
		}

		return e.complexity.NodeAggregateResult.AboutMax(childComplexity), true

	case "NodeAggregateResult.aboutMin":
		if e.complexity.NodeAggregateResult.AboutMin == nil {
			break
		}

		return e.complexity.NodeAggregateResult.AboutMin(childComplexity), true

	case "NodeAggregateResult.colorMax":
		if e.complexity.NodeAggregateResult.ColorMax == nil {
			break
		}

		return e.complexity.NodeAggregateResult.ColorMax(childComplexity), true

	case "NodeAggregateResult.colorMin":
		if e.complexity.NodeAggregateResult.ColorMin == nil {
			break
		}

		return e.complexity.NodeAggregateResult.ColorMin(childComplexity), true

	case "NodeAggregateResult.count":
		if e.complexity.NodeAggregateResult.Count == nil {
			break
		}

		return e.complexity.NodeAggregateResult.Count(childComplexity), true

	case "NodeAggregateResult.createdAtMax":
		if e.complexity.NodeAggregateResult.CreatedAtMax == nil {
			break
		}

		return e.complexity.NodeAggregateResult.CreatedAtMax(childComplexity), true

	case "NodeAggregateResult.createdAtMin":
		if e.complexity.NodeAggregateResult.CreatedAtMin == nil {
			break
		}

		return e.complexity.NodeAggregateResult.CreatedAtMin(childComplexity), true

	case "NodeAggregateResult.nameMax":
		if e.complexity.NodeAggregateResult.NameMax == nil {
			break
		}

		return e.complexity.NodeAggregateResult.NameMax(childComplexity), true

	case "NodeAggregateResult.nameMin":
		if e.complexity.NodeAggregateResult.NameMin == nil {
			break
		}

		return e.complexity.NodeAggregateResult.NameMin(childComplexity), true

	case "NodeAggregateResult.nameidMax":
		if e.complexity.NodeAggregateResult.NameidMax == nil {
			break
		}

		return e.complexity.NodeAggregateResult.NameidMax(childComplexity), true

	case "NodeAggregateResult.nameidMin":
		if e.complexity.NodeAggregateResult.NameidMin == nil {
			break
		}

		return e.complexity.NodeAggregateResult.NameidMin(childComplexity), true

	case "NodeAggregateResult.rightsAvg":
		if e.complexity.NodeAggregateResult.RightsAvg == nil {
			break
		}

		return e.complexity.NodeAggregateResult.RightsAvg(childComplexity), true

	case "NodeAggregateResult.rightsMax":
		if e.complexity.NodeAggregateResult.RightsMax == nil {
			break
		}

		return e.complexity.NodeAggregateResult.RightsMax(childComplexity), true

	case "NodeAggregateResult.rightsMin":
		if e.complexity.NodeAggregateResult.RightsMin == nil {
			break
		}

		return e.complexity.NodeAggregateResult.RightsMin(childComplexity), true

	case "NodeAggregateResult.rightsSum":
		if e.complexity.NodeAggregateResult.RightsSum == nil {
			break
		}

		return e.complexity.NodeAggregateResult.RightsSum(childComplexity), true

	case "NodeAggregateResult.rootnameidMax":
		if e.complexity.NodeAggregateResult.RootnameidMax == nil {
			break
		}

		return e.complexity.NodeAggregateResult.RootnameidMax(childComplexity), true

	case "NodeAggregateResult.rootnameidMin":
		if e.complexity.NodeAggregateResult.RootnameidMin == nil {
			break
		}

		return e.complexity.NodeAggregateResult.RootnameidMin(childComplexity), true

	case "NodeAggregateResult.updatedAtMax":
		if e.complexity.NodeAggregateResult.UpdatedAtMax == nil {
			break
		}

		return e.complexity.NodeAggregateResult.UpdatedAtMax(childComplexity), true

	case "NodeAggregateResult.updatedAtMin":
		if e.complexity.NodeAggregateResult.UpdatedAtMin == nil {
			break
		}

		return e.complexity.NodeAggregateResult.UpdatedAtMin(childComplexity), true

	case "NodeFragment.about":
		if e.complexity.NodeFragment.About == nil {
			break
		}

		return e.complexity.NodeFragment.About(childComplexity), true

	case "NodeFragment.color":
		if e.complexity.NodeFragment.Color == nil {
			break
		}

		return e.complexity.NodeFragment.Color(childComplexity), true

	case "NodeFragment.first_link":
		if e.complexity.NodeFragment.FirstLink == nil {
			break
		}

		return e.complexity.NodeFragment.FirstLink(childComplexity), true

	case "NodeFragment.id":
		if e.complexity.NodeFragment.ID == nil {
			break
		}

		return e.complexity.NodeFragment.ID(childComplexity), true

	case "NodeFragment.mandate":
		if e.complexity.NodeFragment.Mandate == nil {
			break
		}

		args, err := ec.field_NodeFragment_mandate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.NodeFragment.Mandate(childComplexity, args["filter"].(*model.MandateFilter)), true

	case "NodeFragment.mode":
		if e.complexity.NodeFragment.Mode == nil {
			break
		}

		return e.complexity.NodeFragment.Mode(childComplexity), true

	case "NodeFragment.name":
		if e.complexity.NodeFragment.Name == nil {
			break
		}

		return e.complexity.NodeFragment.Name(childComplexity), true

	case "NodeFragment.nameid":
		if e.complexity.NodeFragment.Nameid == nil {
			break
		}

		return e.complexity.NodeFragment.Nameid(childComplexity), true

	case "NodeFragment.role_ext":
		if e.complexity.NodeFragment.RoleExt == nil {
			break
		}

		return e.complexity.NodeFragment.RoleExt(childComplexity), true

	case "NodeFragment.role_type":
		if e.complexity.NodeFragment.RoleType == nil {
			break
		}

		return e.complexity.NodeFragment.RoleType(childComplexity), true

	case "NodeFragment.skills":
		if e.complexity.NodeFragment.Skills == nil {
			break
		}

		return e.complexity.NodeFragment.Skills(childComplexity), true

	case "NodeFragment.type_":
		if e.complexity.NodeFragment.Type == nil {
			break
		}

		return e.complexity.NodeFragment.Type(childComplexity), true

	case "NodeFragment.visibility":
		if e.complexity.NodeFragment.Visibility == nil {
			break
		}

		return e.complexity.NodeFragment.Visibility(childComplexity), true

	case "NodeFragmentAggregateResult.aboutMax":
		if e.complexity.NodeFragmentAggregateResult.AboutMax == nil {
			break
		}

		return e.complexity.NodeFragmentAggregateResult.AboutMax(childComplexity), true

	case "NodeFragmentAggregateResult.aboutMin":
		if e.complexity.NodeFragmentAggregateResult.AboutMin == nil {
			break
		}

		return e.complexity.NodeFragmentAggregateResult.AboutMin(childComplexity), true

	case "NodeFragmentAggregateResult.colorMax":
		if e.complexity.NodeFragmentAggregateResult.ColorMax == nil {
			break
		}

		return e.complexity.NodeFragmentAggregateResult.ColorMax(childComplexity), true

	case "NodeFragmentAggregateResult.colorMin":
		if e.complexity.NodeFragmentAggregateResult.ColorMin == nil {
			break
		}

		return e.complexity.NodeFragmentAggregateResult.ColorMin(childComplexity), true

	case "NodeFragmentAggregateResult.count":
		if e.complexity.NodeFragmentAggregateResult.Count == nil {
			break
		}

		return e.complexity.NodeFragmentAggregateResult.Count(childComplexity), true

	case "NodeFragmentAggregateResult.first_linkMax":
		if e.complexity.NodeFragmentAggregateResult.FirstLinkMax == nil {
			break
		}

		return e.complexity.NodeFragmentAggregateResult.FirstLinkMax(childComplexity), true

	case "NodeFragmentAggregateResult.first_linkMin":
		if e.complexity.NodeFragmentAggregateResult.FirstLinkMin == nil {
			break
		}

		return e.complexity.NodeFragmentAggregateResult.FirstLinkMin(childComplexity), true

	case "NodeFragmentAggregateResult.nameMax":
		if e.complexity.NodeFragmentAggregateResult.NameMax == nil {
			break
		}

		return e.complexity.NodeFragmentAggregateResult.NameMax(childComplexity), true

	case "NodeFragmentAggregateResult.nameMin":
		if e.complexity.NodeFragmentAggregateResult.NameMin == nil {
			break
		}

		return e.complexity.NodeFragmentAggregateResult.NameMin(childComplexity), true

	case "NodeFragmentAggregateResult.nameidMax":
		if e.complexity.NodeFragmentAggregateResult.NameidMax == nil {
			break
		}

		return e.complexity.NodeFragmentAggregateResult.NameidMax(childComplexity), true

	case "NodeFragmentAggregateResult.nameidMin":
		if e.complexity.NodeFragmentAggregateResult.NameidMin == nil {
			break
		}

		return e.complexity.NodeFragmentAggregateResult.NameidMin(childComplexity), true

	case "NodeFragmentAggregateResult.role_extMax":
		if e.complexity.NodeFragmentAggregateResult.RoleExtMax == nil {
			break
		}

		return e.complexity.NodeFragmentAggregateResult.RoleExtMax(childComplexity), true

	case "NodeFragmentAggregateResult.role_extMin":
		if e.complexity.NodeFragmentAggregateResult.RoleExtMin == nil {
			break
		}

		return e.complexity.NodeFragmentAggregateResult.RoleExtMin(childComplexity), true

	case "Notif.contract":
		if e.complexity.Notif.Contract == nil {
			break
		}

		args, err := ec.field_Notif_contract_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Notif.Contract(childComplexity, args["filter"].(*model.ContractFilter)), true

	case "Notif.createdAt":
		if e.complexity.Notif.CreatedAt == nil {
			break
		}

		return e.complexity.Notif.CreatedAt(childComplexity), true

	case "Notif.createdBy":
		if e.complexity.Notif.CreatedBy == nil {
			break
		}

		args, err := ec.field_Notif_createdBy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Notif.CreatedBy(childComplexity, args["filter"].(*model.UserFilter)), true

	case "Notif.id":
		if e.complexity.Notif.ID == nil {
			break
		}

		return e.complexity.Notif.ID(childComplexity), true

	case "Notif.link":
		if e.complexity.Notif.Link == nil {
			break
		}

		return e.complexity.Notif.Link(childComplexity), true

	case "Notif.message":
		if e.complexity.Notif.Message == nil {
			break
		}

		return e.complexity.Notif.Message(childComplexity), true

	case "Notif.tension_":
		if e.complexity.Notif.Tension == nil {
			break
		}

		args, err := ec.field_Notif_tension__args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Notif.Tension(childComplexity, args["filter"].(*model.TensionFilter)), true

	case "Notif.updatedAt":
		if e.complexity.Notif.UpdatedAt == nil {
			break
		}

		return e.complexity.Notif.UpdatedAt(childComplexity), true

	case "NotifAggregateResult.count":
		if e.complexity.NotifAggregateResult.Count == nil {
			break
		}

		return e.complexity.NotifAggregateResult.Count(childComplexity), true

	case "NotifAggregateResult.createdAtMax":
		if e.complexity.NotifAggregateResult.CreatedAtMax == nil {
			break
		}

		return e.complexity.NotifAggregateResult.CreatedAtMax(childComplexity), true

	case "NotifAggregateResult.createdAtMin":
		if e.complexity.NotifAggregateResult.CreatedAtMin == nil {
			break
		}

		return e.complexity.NotifAggregateResult.CreatedAtMin(childComplexity), true

	case "NotifAggregateResult.linkMax":
		if e.complexity.NotifAggregateResult.LinkMax == nil {
			break
		}

		return e.complexity.NotifAggregateResult.LinkMax(childComplexity), true

	case "NotifAggregateResult.linkMin":
		if e.complexity.NotifAggregateResult.LinkMin == nil {
			break
		}

		return e.complexity.NotifAggregateResult.LinkMin(childComplexity), true

	case "NotifAggregateResult.messageMax":
		if e.complexity.NotifAggregateResult.MessageMax == nil {
			break
		}

		return e.complexity.NotifAggregateResult.MessageMax(childComplexity), true

	case "NotifAggregateResult.messageMin":
		if e.complexity.NotifAggregateResult.MessageMin == nil {
			break
		}

		return e.complexity.NotifAggregateResult.MessageMin(childComplexity), true

	case "NotifAggregateResult.updatedAtMax":
		if e.complexity.NotifAggregateResult.UpdatedAtMax == nil {
			break
		}

		return e.complexity.NotifAggregateResult.UpdatedAtMax(childComplexity), true

	case "NotifAggregateResult.updatedAtMin":
		if e.complexity.NotifAggregateResult.UpdatedAtMin == nil {
			break
		}

		return e.complexity.NotifAggregateResult.UpdatedAtMin(childComplexity), true

	case "PendingUser.contracts":
		if e.complexity.PendingUser.Contracts == nil {
			break
		}

		args, err := ec.field_PendingUser_contracts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.PendingUser.Contracts(childComplexity, args["filter"].(*model.ContractFilter), args["order"].(*model.ContractOrder), args["first"].(*int), args["offset"].(*int)), true

	case "PendingUser.contractsAggregate":
		if e.complexity.PendingUser.ContractsAggregate == nil {
			break
		}

		args, err := ec.field_PendingUser_contractsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.PendingUser.ContractsAggregate(childComplexity, args["filter"].(*model.ContractFilter)), true

	case "PendingUser.email":
		if e.complexity.PendingUser.Email == nil {
			break
		}

		return e.complexity.PendingUser.Email(childComplexity), true

	case "PendingUser.email_token":
		if e.complexity.PendingUser.EmailToken == nil {
			break
		}

		return e.complexity.PendingUser.EmailToken(childComplexity), true

	case "PendingUser.id":
		if e.complexity.PendingUser.ID == nil {
			break
		}

		return e.complexity.PendingUser.ID(childComplexity), true

	case "PendingUser.password":
		if e.complexity.PendingUser.Password == nil {
			break
		}

		return e.complexity.PendingUser.Password(childComplexity), true

	case "PendingUser.subscribe":
		if e.complexity.PendingUser.Subscribe == nil {
			break
		}

		return e.complexity.PendingUser.Subscribe(childComplexity), true

	case "PendingUser.token":
		if e.complexity.PendingUser.Token == nil {
			break
		}

		return e.complexity.PendingUser.Token(childComplexity), true

	case "PendingUser.updatedAt":
		if e.complexity.PendingUser.UpdatedAt == nil {
			break
		}

		return e.complexity.PendingUser.UpdatedAt(childComplexity), true

	case "PendingUser.username":
		if e.complexity.PendingUser.Username == nil {
			break
		}

		return e.complexity.PendingUser.Username(childComplexity), true

	case "PendingUserAggregateResult.count":
		if e.complexity.PendingUserAggregateResult.Count == nil {
			break
		}

		return e.complexity.PendingUserAggregateResult.Count(childComplexity), true

	case "PendingUserAggregateResult.emailMax":
		if e.complexity.PendingUserAggregateResult.EmailMax == nil {
			break
		}

		return e.complexity.PendingUserAggregateResult.EmailMax(childComplexity), true

	case "PendingUserAggregateResult.emailMin":
		if e.complexity.PendingUserAggregateResult.EmailMin == nil {
			break
		}

		return e.complexity.PendingUserAggregateResult.EmailMin(childComplexity), true

	case "PendingUserAggregateResult.email_tokenMax":
		if e.complexity.PendingUserAggregateResult.EmailTokenMax == nil {
			break
		}

		return e.complexity.PendingUserAggregateResult.EmailTokenMax(childComplexity), true

	case "PendingUserAggregateResult.email_tokenMin":
		if e.complexity.PendingUserAggregateResult.EmailTokenMin == nil {
			break
		}

		return e.complexity.PendingUserAggregateResult.EmailTokenMin(childComplexity), true

	case "PendingUserAggregateResult.passwordMax":
		if e.complexity.PendingUserAggregateResult.PasswordMax == nil {
			break
		}

		return e.complexity.PendingUserAggregateResult.PasswordMax(childComplexity), true

	case "PendingUserAggregateResult.passwordMin":
		if e.complexity.PendingUserAggregateResult.PasswordMin == nil {
			break
		}

		return e.complexity.PendingUserAggregateResult.PasswordMin(childComplexity), true

	case "PendingUserAggregateResult.tokenMax":
		if e.complexity.PendingUserAggregateResult.TokenMax == nil {
			break
		}

		return e.complexity.PendingUserAggregateResult.TokenMax(childComplexity), true

	case "PendingUserAggregateResult.tokenMin":
		if e.complexity.PendingUserAggregateResult.TokenMin == nil {
			break
		}

		return e.complexity.PendingUserAggregateResult.TokenMin(childComplexity), true

	case "PendingUserAggregateResult.updatedAtMax":
		if e.complexity.PendingUserAggregateResult.UpdatedAtMax == nil {
			break
		}

		return e.complexity.PendingUserAggregateResult.UpdatedAtMax(childComplexity), true

	case "PendingUserAggregateResult.updatedAtMin":
		if e.complexity.PendingUserAggregateResult.UpdatedAtMin == nil {
			break
		}

		return e.complexity.PendingUserAggregateResult.UpdatedAtMin(childComplexity), true

	case "PendingUserAggregateResult.usernameMax":
		if e.complexity.PendingUserAggregateResult.UsernameMax == nil {
			break
		}

		return e.complexity.PendingUserAggregateResult.UsernameMax(childComplexity), true

	case "PendingUserAggregateResult.usernameMin":
		if e.complexity.PendingUserAggregateResult.UsernameMin == nil {
			break
		}

		return e.complexity.PendingUserAggregateResult.UsernameMin(childComplexity), true

	case "Point.latitude":
		if e.complexity.Point.Latitude == nil {
			break
		}

		return e.complexity.Point.Latitude(childComplexity), true

	case "Point.longitude":
		if e.complexity.Point.Longitude == nil {
			break
		}

		return e.complexity.Point.Longitude(childComplexity), true

	case "PointList.points":
		if e.complexity.PointList.Points == nil {
			break
		}

		return e.complexity.PointList.Points(childComplexity), true

	case "Polygon.coordinates":
		if e.complexity.Polygon.Coordinates == nil {
			break
		}

		return e.complexity.Polygon.Coordinates(childComplexity), true

	case "Post.createdAt":
		if e.complexity.Post.CreatedAt == nil {
			break
		}

		return e.complexity.Post.CreatedAt(childComplexity), true

	case "Post.createdBy":
		if e.complexity.Post.CreatedBy == nil {
			break
		}

		args, err := ec.field_Post_createdBy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Post.CreatedBy(childComplexity, args["filter"].(*model.UserFilter)), true

	case "Post.id":
		if e.complexity.Post.ID == nil {
			break
		}

		return e.complexity.Post.ID(childComplexity), true

	case "Post.message":
		if e.complexity.Post.Message == nil {
			break
		}

		return e.complexity.Post.Message(childComplexity), true

	case "Post.updatedAt":
		if e.complexity.Post.UpdatedAt == nil {
			break
		}

		return e.complexity.Post.UpdatedAt(childComplexity), true

	case "PostAggregateResult.count":
		if e.complexity.PostAggregateResult.Count == nil {
			break
		}

		return e.complexity.PostAggregateResult.Count(childComplexity), true

	case "PostAggregateResult.createdAtMax":
		if e.complexity.PostAggregateResult.CreatedAtMax == nil {
			break
		}

		return e.complexity.PostAggregateResult.CreatedAtMax(childComplexity), true

	case "PostAggregateResult.createdAtMin":
		if e.complexity.PostAggregateResult.CreatedAtMin == nil {
			break
		}

		return e.complexity.PostAggregateResult.CreatedAtMin(childComplexity), true

	case "PostAggregateResult.messageMax":
		if e.complexity.PostAggregateResult.MessageMax == nil {
			break
		}

		return e.complexity.PostAggregateResult.MessageMax(childComplexity), true

	case "PostAggregateResult.messageMin":
		if e.complexity.PostAggregateResult.MessageMin == nil {
			break
		}

		return e.complexity.PostAggregateResult.MessageMin(childComplexity), true

	case "PostAggregateResult.updatedAtMax":
		if e.complexity.PostAggregateResult.UpdatedAtMax == nil {
			break
		}

		return e.complexity.PostAggregateResult.UpdatedAtMax(childComplexity), true

	case "PostAggregateResult.updatedAtMin":
		if e.complexity.PostAggregateResult.UpdatedAtMin == nil {
			break
		}

		return e.complexity.PostAggregateResult.UpdatedAtMin(childComplexity), true

	case "Project.columns":
		if e.complexity.Project.Columns == nil {
			break
		}

		args, err := ec.field_Project_columns_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Project.Columns(childComplexity, args["filter"].(*model.ProjectColumnFilter), args["order"].(*model.ProjectColumnOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Project.columnsAggregate":
		if e.complexity.Project.ColumnsAggregate == nil {
			break
		}

		args, err := ec.field_Project_columnsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Project.ColumnsAggregate(childComplexity, args["filter"].(*model.ProjectColumnFilter)), true

	case "Project.createdAt":
		if e.complexity.Project.CreatedAt == nil {
			break
		}

		return e.complexity.Project.CreatedAt(childComplexity), true

	case "Project.createdBy":
		if e.complexity.Project.CreatedBy == nil {
			break
		}

		args, err := ec.field_Project_createdBy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Project.CreatedBy(childComplexity, args["filter"].(*model.UserFilter)), true

	case "Project.description":
		if e.complexity.Project.Description == nil {
			break
		}

		return e.complexity.Project.Description(childComplexity), true

	case "Project.fields":
		if e.complexity.Project.Fields == nil {
			break
		}

		args, err := ec.field_Project_fields_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Project.Fields(childComplexity, args["filter"].(*model.ProjectFieldFilter), args["first"].(*int), args["offset"].(*int)), true

	case "Project.fieldsAggregate":
		if e.complexity.Project.FieldsAggregate == nil {
			break
		}

		args, err := ec.field_Project_fieldsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Project.FieldsAggregate(childComplexity, args["filter"].(*model.ProjectFieldFilter)), true

	case "Project.id":
		if e.complexity.Project.ID == nil {
			break
		}

		return e.complexity.Project.ID(childComplexity), true

	case "Project.leaders":
		if e.complexity.Project.Leaders == nil {
			break
		}

		args, err := ec.field_Project_leaders_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Project.Leaders(childComplexity, args["filter"].(*model.NodeFilter), args["order"].(*model.NodeOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Project.leadersAggregate":
		if e.complexity.Project.LeadersAggregate == nil {
			break
		}

		args, err := ec.field_Project_leadersAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Project.LeadersAggregate(childComplexity, args["filter"].(*model.NodeFilter)), true

	case "Project.name":
		if e.complexity.Project.Name == nil {
			break
		}

		return e.complexity.Project.Name(childComplexity), true

	case "Project.nameid":
		if e.complexity.Project.Nameid == nil {
			break
		}

		return e.complexity.Project.Nameid(childComplexity), true

	case "Project.nodes":
		if e.complexity.Project.Nodes == nil {
			break
		}

		args, err := ec.field_Project_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Project.Nodes(childComplexity, args["filter"].(*model.NodeFilter), args["order"].(*model.NodeOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Project.nodesAggregate":
		if e.complexity.Project.NodesAggregate == nil {
			break
		}

		args, err := ec.field_Project_nodesAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Project.NodesAggregate(childComplexity, args["filter"].(*model.NodeFilter)), true

	case "Project.parentnameid":
		if e.complexity.Project.Parentnameid == nil {
			break
		}

		return e.complexity.Project.Parentnameid(childComplexity), true

	case "Project.rootnameid":
		if e.complexity.Project.Rootnameid == nil {
			break
		}

		return e.complexity.Project.Rootnameid(childComplexity), true

	case "Project.status":
		if e.complexity.Project.Status == nil {
			break
		}

		return e.complexity.Project.Status(childComplexity), true

	case "Project.updatedAt":
		if e.complexity.Project.UpdatedAt == nil {
			break
		}

		return e.complexity.Project.UpdatedAt(childComplexity), true

	case "ProjectAggregateResult.count":
		if e.complexity.ProjectAggregateResult.Count == nil {
			break
		}

		return e.complexity.ProjectAggregateResult.Count(childComplexity), true

	case "ProjectAggregateResult.createdAtMax":
		if e.complexity.ProjectAggregateResult.CreatedAtMax == nil {
			break
		}

		return e.complexity.ProjectAggregateResult.CreatedAtMax(childComplexity), true

	case "ProjectAggregateResult.createdAtMin":
		if e.complexity.ProjectAggregateResult.CreatedAtMin == nil {
			break
		}

		return e.complexity.ProjectAggregateResult.CreatedAtMin(childComplexity), true

	case "ProjectAggregateResult.descriptionMax":
		if e.complexity.ProjectAggregateResult.DescriptionMax == nil {
			break
		}

		return e.complexity.ProjectAggregateResult.DescriptionMax(childComplexity), true

	case "ProjectAggregateResult.descriptionMin":
		if e.complexity.ProjectAggregateResult.DescriptionMin == nil {
			break
		}

		return e.complexity.ProjectAggregateResult.DescriptionMin(childComplexity), true

	case "ProjectAggregateResult.nameMax":
		if e.complexity.ProjectAggregateResult.NameMax == nil {
			break
		}

		return e.complexity.ProjectAggregateResult.NameMax(childComplexity), true

	case "ProjectAggregateResult.nameMin":
		if e.complexity.ProjectAggregateResult.NameMin == nil {
			break
		}

		return e.complexity.ProjectAggregateResult.NameMin(childComplexity), true

	case "ProjectAggregateResult.nameidMax":
		if e.complexity.ProjectAggregateResult.NameidMax == nil {
			break
		}

		return e.complexity.ProjectAggregateResult.NameidMax(childComplexity), true

	case "ProjectAggregateResult.nameidMin":
		if e.complexity.ProjectAggregateResult.NameidMin == nil {
			break
		}

		return e.complexity.ProjectAggregateResult.NameidMin(childComplexity), true

	case "ProjectAggregateResult.parentnameidMax":
		if e.complexity.ProjectAggregateResult.ParentnameidMax == nil {
			break
		}

		return e.complexity.ProjectAggregateResult.ParentnameidMax(childComplexity), true

	case "ProjectAggregateResult.parentnameidMin":
		if e.complexity.ProjectAggregateResult.ParentnameidMin == nil {
			break
		}

		return e.complexity.ProjectAggregateResult.ParentnameidMin(childComplexity), true

	case "ProjectAggregateResult.rootnameidMax":
		if e.complexity.ProjectAggregateResult.RootnameidMax == nil {
			break
		}

		return e.complexity.ProjectAggregateResult.RootnameidMax(childComplexity), true

	case "ProjectAggregateResult.rootnameidMin":
		if e.complexity.ProjectAggregateResult.RootnameidMin == nil {
			break
		}

		return e.complexity.ProjectAggregateResult.RootnameidMin(childComplexity), true

	case "ProjectAggregateResult.updatedAtMax":
		if e.complexity.ProjectAggregateResult.UpdatedAtMax == nil {
			break
		}

		return e.complexity.ProjectAggregateResult.UpdatedAtMax(childComplexity), true

	case "ProjectAggregateResult.updatedAtMin":
		if e.complexity.ProjectAggregateResult.UpdatedAtMin == nil {
			break
		}

		return e.complexity.ProjectAggregateResult.UpdatedAtMin(childComplexity), true

	case "ProjectCard.card":
		if e.complexity.ProjectCard.Card == nil {
			break
		}

		args, err := ec.field_ProjectCard_card_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ProjectCard.Card(childComplexity, args["filter"].(*model.CardKindFilter)), true

	case "ProjectCard.id":
		if e.complexity.ProjectCard.ID == nil {
			break
		}

		return e.complexity.ProjectCard.ID(childComplexity), true

	case "ProjectCard.pc":
		if e.complexity.ProjectCard.Pc == nil {
			break
		}

		args, err := ec.field_ProjectCard_pc_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ProjectCard.Pc(childComplexity, args["filter"].(*model.ProjectColumnFilter)), true

	case "ProjectCard.pos":
		if e.complexity.ProjectCard.Pos == nil {
			break
		}

		return e.complexity.ProjectCard.Pos(childComplexity), true

	case "ProjectCard.values":
		if e.complexity.ProjectCard.Values == nil {
			break
		}

		args, err := ec.field_ProjectCard_values_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ProjectCard.Values(childComplexity, args["filter"].(*model.ProjectFieldValueFilter), args["order"].(*model.ProjectFieldValueOrder), args["first"].(*int), args["offset"].(*int)), true

	case "ProjectCard.valuesAggregate":
		if e.complexity.ProjectCard.ValuesAggregate == nil {
			break
		}

		args, err := ec.field_ProjectCard_valuesAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ProjectCard.ValuesAggregate(childComplexity, args["filter"].(*model.ProjectFieldValueFilter)), true

	case "ProjectCardAggregateResult.count":
		if e.complexity.ProjectCardAggregateResult.Count == nil {
			break
		}

		return e.complexity.ProjectCardAggregateResult.Count(childComplexity), true

	case "ProjectCardAggregateResult.posAvg":
		if e.complexity.ProjectCardAggregateResult.PosAvg == nil {
			break
		}

		return e.complexity.ProjectCardAggregateResult.PosAvg(childComplexity), true

	case "ProjectCardAggregateResult.posMax":
		if e.complexity.ProjectCardAggregateResult.PosMax == nil {
			break
		}

		return e.complexity.ProjectCardAggregateResult.PosMax(childComplexity), true

	case "ProjectCardAggregateResult.posMin":
		if e.complexity.ProjectCardAggregateResult.PosMin == nil {
			break
		}

		return e.complexity.ProjectCardAggregateResult.PosMin(childComplexity), true

	case "ProjectCardAggregateResult.posSum":
		if e.complexity.ProjectCardAggregateResult.PosSum == nil {
			break
		}

		return e.complexity.ProjectCardAggregateResult.PosSum(childComplexity), true

	case "ProjectColumn.cards":
		if e.complexity.ProjectColumn.Cards == nil {
			break
		}

		args, err := ec.field_ProjectColumn_cards_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ProjectColumn.Cards(childComplexity, args["filter"].(*model.ProjectCardFilter), args["order"].(*model.ProjectCardOrder), args["first"].(*int), args["offset"].(*int)), true

	case "ProjectColumn.cardsAggregate":
		if e.complexity.ProjectColumn.CardsAggregate == nil {
			break
		}

		args, err := ec.field_ProjectColumn_cardsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ProjectColumn.CardsAggregate(childComplexity, args["filter"].(*model.ProjectCardFilter)), true

	case "ProjectColumn.col_type":
		if e.complexity.ProjectColumn.ColType == nil {
			break
		}

		return e.complexity.ProjectColumn.ColType(childComplexity), true

	case "ProjectColumn.color":
		if e.complexity.ProjectColumn.Color == nil {
			break
		}

		return e.complexity.ProjectColumn.Color(childComplexity), true

	case "ProjectColumn.description":
		if e.complexity.ProjectColumn.Description == nil {
			break
		}

		return e.complexity.ProjectColumn.Description(childComplexity), true

	case "ProjectColumn.id":
		if e.complexity.ProjectColumn.ID == nil {
			break
		}

		return e.complexity.ProjectColumn.ID(childComplexity), true

	case "ProjectColumn.name":
		if e.complexity.ProjectColumn.Name == nil {
			break
		}

		return e.complexity.ProjectColumn.Name(childComplexity), true

	case "ProjectColumn.pos":
		if e.complexity.ProjectColumn.Pos == nil {
			break
		}

		return e.complexity.ProjectColumn.Pos(childComplexity), true

	case "ProjectColumn.project":
		if e.complexity.ProjectColumn.Project == nil {
			break
		}

		args, err := ec.field_ProjectColumn_project_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ProjectColumn.Project(childComplexity, args["filter"].(*model.ProjectFilter)), true

	case "ProjectColumn.tensions":
		if e.complexity.ProjectColumn.Tensions == nil {
			break
		}

		args, err := ec.field_ProjectColumn_tensions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ProjectColumn.Tensions(childComplexity, args["filter"].(*model.TensionFilter), args["order"].(*model.TensionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "ProjectColumn.tensionsAggregate":
		if e.complexity.ProjectColumn.TensionsAggregate == nil {
			break
		}

		args, err := ec.field_ProjectColumn_tensionsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ProjectColumn.TensionsAggregate(childComplexity, args["filter"].(*model.TensionFilter)), true

	case "ProjectColumnAggregateResult.colorMax":
		if e.complexity.ProjectColumnAggregateResult.ColorMax == nil {
			break
		}

		return e.complexity.ProjectColumnAggregateResult.ColorMax(childComplexity), true

	case "ProjectColumnAggregateResult.colorMin":
		if e.complexity.ProjectColumnAggregateResult.ColorMin == nil {
			break
		}

		return e.complexity.ProjectColumnAggregateResult.ColorMin(childComplexity), true

	case "ProjectColumnAggregateResult.count":
		if e.complexity.ProjectColumnAggregateResult.Count == nil {
			break
		}

		return e.complexity.ProjectColumnAggregateResult.Count(childComplexity), true

	case "ProjectColumnAggregateResult.descriptionMax":
		if e.complexity.ProjectColumnAggregateResult.DescriptionMax == nil {
			break
		}

		return e.complexity.ProjectColumnAggregateResult.DescriptionMax(childComplexity), true

	case "ProjectColumnAggregateResult.descriptionMin":
		if e.complexity.ProjectColumnAggregateResult.DescriptionMin == nil {
			break
		}

		return e.complexity.ProjectColumnAggregateResult.DescriptionMin(childComplexity), true

	case "ProjectColumnAggregateResult.nameMax":
		if e.complexity.ProjectColumnAggregateResult.NameMax == nil {
			break
		}

		return e.complexity.ProjectColumnAggregateResult.NameMax(childComplexity), true

	case "ProjectColumnAggregateResult.nameMin":
		if e.complexity.ProjectColumnAggregateResult.NameMin == nil {
			break
		}

		return e.complexity.ProjectColumnAggregateResult.NameMin(childComplexity), true

	case "ProjectColumnAggregateResult.posAvg":
		if e.complexity.ProjectColumnAggregateResult.PosAvg == nil {
			break
		}

		return e.complexity.ProjectColumnAggregateResult.PosAvg(childComplexity), true

	case "ProjectColumnAggregateResult.posMax":
		if e.complexity.ProjectColumnAggregateResult.PosMax == nil {
			break
		}

		return e.complexity.ProjectColumnAggregateResult.PosMax(childComplexity), true

	case "ProjectColumnAggregateResult.posMin":
		if e.complexity.ProjectColumnAggregateResult.PosMin == nil {
			break
		}

		return e.complexity.ProjectColumnAggregateResult.PosMin(childComplexity), true

	case "ProjectColumnAggregateResult.posSum":
		if e.complexity.ProjectColumnAggregateResult.PosSum == nil {
			break
		}

		return e.complexity.ProjectColumnAggregateResult.PosSum(childComplexity), true

	case "ProjectDraft.createdAt":
		if e.complexity.ProjectDraft.CreatedAt == nil {
			break
		}

		return e.complexity.ProjectDraft.CreatedAt(childComplexity), true

	case "ProjectDraft.createdBy":
		if e.complexity.ProjectDraft.CreatedBy == nil {
			break
		}

		args, err := ec.field_ProjectDraft_createdBy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ProjectDraft.CreatedBy(childComplexity, args["filter"].(*model.UserFilter)), true

	case "ProjectDraft.id":
		if e.complexity.ProjectDraft.ID == nil {
			break
		}

		return e.complexity.ProjectDraft.ID(childComplexity), true

	case "ProjectDraft.message":
		if e.complexity.ProjectDraft.Message == nil {
			break
		}

		return e.complexity.ProjectDraft.Message(childComplexity), true

	case "ProjectDraft.title":
		if e.complexity.ProjectDraft.Title == nil {
			break
		}

		return e.complexity.ProjectDraft.Title(childComplexity), true

	case "ProjectDraft.updatedAt":
		if e.complexity.ProjectDraft.UpdatedAt == nil {
			break
		}

		return e.complexity.ProjectDraft.UpdatedAt(childComplexity), true

	case "ProjectDraftAggregateResult.count":
		if e.complexity.ProjectDraftAggregateResult.Count == nil {
			break
		}

		return e.complexity.ProjectDraftAggregateResult.Count(childComplexity), true

	case "ProjectDraftAggregateResult.createdAtMax":
		if e.complexity.ProjectDraftAggregateResult.CreatedAtMax == nil {
			break
		}

		return e.complexity.ProjectDraftAggregateResult.CreatedAtMax(childComplexity), true

	case "ProjectDraftAggregateResult.createdAtMin":
		if e.complexity.ProjectDraftAggregateResult.CreatedAtMin == nil {
			break
		}

		return e.complexity.ProjectDraftAggregateResult.CreatedAtMin(childComplexity), true

	case "ProjectDraftAggregateResult.messageMax":
		if e.complexity.ProjectDraftAggregateResult.MessageMax == nil {
			break
		}

		return e.complexity.ProjectDraftAggregateResult.MessageMax(childComplexity), true

	case "ProjectDraftAggregateResult.messageMin":
		if e.complexity.ProjectDraftAggregateResult.MessageMin == nil {
			break
		}

		return e.complexity.ProjectDraftAggregateResult.MessageMin(childComplexity), true

	case "ProjectDraftAggregateResult.titleMax":
		if e.complexity.ProjectDraftAggregateResult.TitleMax == nil {
			break
		}

		return e.complexity.ProjectDraftAggregateResult.TitleMax(childComplexity), true

	case "ProjectDraftAggregateResult.titleMin":
		if e.complexity.ProjectDraftAggregateResult.TitleMin == nil {
			break
		}

		return e.complexity.ProjectDraftAggregateResult.TitleMin(childComplexity), true

	case "ProjectDraftAggregateResult.updatedAtMax":
		if e.complexity.ProjectDraftAggregateResult.UpdatedAtMax == nil {
			break
		}

		return e.complexity.ProjectDraftAggregateResult.UpdatedAtMax(childComplexity), true

	case "ProjectDraftAggregateResult.updatedAtMin":
		if e.complexity.ProjectDraftAggregateResult.UpdatedAtMin == nil {
			break
		}

		return e.complexity.ProjectDraftAggregateResult.UpdatedAtMin(childComplexity), true

	case "ProjectField.field_type":
		if e.complexity.ProjectField.FieldType == nil {
			break
		}

		return e.complexity.ProjectField.FieldType(childComplexity), true

	case "ProjectField.isVisible":
		if e.complexity.ProjectField.IsVisible == nil {
			break
		}

		return e.complexity.ProjectField.IsVisible(childComplexity), true

	case "ProjectField.values":
		if e.complexity.ProjectField.Values == nil {
			break
		}

		args, err := ec.field_ProjectField_values_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ProjectField.Values(childComplexity, args["filter"].(*model.ProjectFieldValueFilter), args["order"].(*model.ProjectFieldValueOrder), args["first"].(*int), args["offset"].(*int)), true

	case "ProjectField.valuesAggregate":
		if e.complexity.ProjectField.ValuesAggregate == nil {
			break
		}

		args, err := ec.field_ProjectField_valuesAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ProjectField.ValuesAggregate(childComplexity, args["filter"].(*model.ProjectFieldValueFilter)), true

	case "ProjectFieldAggregateResult.count":
		if e.complexity.ProjectFieldAggregateResult.Count == nil {
			break
		}

		return e.complexity.ProjectFieldAggregateResult.Count(childComplexity), true

	case "ProjectFieldValue.field":
		if e.complexity.ProjectFieldValue.Field == nil {
			break
		}

		args, err := ec.field_ProjectFieldValue_field_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ProjectFieldValue.Field(childComplexity, args["filter"].(*model.ProjectFieldFilter)), true

	case "ProjectFieldValue.pos":
		if e.complexity.ProjectFieldValue.Pos == nil {
			break
		}

		return e.complexity.ProjectFieldValue.Pos(childComplexity), true

	case "ProjectFieldValue.value":
		if e.complexity.ProjectFieldValue.Value == nil {
			break
		}

		return e.complexity.ProjectFieldValue.Value(childComplexity), true

	case "ProjectFieldValueAggregateResult.count":
		if e.complexity.ProjectFieldValueAggregateResult.Count == nil {
			break
		}

		return e.complexity.ProjectFieldValueAggregateResult.Count(childComplexity), true

	case "ProjectFieldValueAggregateResult.posAvg":
		if e.complexity.ProjectFieldValueAggregateResult.PosAvg == nil {
			break
		}

		return e.complexity.ProjectFieldValueAggregateResult.PosAvg(childComplexity), true

	case "ProjectFieldValueAggregateResult.posMax":
		if e.complexity.ProjectFieldValueAggregateResult.PosMax == nil {
			break
		}

		return e.complexity.ProjectFieldValueAggregateResult.PosMax(childComplexity), true

	case "ProjectFieldValueAggregateResult.posMin":
		if e.complexity.ProjectFieldValueAggregateResult.PosMin == nil {
			break
		}

		return e.complexity.ProjectFieldValueAggregateResult.PosMin(childComplexity), true

	case "ProjectFieldValueAggregateResult.posSum":
		if e.complexity.ProjectFieldValueAggregateResult.PosSum == nil {
			break
		}

		return e.complexity.ProjectFieldValueAggregateResult.PosSum(childComplexity), true

	case "ProjectFieldValueAggregateResult.valueMax":
		if e.complexity.ProjectFieldValueAggregateResult.ValueMax == nil {
			break
		}

		return e.complexity.ProjectFieldValueAggregateResult.ValueMax(childComplexity), true

	case "ProjectFieldValueAggregateResult.valueMin":
		if e.complexity.ProjectFieldValueAggregateResult.ValueMin == nil {
			break
		}

		return e.complexity.ProjectFieldValueAggregateResult.ValueMin(childComplexity), true

	case "Query.aggregateBlob":
		if e.complexity.Query.AggregateBlob == nil {
			break
		}

		args, err := ec.field_Query_aggregateBlob_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateBlob(childComplexity, args["filter"].(*model.BlobFilter)), true

	case "Query.aggregateComment":
		if e.complexity.Query.AggregateComment == nil {
			break
		}

		args, err := ec.field_Query_aggregateComment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateComment(childComplexity, args["filter"].(*model.CommentFilter)), true

	case "Query.aggregateContract":
		if e.complexity.Query.AggregateContract == nil {
			break
		}

		args, err := ec.field_Query_aggregateContract_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateContract(childComplexity, args["filter"].(*model.ContractFilter)), true

	case "Query.aggregateEvent":
		if e.complexity.Query.AggregateEvent == nil {
			break
		}

		args, err := ec.field_Query_aggregateEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateEvent(childComplexity, args["filter"].(*model.EventFilter)), true

	case "Query.aggregateEventCount":
		if e.complexity.Query.AggregateEventCount == nil {
			break
		}

		args, err := ec.field_Query_aggregateEventCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateEventCount(childComplexity, args["filter"].(*model.EventCountFilter)), true

	case "Query.aggregateEventFragment":
		if e.complexity.Query.AggregateEventFragment == nil {
			break
		}

		args, err := ec.field_Query_aggregateEventFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateEventFragment(childComplexity, args["filter"].(*model.EventFragmentFilter)), true

	case "Query.aggregateLabel":
		if e.complexity.Query.AggregateLabel == nil {
			break
		}

		args, err := ec.field_Query_aggregateLabel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateLabel(childComplexity, args["filter"].(*model.LabelFilter)), true

	case "Query.aggregateMandate":
		if e.complexity.Query.AggregateMandate == nil {
			break
		}

		args, err := ec.field_Query_aggregateMandate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateMandate(childComplexity, args["filter"].(*model.MandateFilter)), true

	case "Query.aggregateNode":
		if e.complexity.Query.AggregateNode == nil {
			break
		}

		args, err := ec.field_Query_aggregateNode_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateNode(childComplexity, args["filter"].(*model.NodeFilter)), true

	case "Query.aggregateNodeFragment":
		if e.complexity.Query.AggregateNodeFragment == nil {
			break
		}

		args, err := ec.field_Query_aggregateNodeFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateNodeFragment(childComplexity, args["filter"].(*model.NodeFragmentFilter)), true

	case "Query.aggregateNotif":
		if e.complexity.Query.AggregateNotif == nil {
			break
		}

		args, err := ec.field_Query_aggregateNotif_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateNotif(childComplexity, args["filter"].(*model.NotifFilter)), true

	case "Query.aggregatePendingUser":
		if e.complexity.Query.AggregatePendingUser == nil {
			break
		}

		args, err := ec.field_Query_aggregatePendingUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregatePendingUser(childComplexity, args["filter"].(*model.PendingUserFilter)), true

	case "Query.aggregatePost":
		if e.complexity.Query.AggregatePost == nil {
			break
		}

		args, err := ec.field_Query_aggregatePost_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregatePost(childComplexity, args["filter"].(*model.PostFilter)), true

	case "Query.aggregateProject":
		if e.complexity.Query.AggregateProject == nil {
			break
		}

		args, err := ec.field_Query_aggregateProject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateProject(childComplexity, args["filter"].(*model.ProjectFilter)), true

	case "Query.aggregateProjectCard":
		if e.complexity.Query.AggregateProjectCard == nil {
			break
		}

		args, err := ec.field_Query_aggregateProjectCard_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateProjectCard(childComplexity, args["filter"].(*model.ProjectCardFilter)), true

	case "Query.aggregateProjectColumn":
		if e.complexity.Query.AggregateProjectColumn == nil {
			break
		}

		args, err := ec.field_Query_aggregateProjectColumn_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateProjectColumn(childComplexity, args["filter"].(*model.ProjectColumnFilter)), true

	case "Query.aggregateProjectDraft":
		if e.complexity.Query.AggregateProjectDraft == nil {
			break
		}

		args, err := ec.field_Query_aggregateProjectDraft_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateProjectDraft(childComplexity, args["filter"].(*model.ProjectDraftFilter)), true

	case "Query.aggregateProjectField":
		if e.complexity.Query.AggregateProjectField == nil {
			break
		}

		args, err := ec.field_Query_aggregateProjectField_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateProjectField(childComplexity, args["filter"].(*model.ProjectFieldFilter)), true

	case "Query.aggregateProjectFieldValue":
		if e.complexity.Query.AggregateProjectFieldValue == nil {
			break
		}

		args, err := ec.field_Query_aggregateProjectFieldValue_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateProjectFieldValue(childComplexity, args["filter"].(*model.ProjectFieldValueFilter)), true

	case "Query.aggregateReaction":
		if e.complexity.Query.AggregateReaction == nil {
			break
		}

		args, err := ec.field_Query_aggregateReaction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateReaction(childComplexity, args["filter"].(*model.ReactionFilter)), true

	case "Query.aggregateRoleExt":
		if e.complexity.Query.AggregateRoleExt == nil {
			break
		}

		args, err := ec.field_Query_aggregateRoleExt_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateRoleExt(childComplexity, args["filter"].(*model.RoleExtFilter)), true

	case "Query.aggregateTension":
		if e.complexity.Query.AggregateTension == nil {
			break
		}

		args, err := ec.field_Query_aggregateTension_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateTension(childComplexity, args["filter"].(*model.TensionFilter)), true

	case "Query.aggregateUser":
		if e.complexity.Query.AggregateUser == nil {
			break
		}

		args, err := ec.field_Query_aggregateUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateUser(childComplexity, args["filter"].(*model.UserFilter)), true

	case "Query.aggregateUserEvent":
		if e.complexity.Query.AggregateUserEvent == nil {
			break
		}

		args, err := ec.field_Query_aggregateUserEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateUserEvent(childComplexity, args["filter"].(*model.UserEventFilter)), true

	case "Query.aggregateUserRights":
		if e.complexity.Query.AggregateUserRights == nil {
			break
		}

		args, err := ec.field_Query_aggregateUserRights_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateUserRights(childComplexity, args["filter"].(*model.UserRightsFilter)), true

	case "Query.aggregateVote":
		if e.complexity.Query.AggregateVote == nil {
			break
		}

		args, err := ec.field_Query_aggregateVote_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateVote(childComplexity, args["filter"].(*model.VoteFilter)), true

	case "Query.getBlob":
		if e.complexity.Query.GetBlob == nil {
			break
		}

		args, err := ec.field_Query_getBlob_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetBlob(childComplexity, args["id"].(string)), true

	case "Query.getComment":
		if e.complexity.Query.GetComment == nil {
			break
		}

		args, err := ec.field_Query_getComment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetComment(childComplexity, args["id"].(string)), true

	case "Query.getContract":
		if e.complexity.Query.GetContract == nil {
			break
		}

		args, err := ec.field_Query_getContract_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetContract(childComplexity, args["id"].(*string), args["contractid"].(*string)), true

	case "Query.getEvent":
		if e.complexity.Query.GetEvent == nil {
			break
		}

		args, err := ec.field_Query_getEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetEvent(childComplexity, args["id"].(string)), true

	case "Query.getLabel":
		if e.complexity.Query.GetLabel == nil {
			break
		}

		args, err := ec.field_Query_getLabel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetLabel(childComplexity, args["id"].(string)), true

	case "Query.getMandate":
		if e.complexity.Query.GetMandate == nil {
			break
		}

		args, err := ec.field_Query_getMandate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMandate(childComplexity, args["id"].(string)), true

	case "Query.getNode":
		if e.complexity.Query.GetNode == nil {
			break
		}

		args, err := ec.field_Query_getNode_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetNode(childComplexity, args["id"].(*string), args["nameid"].(*string)), true

	case "Query.getNodeFragment":
		if e.complexity.Query.GetNodeFragment == nil {
			break
		}

		args, err := ec.field_Query_getNodeFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetNodeFragment(childComplexity, args["id"].(string)), true

	case "Query.getNotif":
		if e.complexity.Query.GetNotif == nil {
			break
		}

		args, err := ec.field_Query_getNotif_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetNotif(childComplexity, args["id"].(string)), true

	case "Query.getPendingUser":
		if e.complexity.Query.GetPendingUser == nil {
			break
		}

		args, err := ec.field_Query_getPendingUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetPendingUser(childComplexity, args["id"].(*string), args["username"].(*string), args["email"].(*string)), true

	case "Query.getPost":
		if e.complexity.Query.GetPost == nil {
			break
		}

		args, err := ec.field_Query_getPost_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetPost(childComplexity, args["id"].(string)), true

	case "Query.getProject":
		if e.complexity.Query.GetProject == nil {
			break
		}

		args, err := ec.field_Query_getProject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetProject(childComplexity, args["id"].(string)), true

	case "Query.getProjectCard":
		if e.complexity.Query.GetProjectCard == nil {
			break
		}

		args, err := ec.field_Query_getProjectCard_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetProjectCard(childComplexity, args["id"].(string)), true

	case "Query.getProjectColumn":
		if e.complexity.Query.GetProjectColumn == nil {
			break
		}

		args, err := ec.field_Query_getProjectColumn_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetProjectColumn(childComplexity, args["id"].(string)), true

	case "Query.getProjectDraft":
		if e.complexity.Query.GetProjectDraft == nil {
			break
		}

		args, err := ec.field_Query_getProjectDraft_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetProjectDraft(childComplexity, args["id"].(string)), true

	case "Query.getReaction":
		if e.complexity.Query.GetReaction == nil {
			break
		}

		args, err := ec.field_Query_getReaction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetReaction(childComplexity, args["id"].(*string), args["reactionid"].(*string)), true

	case "Query.getRoleExt":
		if e.complexity.Query.GetRoleExt == nil {
			break
		}

		args, err := ec.field_Query_getRoleExt_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetRoleExt(childComplexity, args["id"].(string)), true

	case "Query.getTension":
		if e.complexity.Query.GetTension == nil {
			break
		}

		args, err := ec.field_Query_getTension_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetTension(childComplexity, args["id"].(string)), true

	case "Query.getUser":
		if e.complexity.Query.GetUser == nil {
			break
		}

		args, err := ec.field_Query_getUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetUser(childComplexity, args["id"].(*string), args["username"].(*string), args["email"].(*string)), true

	case "Query.getUserEvent":
		if e.complexity.Query.GetUserEvent == nil {
			break
		}

		args, err := ec.field_Query_getUserEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetUserEvent(childComplexity, args["id"].(string)), true

	case "Query.getVote":
		if e.complexity.Query.GetVote == nil {
			break
		}

		args, err := ec.field_Query_getVote_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetVote(childComplexity, args["id"].(*string), args["voteid"].(*string)), true

	case "Query.queryBlob":
		if e.complexity.Query.QueryBlob == nil {
			break
		}

		args, err := ec.field_Query_queryBlob_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryBlob(childComplexity, args["filter"].(*model.BlobFilter), args["order"].(*model.BlobOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryComment":
		if e.complexity.Query.QueryComment == nil {
			break
		}

		args, err := ec.field_Query_queryComment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryComment(childComplexity, args["filter"].(*model.CommentFilter), args["order"].(*model.CommentOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryContract":
		if e.complexity.Query.QueryContract == nil {
			break
		}

		args, err := ec.field_Query_queryContract_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryContract(childComplexity, args["filter"].(*model.ContractFilter), args["order"].(*model.ContractOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryEvent":
		if e.complexity.Query.QueryEvent == nil {
			break
		}

		args, err := ec.field_Query_queryEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryEvent(childComplexity, args["filter"].(*model.EventFilter), args["order"].(*model.EventOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryEventCount":
		if e.complexity.Query.QueryEventCount == nil {
			break
		}

		args, err := ec.field_Query_queryEventCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryEventCount(childComplexity, args["filter"].(*model.EventCountFilter), args["order"].(*model.EventCountOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryEventFragment":
		if e.complexity.Query.QueryEventFragment == nil {
			break
		}

		args, err := ec.field_Query_queryEventFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryEventFragment(childComplexity, args["filter"].(*model.EventFragmentFilter), args["order"].(*model.EventFragmentOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryLabel":
		if e.complexity.Query.QueryLabel == nil {
			break
		}

		args, err := ec.field_Query_queryLabel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryLabel(childComplexity, args["filter"].(*model.LabelFilter), args["order"].(*model.LabelOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryMandate":
		if e.complexity.Query.QueryMandate == nil {
			break
		}

		args, err := ec.field_Query_queryMandate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryMandate(childComplexity, args["filter"].(*model.MandateFilter), args["order"].(*model.MandateOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryNode":
		if e.complexity.Query.QueryNode == nil {
			break
		}

		args, err := ec.field_Query_queryNode_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryNode(childComplexity, args["filter"].(*model.NodeFilter), args["order"].(*model.NodeOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryNodeFragment":
		if e.complexity.Query.QueryNodeFragment == nil {
			break
		}

		args, err := ec.field_Query_queryNodeFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryNodeFragment(childComplexity, args["filter"].(*model.NodeFragmentFilter), args["order"].(*model.NodeFragmentOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryNotif":
		if e.complexity.Query.QueryNotif == nil {
			break
		}

		args, err := ec.field_Query_queryNotif_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryNotif(childComplexity, args["filter"].(*model.NotifFilter), args["order"].(*model.NotifOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryPendingUser":
		if e.complexity.Query.QueryPendingUser == nil {
			break
		}

		args, err := ec.field_Query_queryPendingUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryPendingUser(childComplexity, args["filter"].(*model.PendingUserFilter), args["order"].(*model.PendingUserOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryPost":
		if e.complexity.Query.QueryPost == nil {
			break
		}

		args, err := ec.field_Query_queryPost_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryPost(childComplexity, args["filter"].(*model.PostFilter), args["order"].(*model.PostOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryProject":
		if e.complexity.Query.QueryProject == nil {
			break
		}

		args, err := ec.field_Query_queryProject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryProject(childComplexity, args["filter"].(*model.ProjectFilter), args["order"].(*model.ProjectOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryProjectCard":
		if e.complexity.Query.QueryProjectCard == nil {
			break
		}

		args, err := ec.field_Query_queryProjectCard_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryProjectCard(childComplexity, args["filter"].(*model.ProjectCardFilter), args["order"].(*model.ProjectCardOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryProjectColumn":
		if e.complexity.Query.QueryProjectColumn == nil {
			break
		}

		args, err := ec.field_Query_queryProjectColumn_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryProjectColumn(childComplexity, args["filter"].(*model.ProjectColumnFilter), args["order"].(*model.ProjectColumnOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryProjectDraft":
		if e.complexity.Query.QueryProjectDraft == nil {
			break
		}

		args, err := ec.field_Query_queryProjectDraft_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryProjectDraft(childComplexity, args["filter"].(*model.ProjectDraftFilter), args["order"].(*model.ProjectDraftOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryProjectField":
		if e.complexity.Query.QueryProjectField == nil {
			break
		}

		args, err := ec.field_Query_queryProjectField_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryProjectField(childComplexity, args["filter"].(*model.ProjectFieldFilter), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryProjectFieldValue":
		if e.complexity.Query.QueryProjectFieldValue == nil {
			break
		}

		args, err := ec.field_Query_queryProjectFieldValue_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryProjectFieldValue(childComplexity, args["filter"].(*model.ProjectFieldValueFilter), args["order"].(*model.ProjectFieldValueOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryReaction":
		if e.complexity.Query.QueryReaction == nil {
			break
		}

		args, err := ec.field_Query_queryReaction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryReaction(childComplexity, args["filter"].(*model.ReactionFilter), args["order"].(*model.ReactionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryRoleExt":
		if e.complexity.Query.QueryRoleExt == nil {
			break
		}

		args, err := ec.field_Query_queryRoleExt_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryRoleExt(childComplexity, args["filter"].(*model.RoleExtFilter), args["order"].(*model.RoleExtOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryTension":
		if e.complexity.Query.QueryTension == nil {
			break
		}

		args, err := ec.field_Query_queryTension_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryTension(childComplexity, args["filter"].(*model.TensionFilter), args["order"].(*model.TensionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryUser":
		if e.complexity.Query.QueryUser == nil {
			break
		}

		args, err := ec.field_Query_queryUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryUser(childComplexity, args["filter"].(*model.UserFilter), args["order"].(*model.UserOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryUserEvent":
		if e.complexity.Query.QueryUserEvent == nil {
			break
		}

		args, err := ec.field_Query_queryUserEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryUserEvent(childComplexity, args["filter"].(*model.UserEventFilter), args["order"].(*model.UserEventOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryUserRights":
		if e.complexity.Query.QueryUserRights == nil {
			break
		}

		args, err := ec.field_Query_queryUserRights_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryUserRights(childComplexity, args["filter"].(*model.UserRightsFilter), args["order"].(*model.UserRightsOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryVote":
		if e.complexity.Query.QueryVote == nil {
			break
		}

		args, err := ec.field_Query_queryVote_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryVote(childComplexity, args["filter"].(*model.VoteFilter), args["order"].(*model.VoteOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Reaction.comment":
		if e.complexity.Reaction.Comment == nil {
			break
		}

		args, err := ec.field_Reaction_comment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Reaction.Comment(childComplexity, args["filter"].(*model.CommentFilter)), true

	case "Reaction.id":
		if e.complexity.Reaction.ID == nil {
			break
		}

		return e.complexity.Reaction.ID(childComplexity), true

	case "Reaction.reactionid":
		if e.complexity.Reaction.Reactionid == nil {
			break
		}

		return e.complexity.Reaction.Reactionid(childComplexity), true

	case "Reaction.type_":
		if e.complexity.Reaction.Type == nil {
			break
		}

		return e.complexity.Reaction.Type(childComplexity), true

	case "Reaction.user":
		if e.complexity.Reaction.User == nil {
			break
		}

		args, err := ec.field_Reaction_user_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Reaction.User(childComplexity, args["filter"].(*model.UserFilter)), true

	case "ReactionAggregateResult.count":
		if e.complexity.ReactionAggregateResult.Count == nil {
			break
		}

		return e.complexity.ReactionAggregateResult.Count(childComplexity), true

	case "ReactionAggregateResult.reactionidMax":
		if e.complexity.ReactionAggregateResult.ReactionidMax == nil {
			break
		}

		return e.complexity.ReactionAggregateResult.ReactionidMax(childComplexity), true

	case "ReactionAggregateResult.reactionidMin":
		if e.complexity.ReactionAggregateResult.ReactionidMin == nil {
			break
		}

		return e.complexity.ReactionAggregateResult.ReactionidMin(childComplexity), true

	case "ReactionAggregateResult.type_Avg":
		if e.complexity.ReactionAggregateResult.TypeAvg == nil {
			break
		}

		return e.complexity.ReactionAggregateResult.TypeAvg(childComplexity), true

	case "ReactionAggregateResult.type_Max":
		if e.complexity.ReactionAggregateResult.TypeMax == nil {
			break
		}

		return e.complexity.ReactionAggregateResult.TypeMax(childComplexity), true

	case "ReactionAggregateResult.type_Min":
		if e.complexity.ReactionAggregateResult.TypeMin == nil {
			break
		}

		return e.complexity.ReactionAggregateResult.TypeMin(childComplexity), true

	case "ReactionAggregateResult.type_Sum":
		if e.complexity.ReactionAggregateResult.TypeSum == nil {
			break
		}

		return e.complexity.ReactionAggregateResult.TypeSum(childComplexity), true

	case "RoleExt.about":
		if e.complexity.RoleExt.About == nil {
			break
		}

		return e.complexity.RoleExt.About(childComplexity), true

	case "RoleExt.color":
		if e.complexity.RoleExt.Color == nil {
			break
		}

		return e.complexity.RoleExt.Color(childComplexity), true

	case "RoleExt.id":
		if e.complexity.RoleExt.ID == nil {
			break
		}

		return e.complexity.RoleExt.ID(childComplexity), true

	case "RoleExt.mandate":
		if e.complexity.RoleExt.Mandate == nil {
			break
		}

		args, err := ec.field_RoleExt_mandate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.RoleExt.Mandate(childComplexity, args["filter"].(*model.MandateFilter)), true

	case "RoleExt.name":
		if e.complexity.RoleExt.Name == nil {
			break
		}

		return e.complexity.RoleExt.Name(childComplexity), true

	case "RoleExt.nodes":
		if e.complexity.RoleExt.Nodes == nil {
			break
		}

		args, err := ec.field_RoleExt_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.RoleExt.Nodes(childComplexity, args["filter"].(*model.NodeFilter), args["order"].(*model.NodeOrder), args["first"].(*int), args["offset"].(*int)), true

	case "RoleExt.nodesAggregate":
		if e.complexity.RoleExt.NodesAggregate == nil {
			break
		}

		args, err := ec.field_RoleExt_nodesAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.RoleExt.NodesAggregate(childComplexity, args["filter"].(*model.NodeFilter)), true

	case "RoleExt.role_type":
		if e.complexity.RoleExt.RoleType == nil {
			break
		}

		return e.complexity.RoleExt.RoleType(childComplexity), true

	case "RoleExt.roles":
		if e.complexity.RoleExt.Roles == nil {
			break
		}

		args, err := ec.field_RoleExt_roles_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.RoleExt.Roles(childComplexity, args["filter"].(*model.NodeFilter), args["order"].(*model.NodeOrder), args["first"].(*int), args["offset"].(*int)), true

	case "RoleExt.rolesAggregate":
		if e.complexity.RoleExt.RolesAggregate == nil {
			break
		}

		args, err := ec.field_RoleExt_rolesAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.RoleExt.RolesAggregate(childComplexity, args["filter"].(*model.NodeFilter)), true

	case "RoleExt.rootnameid":
		if e.complexity.RoleExt.Rootnameid == nil {
			break
		}

		return e.complexity.RoleExt.Rootnameid(childComplexity), true

	case "RoleExtAggregateResult.aboutMax":
		if e.complexity.RoleExtAggregateResult.AboutMax == nil {
			break
		}

		return e.complexity.RoleExtAggregateResult.AboutMax(childComplexity), true

	case "RoleExtAggregateResult.aboutMin":
		if e.complexity.RoleExtAggregateResult.AboutMin == nil {
			break
		}

		return e.complexity.RoleExtAggregateResult.AboutMin(childComplexity), true

	case "RoleExtAggregateResult.colorMax":
		if e.complexity.RoleExtAggregateResult.ColorMax == nil {
			break
		}

		return e.complexity.RoleExtAggregateResult.ColorMax(childComplexity), true

	case "RoleExtAggregateResult.colorMin":
		if e.complexity.RoleExtAggregateResult.ColorMin == nil {
			break
		}

		return e.complexity.RoleExtAggregateResult.ColorMin(childComplexity), true

	case "RoleExtAggregateResult.count":
		if e.complexity.RoleExtAggregateResult.Count == nil {
			break
		}

		return e.complexity.RoleExtAggregateResult.Count(childComplexity), true

	case "RoleExtAggregateResult.nameMax":
		if e.complexity.RoleExtAggregateResult.NameMax == nil {
			break
		}

		return e.complexity.RoleExtAggregateResult.NameMax(childComplexity), true

	case "RoleExtAggregateResult.nameMin":
		if e.complexity.RoleExtAggregateResult.NameMin == nil {
			break
		}

		return e.complexity.RoleExtAggregateResult.NameMin(childComplexity), true

	case "RoleExtAggregateResult.rootnameidMax":
		if e.complexity.RoleExtAggregateResult.RootnameidMax == nil {
			break
		}

		return e.complexity.RoleExtAggregateResult.RootnameidMax(childComplexity), true

	case "RoleExtAggregateResult.rootnameidMin":
		if e.complexity.RoleExtAggregateResult.RootnameidMin == nil {
			break
		}

		return e.complexity.RoleExtAggregateResult.RootnameidMin(childComplexity), true

	case "Tension.action":
		if e.complexity.Tension.Action == nil {
			break
		}

		return e.complexity.Tension.Action(childComplexity), true

	case "Tension.assignees":
		if e.complexity.Tension.Assignees == nil {
			break
		}

		args, err := ec.field_Tension_assignees_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.Assignees(childComplexity, args["filter"].(*model.UserFilter), args["order"].(*model.UserOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Tension.assigneesAggregate":
		if e.complexity.Tension.AssigneesAggregate == nil {
			break
		}

		args, err := ec.field_Tension_assigneesAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.AssigneesAggregate(childComplexity, args["filter"].(*model.UserFilter)), true

	case "Tension.blobs":
		if e.complexity.Tension.Blobs == nil {
			break
		}

		args, err := ec.field_Tension_blobs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.Blobs(childComplexity, args["filter"].(*model.BlobFilter), args["order"].(*model.BlobOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Tension.blobsAggregate":
		if e.complexity.Tension.BlobsAggregate == nil {
			break
		}

		args, err := ec.field_Tension_blobsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.BlobsAggregate(childComplexity, args["filter"].(*model.BlobFilter)), true

	case "Tension.comments":
		if e.complexity.Tension.Comments == nil {
			break
		}

		args, err := ec.field_Tension_comments_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.Comments(childComplexity, args["filter"].(*model.CommentFilter), args["order"].(*model.CommentOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Tension.commentsAggregate":
		if e.complexity.Tension.CommentsAggregate == nil {
			break
		}

		args, err := ec.field_Tension_commentsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.CommentsAggregate(childComplexity, args["filter"].(*model.CommentFilter)), true

	case "Tension.contracts":
		if e.complexity.Tension.Contracts == nil {
			break
		}

		args, err := ec.field_Tension_contracts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.Contracts(childComplexity, args["filter"].(*model.ContractFilter), args["order"].(*model.ContractOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Tension.contractsAggregate":
		if e.complexity.Tension.ContractsAggregate == nil {
			break
		}

		args, err := ec.field_Tension_contractsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.ContractsAggregate(childComplexity, args["filter"].(*model.ContractFilter)), true

	case "Tension.createdAt":
		if e.complexity.Tension.CreatedAt == nil {
			break
		}

		return e.complexity.Tension.CreatedAt(childComplexity), true

	case "Tension.createdBy":
		if e.complexity.Tension.CreatedBy == nil {
			break
		}

		args, err := ec.field_Tension_createdBy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.CreatedBy(childComplexity, args["filter"].(*model.UserFilter)), true

	case "Tension.emitter":
		if e.complexity.Tension.Emitter == nil {
			break
		}

		args, err := ec.field_Tension_emitter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.Emitter(childComplexity, args["filter"].(*model.NodeFilter)), true

	case "Tension.emitterid":
		if e.complexity.Tension.Emitterid == nil {
			break
		}

		return e.complexity.Tension.Emitterid(childComplexity), true

	case "Tension.history":
		if e.complexity.Tension.History == nil {
			break
		}

		args, err := ec.field_Tension_history_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.History(childComplexity, args["filter"].(*model.EventFilter), args["order"].(*model.EventOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Tension.historyAggregate":
		if e.complexity.Tension.HistoryAggregate == nil {
			break
		}

		args, err := ec.field_Tension_historyAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.HistoryAggregate(childComplexity, args["filter"].(*model.EventFilter)), true

	case "Tension.id":
		if e.complexity.Tension.ID == nil {
			break
		}

		return e.complexity.Tension.ID(childComplexity), true

	case "Tension.labels":
		if e.complexity.Tension.Labels == nil {
			break
		}

		args, err := ec.field_Tension_labels_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.Labels(childComplexity, args["filter"].(*model.LabelFilter), args["order"].(*model.LabelOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Tension.labelsAggregate":
		if e.complexity.Tension.LabelsAggregate == nil {
			break
		}

		args, err := ec.field_Tension_labelsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.LabelsAggregate(childComplexity, args["filter"].(*model.LabelFilter)), true

	case "Tension.mentions":
		if e.complexity.Tension.Mentions == nil {
			break
		}

		args, err := ec.field_Tension_mentions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.Mentions(childComplexity, args["filter"].(*model.EventFilter), args["order"].(*model.EventOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Tension.mentionsAggregate":
		if e.complexity.Tension.MentionsAggregate == nil {
			break
		}

		args, err := ec.field_Tension_mentionsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.MentionsAggregate(childComplexity, args["filter"].(*model.EventFilter)), true

	case "Tension.message":
		if e.complexity.Tension.Message == nil {
			break
		}

		return e.complexity.Tension.Message(childComplexity), true

	case "Tension.n_comments":
		if e.complexity.Tension.NComments == nil {
			break
		}

		return e.complexity.Tension.NComments(childComplexity), true

	case "Tension.project_statuses":
		if e.complexity.Tension.ProjectStatuses == nil {
			break
		}

		args, err := ec.field_Tension_project_statuses_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.ProjectStatuses(childComplexity, args["filter"].(*model.ProjectColumnFilter), args["order"].(*model.ProjectColumnOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Tension.project_statusesAggregate":
		if e.complexity.Tension.ProjectStatusesAggregate == nil {
			break
		}

		args, err := ec.field_Tension_project_statusesAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.ProjectStatusesAggregate(childComplexity, args["filter"].(*model.ProjectColumnFilter)), true

	case "Tension.receiver":
		if e.complexity.Tension.Receiver == nil {
			break
		}

		args, err := ec.field_Tension_receiver_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.Receiver(childComplexity, args["filter"].(*model.NodeFilter)), true

	case "Tension.receiverid":
		if e.complexity.Tension.Receiverid == nil {
			break
		}

		return e.complexity.Tension.Receiverid(childComplexity), true

	case "Tension.status":
		if e.complexity.Tension.Status == nil {
			break
		}

		return e.complexity.Tension.Status(childComplexity), true

	case "Tension.subscribers":
		if e.complexity.Tension.Subscribers == nil {
			break
		}

		args, err := ec.field_Tension_subscribers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.Subscribers(childComplexity, args["filter"].(*model.UserFilter), args["order"].(*model.UserOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Tension.subscribersAggregate":
		if e.complexity.Tension.SubscribersAggregate == nil {
			break
		}

		args, err := ec.field_Tension_subscribersAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.SubscribersAggregate(childComplexity, args["filter"].(*model.UserFilter)), true

	case "Tension.title":
		if e.complexity.Tension.Title == nil {
			break
		}

		return e.complexity.Tension.Title(childComplexity), true

	case "Tension.type_":
		if e.complexity.Tension.Type == nil {
			break
		}

		return e.complexity.Tension.Type(childComplexity), true

	case "Tension.updatedAt":
		if e.complexity.Tension.UpdatedAt == nil {
			break
		}

		return e.complexity.Tension.UpdatedAt(childComplexity), true

	case "TensionAggregateResult.count":
		if e.complexity.TensionAggregateResult.Count == nil {
			break
		}

		return e.complexity.TensionAggregateResult.Count(childComplexity), true

	case "TensionAggregateResult.createdAtMax":
		if e.complexity.TensionAggregateResult.CreatedAtMax == nil {
			break
		}

		return e.complexity.TensionAggregateResult.CreatedAtMax(childComplexity), true

	case "TensionAggregateResult.createdAtMin":
		if e.complexity.TensionAggregateResult.CreatedAtMin == nil {
			break
		}

		return e.complexity.TensionAggregateResult.CreatedAtMin(childComplexity), true

	case "TensionAggregateResult.emitteridMax":
		if e.complexity.TensionAggregateResult.EmitteridMax == nil {
			break
		}

		return e.complexity.TensionAggregateResult.EmitteridMax(childComplexity), true

	case "TensionAggregateResult.emitteridMin":
		if e.complexity.TensionAggregateResult.EmitteridMin == nil {
			break
		}

		return e.complexity.TensionAggregateResult.EmitteridMin(childComplexity), true

	case "TensionAggregateResult.messageMax":
		if e.complexity.TensionAggregateResult.MessageMax == nil {
			break
		}

		return e.complexity.TensionAggregateResult.MessageMax(childComplexity), true

	case "TensionAggregateResult.messageMin":
		if e.complexity.TensionAggregateResult.MessageMin == nil {
			break
		}

		return e.complexity.TensionAggregateResult.MessageMin(childComplexity), true

	case "TensionAggregateResult.n_commentsAvg":
		if e.complexity.TensionAggregateResult.NCommentsAvg == nil {
			break
		}

		return e.complexity.TensionAggregateResult.NCommentsAvg(childComplexity), true

	case "TensionAggregateResult.n_commentsMax":
		if e.complexity.TensionAggregateResult.NCommentsMax == nil {
			break
		}

		return e.complexity.TensionAggregateResult.NCommentsMax(childComplexity), true

	case "TensionAggregateResult.n_commentsMin":
		if e.complexity.TensionAggregateResult.NCommentsMin == nil {
			break
		}

		return e.complexity.TensionAggregateResult.NCommentsMin(childComplexity), true

	case "TensionAggregateResult.n_commentsSum":
		if e.complexity.TensionAggregateResult.NCommentsSum == nil {
			break
		}

		return e.complexity.TensionAggregateResult.NCommentsSum(childComplexity), true

	case "TensionAggregateResult.receiveridMax":
		if e.complexity.TensionAggregateResult.ReceiveridMax == nil {
			break
		}

		return e.complexity.TensionAggregateResult.ReceiveridMax(childComplexity), true

	case "TensionAggregateResult.receiveridMin":
		if e.complexity.TensionAggregateResult.ReceiveridMin == nil {
			break
		}

		return e.complexity.TensionAggregateResult.ReceiveridMin(childComplexity), true

	case "TensionAggregateResult.titleMax":
		if e.complexity.TensionAggregateResult.TitleMax == nil {
			break
		}

		return e.complexity.TensionAggregateResult.TitleMax(childComplexity), true

	case "TensionAggregateResult.titleMin":
		if e.complexity.TensionAggregateResult.TitleMin == nil {
			break
		}

		return e.complexity.TensionAggregateResult.TitleMin(childComplexity), true

	case "TensionAggregateResult.updatedAtMax":
		if e.complexity.TensionAggregateResult.UpdatedAtMax == nil {
			break
		}

		return e.complexity.TensionAggregateResult.UpdatedAtMax(childComplexity), true

	case "TensionAggregateResult.updatedAtMin":
		if e.complexity.TensionAggregateResult.UpdatedAtMin == nil {
			break
		}

		return e.complexity.TensionAggregateResult.UpdatedAtMin(childComplexity), true

	case "UpdateBlobPayload.blob":
		if e.complexity.UpdateBlobPayload.Blob == nil {
			break
		}

		args, err := ec.field_UpdateBlobPayload_blob_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateBlobPayload.Blob(childComplexity, args["filter"].(*model.BlobFilter), args["order"].(*model.BlobOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateBlobPayload.numUids":
		if e.complexity.UpdateBlobPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateBlobPayload.NumUids(childComplexity), true

	case "UpdateCommentPayload.comment":
		if e.complexity.UpdateCommentPayload.Comment == nil {
			break
		}

		args, err := ec.field_UpdateCommentPayload_comment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateCommentPayload.Comment(childComplexity, args["filter"].(*model.CommentFilter), args["order"].(*model.CommentOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateCommentPayload.numUids":
		if e.complexity.UpdateCommentPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateCommentPayload.NumUids(childComplexity), true

	case "UpdateContractPayload.contract":
		if e.complexity.UpdateContractPayload.Contract == nil {
			break
		}

		args, err := ec.field_UpdateContractPayload_contract_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateContractPayload.Contract(childComplexity, args["filter"].(*model.ContractFilter), args["order"].(*model.ContractOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateContractPayload.numUids":
		if e.complexity.UpdateContractPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateContractPayload.NumUids(childComplexity), true

	case "UpdateEventCountPayload.eventCount":
		if e.complexity.UpdateEventCountPayload.EventCount == nil {
			break
		}

		args, err := ec.field_UpdateEventCountPayload_eventCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateEventCountPayload.EventCount(childComplexity, args["filter"].(*model.EventCountFilter), args["order"].(*model.EventCountOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateEventCountPayload.numUids":
		if e.complexity.UpdateEventCountPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateEventCountPayload.NumUids(childComplexity), true

	case "UpdateEventFragmentPayload.eventFragment":
		if e.complexity.UpdateEventFragmentPayload.EventFragment == nil {
			break
		}

		args, err := ec.field_UpdateEventFragmentPayload_eventFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateEventFragmentPayload.EventFragment(childComplexity, args["filter"].(*model.EventFragmentFilter), args["order"].(*model.EventFragmentOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateEventFragmentPayload.numUids":
		if e.complexity.UpdateEventFragmentPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateEventFragmentPayload.NumUids(childComplexity), true

	case "UpdateEventPayload.event":
		if e.complexity.UpdateEventPayload.Event == nil {
			break
		}

		args, err := ec.field_UpdateEventPayload_event_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateEventPayload.Event(childComplexity, args["filter"].(*model.EventFilter), args["order"].(*model.EventOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateEventPayload.numUids":
		if e.complexity.UpdateEventPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateEventPayload.NumUids(childComplexity), true

	case "UpdateLabelPayload.label":
		if e.complexity.UpdateLabelPayload.Label == nil {
			break
		}

		args, err := ec.field_UpdateLabelPayload_label_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateLabelPayload.Label(childComplexity, args["filter"].(*model.LabelFilter), args["order"].(*model.LabelOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateLabelPayload.numUids":
		if e.complexity.UpdateLabelPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateLabelPayload.NumUids(childComplexity), true

	case "UpdateMandatePayload.mandate":
		if e.complexity.UpdateMandatePayload.Mandate == nil {
			break
		}

		args, err := ec.field_UpdateMandatePayload_mandate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateMandatePayload.Mandate(childComplexity, args["filter"].(*model.MandateFilter), args["order"].(*model.MandateOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateMandatePayload.numUids":
		if e.complexity.UpdateMandatePayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateMandatePayload.NumUids(childComplexity), true

	case "UpdateNodeFragmentPayload.nodeFragment":
		if e.complexity.UpdateNodeFragmentPayload.NodeFragment == nil {
			break
		}

		args, err := ec.field_UpdateNodeFragmentPayload_nodeFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateNodeFragmentPayload.NodeFragment(childComplexity, args["filter"].(*model.NodeFragmentFilter), args["order"].(*model.NodeFragmentOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateNodeFragmentPayload.numUids":
		if e.complexity.UpdateNodeFragmentPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateNodeFragmentPayload.NumUids(childComplexity), true

	case "UpdateNodePayload.node":
		if e.complexity.UpdateNodePayload.Node == nil {
			break
		}

		args, err := ec.field_UpdateNodePayload_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateNodePayload.Node(childComplexity, args["filter"].(*model.NodeFilter), args["order"].(*model.NodeOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateNodePayload.numUids":
		if e.complexity.UpdateNodePayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateNodePayload.NumUids(childComplexity), true

	case "UpdateNotifPayload.notif":
		if e.complexity.UpdateNotifPayload.Notif == nil {
			break
		}

		args, err := ec.field_UpdateNotifPayload_notif_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateNotifPayload.Notif(childComplexity, args["filter"].(*model.NotifFilter), args["order"].(*model.NotifOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateNotifPayload.numUids":
		if e.complexity.UpdateNotifPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateNotifPayload.NumUids(childComplexity), true

	case "UpdatePendingUserPayload.numUids":
		if e.complexity.UpdatePendingUserPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdatePendingUserPayload.NumUids(childComplexity), true

	case "UpdatePendingUserPayload.pendingUser":
		if e.complexity.UpdatePendingUserPayload.PendingUser == nil {
			break
		}

		args, err := ec.field_UpdatePendingUserPayload_pendingUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdatePendingUserPayload.PendingUser(childComplexity, args["filter"].(*model.PendingUserFilter), args["order"].(*model.PendingUserOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdatePostPayload.numUids":
		if e.complexity.UpdatePostPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdatePostPayload.NumUids(childComplexity), true

	case "UpdatePostPayload.post":
		if e.complexity.UpdatePostPayload.Post == nil {
			break
		}

		args, err := ec.field_UpdatePostPayload_post_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdatePostPayload.Post(childComplexity, args["filter"].(*model.PostFilter), args["order"].(*model.PostOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateProjectCardPayload.numUids":
		if e.complexity.UpdateProjectCardPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateProjectCardPayload.NumUids(childComplexity), true

	case "UpdateProjectCardPayload.projectCard":
		if e.complexity.UpdateProjectCardPayload.ProjectCard == nil {
			break
		}

		args, err := ec.field_UpdateProjectCardPayload_projectCard_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateProjectCardPayload.ProjectCard(childComplexity, args["filter"].(*model.ProjectCardFilter), args["order"].(*model.ProjectCardOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateProjectColumnPayload.numUids":
		if e.complexity.UpdateProjectColumnPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateProjectColumnPayload.NumUids(childComplexity), true

	case "UpdateProjectColumnPayload.projectColumn":
		if e.complexity.UpdateProjectColumnPayload.ProjectColumn == nil {
			break
		}

		args, err := ec.field_UpdateProjectColumnPayload_projectColumn_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateProjectColumnPayload.ProjectColumn(childComplexity, args["filter"].(*model.ProjectColumnFilter), args["order"].(*model.ProjectColumnOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateProjectDraftPayload.numUids":
		if e.complexity.UpdateProjectDraftPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateProjectDraftPayload.NumUids(childComplexity), true

	case "UpdateProjectDraftPayload.projectDraft":
		if e.complexity.UpdateProjectDraftPayload.ProjectDraft == nil {
			break
		}

		args, err := ec.field_UpdateProjectDraftPayload_projectDraft_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateProjectDraftPayload.ProjectDraft(childComplexity, args["filter"].(*model.ProjectDraftFilter), args["order"].(*model.ProjectDraftOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateProjectFieldPayload.numUids":
		if e.complexity.UpdateProjectFieldPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateProjectFieldPayload.NumUids(childComplexity), true

	case "UpdateProjectFieldPayload.projectField":
		if e.complexity.UpdateProjectFieldPayload.ProjectField == nil {
			break
		}

		args, err := ec.field_UpdateProjectFieldPayload_projectField_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateProjectFieldPayload.ProjectField(childComplexity, args["filter"].(*model.ProjectFieldFilter), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateProjectFieldValuePayload.numUids":
		if e.complexity.UpdateProjectFieldValuePayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateProjectFieldValuePayload.NumUids(childComplexity), true

	case "UpdateProjectFieldValuePayload.projectFieldValue":
		if e.complexity.UpdateProjectFieldValuePayload.ProjectFieldValue == nil {
			break
		}

		args, err := ec.field_UpdateProjectFieldValuePayload_projectFieldValue_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateProjectFieldValuePayload.ProjectFieldValue(childComplexity, args["filter"].(*model.ProjectFieldValueFilter), args["order"].(*model.ProjectFieldValueOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateProjectPayload.numUids":
		if e.complexity.UpdateProjectPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateProjectPayload.NumUids(childComplexity), true

	case "UpdateProjectPayload.project":
		if e.complexity.UpdateProjectPayload.Project == nil {
			break
		}

		args, err := ec.field_UpdateProjectPayload_project_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateProjectPayload.Project(childComplexity, args["filter"].(*model.ProjectFilter), args["order"].(*model.ProjectOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateReactionPayload.numUids":
		if e.complexity.UpdateReactionPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateReactionPayload.NumUids(childComplexity), true

	case "UpdateReactionPayload.reaction":
		if e.complexity.UpdateReactionPayload.Reaction == nil {
			break
		}

		args, err := ec.field_UpdateReactionPayload_reaction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateReactionPayload.Reaction(childComplexity, args["filter"].(*model.ReactionFilter), args["order"].(*model.ReactionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateRoleExtPayload.numUids":
		if e.complexity.UpdateRoleExtPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateRoleExtPayload.NumUids(childComplexity), true

	case "UpdateRoleExtPayload.roleExt":
		if e.complexity.UpdateRoleExtPayload.RoleExt == nil {
			break
		}

		args, err := ec.field_UpdateRoleExtPayload_roleExt_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateRoleExtPayload.RoleExt(childComplexity, args["filter"].(*model.RoleExtFilter), args["order"].(*model.RoleExtOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateTensionPayload.numUids":
		if e.complexity.UpdateTensionPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateTensionPayload.NumUids(childComplexity), true

	case "UpdateTensionPayload.tension":
		if e.complexity.UpdateTensionPayload.Tension == nil {
			break
		}

		args, err := ec.field_UpdateTensionPayload_tension_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateTensionPayload.Tension(childComplexity, args["filter"].(*model.TensionFilter), args["order"].(*model.TensionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateUserEventPayload.numUids":
		if e.complexity.UpdateUserEventPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateUserEventPayload.NumUids(childComplexity), true

	case "UpdateUserEventPayload.userEvent":
		if e.complexity.UpdateUserEventPayload.UserEvent == nil {
			break
		}

		args, err := ec.field_UpdateUserEventPayload_userEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateUserEventPayload.UserEvent(childComplexity, args["filter"].(*model.UserEventFilter), args["order"].(*model.UserEventOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateUserPayload.numUids":
		if e.complexity.UpdateUserPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateUserPayload.NumUids(childComplexity), true

	case "UpdateUserPayload.user":
		if e.complexity.UpdateUserPayload.User == nil {
			break
		}

		args, err := ec.field_UpdateUserPayload_user_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateUserPayload.User(childComplexity, args["filter"].(*model.UserFilter), args["order"].(*model.UserOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateUserRightsPayload.numUids":
		if e.complexity.UpdateUserRightsPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateUserRightsPayload.NumUids(childComplexity), true

	case "UpdateUserRightsPayload.userRights":
		if e.complexity.UpdateUserRightsPayload.UserRights == nil {
			break
		}

		args, err := ec.field_UpdateUserRightsPayload_userRights_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateUserRightsPayload.UserRights(childComplexity, args["filter"].(*model.UserRightsFilter), args["order"].(*model.UserRightsOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateVotePayload.numUids":
		if e.complexity.UpdateVotePayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateVotePayload.NumUids(childComplexity), true

	case "UpdateVotePayload.vote":
		if e.complexity.UpdateVotePayload.Vote == nil {
			break
		}

		args, err := ec.field_UpdateVotePayload_vote_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateVotePayload.Vote(childComplexity, args["filter"].(*model.VoteFilter), args["order"].(*model.VoteOrder), args["first"].(*int), args["offset"].(*int)), true

	case "User.bio":
		if e.complexity.User.Bio == nil {
			break
		}

		return e.complexity.User.Bio(childComplexity), true

	case "User.contracts":
		if e.complexity.User.Contracts == nil {
			break
		}

		args, err := ec.field_User_contracts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Contracts(childComplexity, args["filter"].(*model.ContractFilter), args["order"].(*model.ContractOrder), args["first"].(*int), args["offset"].(*int)), true

	case "User.contractsAggregate":
		if e.complexity.User.ContractsAggregate == nil {
			break
		}

		args, err := ec.field_User_contractsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.ContractsAggregate(childComplexity, args["filter"].(*model.ContractFilter)), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.event_count":
		if e.complexity.User.EventCount == nil {
			break
		}

		args, err := ec.field_User_event_count_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.EventCount(childComplexity, args["filter"].(*model.EventCountFilter)), true

	case "User.events":
		if e.complexity.User.Events == nil {
			break
		}

		args, err := ec.field_User_events_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Events(childComplexity, args["filter"].(*model.UserEventFilter), args["order"].(*model.UserEventOrder), args["first"].(*int), args["offset"].(*int)), true

	case "User.eventsAggregate":
		if e.complexity.User.EventsAggregate == nil {
			break
		}

		args, err := ec.field_User_eventsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.EventsAggregate(childComplexity, args["filter"].(*model.UserEventFilter)), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.lang":
		if e.complexity.User.Lang == nil {
			break
		}

		return e.complexity.User.Lang(childComplexity), true

	case "User.lastAck":
		if e.complexity.User.LastAck == nil {
			break
		}

		return e.complexity.User.LastAck(childComplexity), true

	case "User.links":
		if e.complexity.User.Links == nil {
			break
		}

		return e.complexity.User.Links(childComplexity), true

	case "User.location":
		if e.complexity.User.Location == nil {
			break
		}

		return e.complexity.User.Location(childComplexity), true

	case "User.markAllAsRead":
		if e.complexity.User.MarkAllAsRead == nil {
			break
		}

		return e.complexity.User.MarkAllAsRead(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.notifyByEmail":
		if e.complexity.User.NotifyByEmail == nil {
			break
		}

		return e.complexity.User.NotifyByEmail(childComplexity), true

	case "User.password":
		if e.complexity.User.Password == nil {
			break
		}

		return e.complexity.User.Password(childComplexity), true

	case "User.reactions":
		if e.complexity.User.Reactions == nil {
			break
		}

		args, err := ec.field_User_reactions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Reactions(childComplexity, args["filter"].(*model.ReactionFilter), args["order"].(*model.ReactionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "User.reactionsAggregate":
		if e.complexity.User.ReactionsAggregate == nil {
			break
		}

		args, err := ec.field_User_reactionsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.ReactionsAggregate(childComplexity, args["filter"].(*model.ReactionFilter)), true

	case "User.rights":
		if e.complexity.User.Rights == nil {
			break
		}

		args, err := ec.field_User_rights_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Rights(childComplexity, args["filter"].(*model.UserRightsFilter)), true

	case "User.roles":
		if e.complexity.User.Roles == nil {
			break
		}

		args, err := ec.field_User_roles_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Roles(childComplexity, args["filter"].(*model.NodeFilter), args["order"].(*model.NodeOrder), args["first"].(*int), args["offset"].(*int)), true

	case "User.rolesAggregate":
		if e.complexity.User.RolesAggregate == nil {
			break
		}

		args, err := ec.field_User_rolesAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.RolesAggregate(childComplexity, args["filter"].(*model.NodeFilter)), true

	case "User.skills":
		if e.complexity.User.Skills == nil {
			break
		}

		return e.complexity.User.Skills(childComplexity), true

	case "User.subscriptions":
		if e.complexity.User.Subscriptions == nil {
			break
		}

		args, err := ec.field_User_subscriptions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Subscriptions(childComplexity, args["filter"].(*model.TensionFilter), args["order"].(*model.TensionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "User.subscriptionsAggregate":
		if e.complexity.User.SubscriptionsAggregate == nil {
			break
		}

		args, err := ec.field_User_subscriptionsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.SubscriptionsAggregate(childComplexity, args["filter"].(*model.TensionFilter)), true

	case "User.tensions_assigned":
		if e.complexity.User.TensionsAssigned == nil {
			break
		}

		args, err := ec.field_User_tensions_assigned_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.TensionsAssigned(childComplexity, args["filter"].(*model.TensionFilter), args["order"].(*model.TensionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "User.tensions_assignedAggregate":
		if e.complexity.User.TensionsAssignedAggregate == nil {
			break
		}

		args, err := ec.field_User_tensions_assignedAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.TensionsAssignedAggregate(childComplexity, args["filter"].(*model.TensionFilter)), true

	case "User.tensions_created":
		if e.complexity.User.TensionsCreated == nil {
			break
		}

		args, err := ec.field_User_tensions_created_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.TensionsCreated(childComplexity, args["filter"].(*model.TensionFilter), args["order"].(*model.TensionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "User.tensions_createdAggregate":
		if e.complexity.User.TensionsCreatedAggregate == nil {
			break
		}

		args, err := ec.field_User_tensions_createdAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.TensionsCreatedAggregate(childComplexity, args["filter"].(*model.TensionFilter)), true

	case "User.username":
		if e.complexity.User.Username == nil {
			break
		}

		return e.complexity.User.Username(childComplexity), true

	case "User.utc":
		if e.complexity.User.Utc == nil {
			break
		}

		return e.complexity.User.Utc(childComplexity), true

	case "User.watching":
		if e.complexity.User.Watching == nil {
			break
		}

		args, err := ec.field_User_watching_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Watching(childComplexity, args["filter"].(*model.NodeFilter), args["order"].(*model.NodeOrder), args["first"].(*int), args["offset"].(*int)), true

	case "User.watchingAggregate":
		if e.complexity.User.WatchingAggregate == nil {
			break
		}

		args, err := ec.field_User_watchingAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.WatchingAggregate(childComplexity, args["filter"].(*model.NodeFilter)), true

	case "UserAggregateResult.bioMax":
		if e.complexity.UserAggregateResult.BioMax == nil {
			break
		}

		return e.complexity.UserAggregateResult.BioMax(childComplexity), true

	case "UserAggregateResult.bioMin":
		if e.complexity.UserAggregateResult.BioMin == nil {
			break
		}

		return e.complexity.UserAggregateResult.BioMin(childComplexity), true

	case "UserAggregateResult.count":
		if e.complexity.UserAggregateResult.Count == nil {
			break
		}

		return e.complexity.UserAggregateResult.Count(childComplexity), true

	case "UserAggregateResult.createdAtMax":
		if e.complexity.UserAggregateResult.CreatedAtMax == nil {
			break
		}

		return e.complexity.UserAggregateResult.CreatedAtMax(childComplexity), true

	case "UserAggregateResult.createdAtMin":
		if e.complexity.UserAggregateResult.CreatedAtMin == nil {
			break
		}

		return e.complexity.UserAggregateResult.CreatedAtMin(childComplexity), true

	case "UserAggregateResult.emailMax":
		if e.complexity.UserAggregateResult.EmailMax == nil {
			break
		}

		return e.complexity.UserAggregateResult.EmailMax(childComplexity), true

	case "UserAggregateResult.emailMin":
		if e.complexity.UserAggregateResult.EmailMin == nil {
			break
		}

		return e.complexity.UserAggregateResult.EmailMin(childComplexity), true

	case "UserAggregateResult.lastAckMax":
		if e.complexity.UserAggregateResult.LastAckMax == nil {
			break
		}

		return e.complexity.UserAggregateResult.LastAckMax(childComplexity), true

	case "UserAggregateResult.lastAckMin":
		if e.complexity.UserAggregateResult.LastAckMin == nil {
			break
		}

		return e.complexity.UserAggregateResult.LastAckMin(childComplexity), true

	case "UserAggregateResult.locationMax":
		if e.complexity.UserAggregateResult.LocationMax == nil {
			break
		}

		return e.complexity.UserAggregateResult.LocationMax(childComplexity), true

	case "UserAggregateResult.locationMin":
		if e.complexity.UserAggregateResult.LocationMin == nil {
			break
		}

		return e.complexity.UserAggregateResult.LocationMin(childComplexity), true

	case "UserAggregateResult.markAllAsReadMax":
		if e.complexity.UserAggregateResult.MarkAllAsReadMax == nil {
			break
		}

		return e.complexity.UserAggregateResult.MarkAllAsReadMax(childComplexity), true

	case "UserAggregateResult.markAllAsReadMin":
		if e.complexity.UserAggregateResult.MarkAllAsReadMin == nil {
			break
		}

		return e.complexity.UserAggregateResult.MarkAllAsReadMin(childComplexity), true

	case "UserAggregateResult.nameMax":
		if e.complexity.UserAggregateResult.NameMax == nil {
			break
		}

		return e.complexity.UserAggregateResult.NameMax(childComplexity), true

	case "UserAggregateResult.nameMin":
		if e.complexity.UserAggregateResult.NameMin == nil {
			break
		}

		return e.complexity.UserAggregateResult.NameMin(childComplexity), true

	case "UserAggregateResult.passwordMax":
		if e.complexity.UserAggregateResult.PasswordMax == nil {
			break
		}

		return e.complexity.UserAggregateResult.PasswordMax(childComplexity), true

	case "UserAggregateResult.passwordMin":
		if e.complexity.UserAggregateResult.PasswordMin == nil {
			break
		}

		return e.complexity.UserAggregateResult.PasswordMin(childComplexity), true

	case "UserAggregateResult.usernameMax":
		if e.complexity.UserAggregateResult.UsernameMax == nil {
			break
		}

		return e.complexity.UserAggregateResult.UsernameMax(childComplexity), true

	case "UserAggregateResult.usernameMin":
		if e.complexity.UserAggregateResult.UsernameMin == nil {
			break
		}

		return e.complexity.UserAggregateResult.UsernameMin(childComplexity), true

	case "UserAggregateResult.utcMax":
		if e.complexity.UserAggregateResult.UtcMax == nil {
			break
		}

		return e.complexity.UserAggregateResult.UtcMax(childComplexity), true

	case "UserAggregateResult.utcMin":
		if e.complexity.UserAggregateResult.UtcMin == nil {
			break
		}

		return e.complexity.UserAggregateResult.UtcMin(childComplexity), true

	case "UserEvent.createdAt":
		if e.complexity.UserEvent.CreatedAt == nil {
			break
		}

		return e.complexity.UserEvent.CreatedAt(childComplexity), true

	case "UserEvent.event":
		if e.complexity.UserEvent.Event == nil {
			break
		}

		args, err := ec.field_UserEvent_event_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UserEvent.Event(childComplexity, args["filter"].(*model.EventKindFilter), args["first"].(*int), args["offset"].(*int)), true

	case "UserEvent.id":
		if e.complexity.UserEvent.ID == nil {
			break
		}

		return e.complexity.UserEvent.ID(childComplexity), true

	case "UserEvent.isRead":
		if e.complexity.UserEvent.IsRead == nil {
			break
		}

		return e.complexity.UserEvent.IsRead(childComplexity), true

	case "UserEvent.user":
		if e.complexity.UserEvent.User == nil {
			break
		}

		args, err := ec.field_UserEvent_user_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UserEvent.User(childComplexity, args["filter"].(*model.UserFilter)), true

	case "UserEventAggregateResult.count":
		if e.complexity.UserEventAggregateResult.Count == nil {
			break
		}

		return e.complexity.UserEventAggregateResult.Count(childComplexity), true

	case "UserEventAggregateResult.createdAtMax":
		if e.complexity.UserEventAggregateResult.CreatedAtMax == nil {
			break
		}

		return e.complexity.UserEventAggregateResult.CreatedAtMax(childComplexity), true

	case "UserEventAggregateResult.createdAtMin":
		if e.complexity.UserEventAggregateResult.CreatedAtMin == nil {
			break
		}

		return e.complexity.UserEventAggregateResult.CreatedAtMin(childComplexity), true

	case "UserRights.canCreateRoot":
		if e.complexity.UserRights.CanCreateRoot == nil {
			break
		}

		return e.complexity.UserRights.CanCreateRoot(childComplexity), true

	case "UserRights.canLogin":
		if e.complexity.UserRights.CanLogin == nil {
			break
		}

		return e.complexity.UserRights.CanLogin(childComplexity), true

	case "UserRights.hasEmailNotifications":
		if e.complexity.UserRights.HasEmailNotifications == nil {
			break
		}

		return e.complexity.UserRights.HasEmailNotifications(childComplexity), true

	case "UserRights.maxPrivateOrga":
		if e.complexity.UserRights.MaxPrivateOrga == nil {
			break
		}

		return e.complexity.UserRights.MaxPrivateOrga(childComplexity), true

	case "UserRights.maxPublicOrga":
		if e.complexity.UserRights.MaxPublicOrga == nil {
			break
		}

		return e.complexity.UserRights.MaxPublicOrga(childComplexity), true

	case "UserRights.type_":
		if e.complexity.UserRights.Type == nil {
			break
		}

		return e.complexity.UserRights.Type(childComplexity), true

	case "UserRightsAggregateResult.count":
		if e.complexity.UserRightsAggregateResult.Count == nil {
			break
		}

		return e.complexity.UserRightsAggregateResult.Count(childComplexity), true

	case "UserRightsAggregateResult.maxPrivateOrgaAvg":
		if e.complexity.UserRightsAggregateResult.MaxPrivateOrgaAvg == nil {
			break
		}

		return e.complexity.UserRightsAggregateResult.MaxPrivateOrgaAvg(childComplexity), true

	case "UserRightsAggregateResult.maxPrivateOrgaMax":
		if e.complexity.UserRightsAggregateResult.MaxPrivateOrgaMax == nil {
			break
		}

		return e.complexity.UserRightsAggregateResult.MaxPrivateOrgaMax(childComplexity), true

	case "UserRightsAggregateResult.maxPrivateOrgaMin":
		if e.complexity.UserRightsAggregateResult.MaxPrivateOrgaMin == nil {
			break
		}

		return e.complexity.UserRightsAggregateResult.MaxPrivateOrgaMin(childComplexity), true

	case "UserRightsAggregateResult.maxPrivateOrgaSum":
		if e.complexity.UserRightsAggregateResult.MaxPrivateOrgaSum == nil {
			break
		}

		return e.complexity.UserRightsAggregateResult.MaxPrivateOrgaSum(childComplexity), true

	case "UserRightsAggregateResult.maxPublicOrgaAvg":
		if e.complexity.UserRightsAggregateResult.MaxPublicOrgaAvg == nil {
			break
		}

		return e.complexity.UserRightsAggregateResult.MaxPublicOrgaAvg(childComplexity), true

	case "UserRightsAggregateResult.maxPublicOrgaMax":
		if e.complexity.UserRightsAggregateResult.MaxPublicOrgaMax == nil {
			break
		}

		return e.complexity.UserRightsAggregateResult.MaxPublicOrgaMax(childComplexity), true

	case "UserRightsAggregateResult.maxPublicOrgaMin":
		if e.complexity.UserRightsAggregateResult.MaxPublicOrgaMin == nil {
			break
		}

		return e.complexity.UserRightsAggregateResult.MaxPublicOrgaMin(childComplexity), true

	case "UserRightsAggregateResult.maxPublicOrgaSum":
		if e.complexity.UserRightsAggregateResult.MaxPublicOrgaSum == nil {
			break
		}

		return e.complexity.UserRightsAggregateResult.MaxPublicOrgaSum(childComplexity), true

	case "Vote.contract":
		if e.complexity.Vote.Contract == nil {
			break
		}

		args, err := ec.field_Vote_contract_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Vote.Contract(childComplexity, args["filter"].(*model.ContractFilter)), true

	case "Vote.createdAt":
		if e.complexity.Vote.CreatedAt == nil {
			break
		}

		return e.complexity.Vote.CreatedAt(childComplexity), true

	case "Vote.createdBy":
		if e.complexity.Vote.CreatedBy == nil {
			break
		}

		args, err := ec.field_Vote_createdBy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Vote.CreatedBy(childComplexity, args["filter"].(*model.UserFilter)), true

	case "Vote.data":
		if e.complexity.Vote.Data == nil {
			break
		}

		return e.complexity.Vote.Data(childComplexity), true

	case "Vote.id":
		if e.complexity.Vote.ID == nil {
			break
		}

		return e.complexity.Vote.ID(childComplexity), true

	case "Vote.message":
		if e.complexity.Vote.Message == nil {
			break
		}

		return e.complexity.Vote.Message(childComplexity), true

	case "Vote.node":
		if e.complexity.Vote.Node == nil {
			break
		}

		args, err := ec.field_Vote_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Vote.Node(childComplexity, args["filter"].(*model.NodeFilter)), true

	case "Vote.updatedAt":
		if e.complexity.Vote.UpdatedAt == nil {
			break
		}

		return e.complexity.Vote.UpdatedAt(childComplexity), true

	case "Vote.voteid":
		if e.complexity.Vote.Voteid == nil {
			break
		}

		return e.complexity.Vote.Voteid(childComplexity), true

	case "VoteAggregateResult.count":
		if e.complexity.VoteAggregateResult.Count == nil {
			break
		}

		return e.complexity.VoteAggregateResult.Count(childComplexity), true

	case "VoteAggregateResult.createdAtMax":
		if e.complexity.VoteAggregateResult.CreatedAtMax == nil {
			break
		}

		return e.complexity.VoteAggregateResult.CreatedAtMax(childComplexity), true

	case "VoteAggregateResult.createdAtMin":
		if e.complexity.VoteAggregateResult.CreatedAtMin == nil {
			break
		}

		return e.complexity.VoteAggregateResult.CreatedAtMin(childComplexity), true

	case "VoteAggregateResult.messageMax":
		if e.complexity.VoteAggregateResult.MessageMax == nil {
			break
		}

		return e.complexity.VoteAggregateResult.MessageMax(childComplexity), true

	case "VoteAggregateResult.messageMin":
		if e.complexity.VoteAggregateResult.MessageMin == nil {
			break
		}

		return e.complexity.VoteAggregateResult.MessageMin(childComplexity), true

	case "VoteAggregateResult.updatedAtMax":
		if e.complexity.VoteAggregateResult.UpdatedAtMax == nil {
			break
		}

		return e.complexity.VoteAggregateResult.UpdatedAtMax(childComplexity), true

	case "VoteAggregateResult.updatedAtMin":
		if e.complexity.VoteAggregateResult.UpdatedAtMin == nil {
			break
		}

		return e.complexity.VoteAggregateResult.UpdatedAtMin(childComplexity), true

	case "VoteAggregateResult.voteidMax":
		if e.complexity.VoteAggregateResult.VoteidMax == nil {
			break
		}

		return e.complexity.VoteAggregateResult.VoteidMax(childComplexity), true

	case "VoteAggregateResult.voteidMin":
		if e.complexity.VoteAggregateResult.VoteidMin == nil {
			break
		}

		return e.complexity.VoteAggregateResult.VoteidMin(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAddBlobInput,
		ec.unmarshalInputAddCommentInput,
		ec.unmarshalInputAddContractInput,
		ec.unmarshalInputAddEventCountInput,
		ec.unmarshalInputAddEventFragmentInput,
		ec.unmarshalInputAddEventInput,
		ec.unmarshalInputAddLabelInput,
		ec.unmarshalInputAddMandateInput,
		ec.unmarshalInputAddNodeFragmentInput,
		ec.unmarshalInputAddNodeInput,
		ec.unmarshalInputAddNotifInput,
		ec.unmarshalInputAddPendingUserInput,
		ec.unmarshalInputAddProjectCardInput,
		ec.unmarshalInputAddProjectColumnInput,
		ec.unmarshalInputAddProjectDraftInput,
		ec.unmarshalInputAddProjectFieldInput,
		ec.unmarshalInputAddProjectFieldValueInput,
		ec.unmarshalInputAddProjectInput,
		ec.unmarshalInputAddReactionInput,
		ec.unmarshalInputAddRoleExtInput,
		ec.unmarshalInputAddTensionInput,
		ec.unmarshalInputAddUserEventInput,
		ec.unmarshalInputAddUserInput,
		ec.unmarshalInputAddUserRightsInput,
		ec.unmarshalInputAddVoteInput,
		ec.unmarshalInputAuthRule,
		ec.unmarshalInputBlobFilter,
		ec.unmarshalInputBlobOrder,
		ec.unmarshalInputBlobPatch,
		ec.unmarshalInputBlobRef,
		ec.unmarshalInputBlobType_hash,
		ec.unmarshalInputCardKindFilter,
		ec.unmarshalInputCardKindRef,
		ec.unmarshalInputCommentFilter,
		ec.unmarshalInputCommentOrder,
		ec.unmarshalInputCommentPatch,
		ec.unmarshalInputCommentRef,
		ec.unmarshalInputContainsFilter,
		ec.unmarshalInputContractFilter,
		ec.unmarshalInputContractOrder,
		ec.unmarshalInputContractPatch,
		ec.unmarshalInputContractRef,
		ec.unmarshalInputContractStatus_hash,
		ec.unmarshalInputContractType_hash,
		ec.unmarshalInputCustomHTTP,
		ec.unmarshalInputDateTimeFilter,
		ec.unmarshalInputDateTimeRange,
		ec.unmarshalInputEventCountFilter,
		ec.unmarshalInputEventCountOrder,
		ec.unmarshalInputEventCountPatch,
		ec.unmarshalInputEventCountRef,
		ec.unmarshalInputEventFilter,
		ec.unmarshalInputEventFragmentFilter,
		ec.unmarshalInputEventFragmentOrder,
		ec.unmarshalInputEventFragmentPatch,
		ec.unmarshalInputEventFragmentRef,
		ec.unmarshalInputEventKindFilter,
		ec.unmarshalInputEventKindRef,
		ec.unmarshalInputEventOrder,
		ec.unmarshalInputEventPatch,
		ec.unmarshalInputEventRef,
		ec.unmarshalInputFloatFilter,
		ec.unmarshalInputFloatRange,
		ec.unmarshalInputGenerateMutationParams,
		ec.unmarshalInputGenerateQueryParams,
		ec.unmarshalInputInt64Filter,
		ec.unmarshalInputInt64Range,
		ec.unmarshalInputIntFilter,
		ec.unmarshalInputIntRange,
		ec.unmarshalInputIntersectsFilter,
		ec.unmarshalInputLabelFilter,
		ec.unmarshalInputLabelOrder,
		ec.unmarshalInputLabelPatch,
		ec.unmarshalInputLabelRef,
		ec.unmarshalInputMandateFilter,
		ec.unmarshalInputMandateOrder,
		ec.unmarshalInputMandatePatch,
		ec.unmarshalInputMandateRef,
		ec.unmarshalInputMultiPolygonRef,
		ec.unmarshalInputNearFilter,
		ec.unmarshalInputNodeFilter,
		ec.unmarshalInputNodeFragmentFilter,
		ec.unmarshalInputNodeFragmentOrder,
		ec.unmarshalInputNodeFragmentPatch,
		ec.unmarshalInputNodeFragmentRef,
		ec.unmarshalInputNodeMode_hash,
		ec.unmarshalInputNodeOrder,
		ec.unmarshalInputNodePatch,
		ec.unmarshalInputNodeRef,
		ec.unmarshalInputNodeType_hash,
		ec.unmarshalInputNodeVisibility_hash,
		ec.unmarshalInputNotifFilter,
		ec.unmarshalInputNotifOrder,
		ec.unmarshalInputNotifPatch,
		ec.unmarshalInputNotifRef,
		ec.unmarshalInputPendingUserFilter,
		ec.unmarshalInputPendingUserOrder,
		ec.unmarshalInputPendingUserPatch,
		ec.unmarshalInputPendingUserRef,
		ec.unmarshalInputPointGeoFilter,
		ec.unmarshalInputPointListRef,
		ec.unmarshalInputPointRef,
		ec.unmarshalInputPolygonGeoFilter,
		ec.unmarshalInputPolygonRef,
		ec.unmarshalInputPostFilter,
		ec.unmarshalInputPostOrder,
		ec.unmarshalInputPostPatch,
		ec.unmarshalInputPostRef,
		ec.unmarshalInputProjectCardFilter,
		ec.unmarshalInputProjectCardOrder,
		ec.unmarshalInputProjectCardPatch,
		ec.unmarshalInputProjectCardRef,
		ec.unmarshalInputProjectColumnFilter,
		ec.unmarshalInputProjectColumnOrder,
		ec.unmarshalInputProjectColumnPatch,
		ec.unmarshalInputProjectColumnRef,
		ec.unmarshalInputProjectDraftFilter,
		ec.unmarshalInputProjectDraftOrder,
		ec.unmarshalInputProjectDraftPatch,
		ec.unmarshalInputProjectDraftRef,
		ec.unmarshalInputProjectFieldFilter,
		ec.unmarshalInputProjectFieldPatch,
		ec.unmarshalInputProjectFieldRef,
		ec.unmarshalInputProjectFieldValueFilter,
		ec.unmarshalInputProjectFieldValueOrder,
		ec.unmarshalInputProjectFieldValuePatch,
		ec.unmarshalInputProjectFieldValueRef,
		ec.unmarshalInputProjectFilter,
		ec.unmarshalInputProjectOrder,
		ec.unmarshalInputProjectPatch,
		ec.unmarshalInputProjectRef,
		ec.unmarshalInputProjectStatus_hash,
		ec.unmarshalInputReactionFilter,
		ec.unmarshalInputReactionOrder,
		ec.unmarshalInputReactionPatch,
		ec.unmarshalInputReactionRef,
		ec.unmarshalInputRoleExtFilter,
		ec.unmarshalInputRoleExtOrder,
		ec.unmarshalInputRoleExtPatch,
		ec.unmarshalInputRoleExtRef,
		ec.unmarshalInputRoleType_hash,
		ec.unmarshalInputStringExactFilter,
		ec.unmarshalInputStringFullTextFilter,
		ec.unmarshalInputStringHashFilter,
		ec.unmarshalInputStringHashFilter_StringRegExpFilter,
		ec.unmarshalInputStringHashFilter_StringTermFilter,
		ec.unmarshalInputStringRange,
		ec.unmarshalInputStringRegExpFilter,
		ec.unmarshalInputStringTermFilter,
		ec.unmarshalInputTensionEvent_hash,
		ec.unmarshalInputTensionFilter,
		ec.unmarshalInputTensionOrder,
		ec.unmarshalInputTensionPatch,
		ec.unmarshalInputTensionRef,
		ec.unmarshalInputTensionStatus_hash,
		ec.unmarshalInputTensionType_hash,
		ec.unmarshalInputUpdateBlobInput,
		ec.unmarshalInputUpdateCommentInput,
		ec.unmarshalInputUpdateContractInput,
		ec.unmarshalInputUpdateEventCountInput,
		ec.unmarshalInputUpdateEventFragmentInput,
		ec.unmarshalInputUpdateEventInput,
		ec.unmarshalInputUpdateLabelInput,
		ec.unmarshalInputUpdateMandateInput,
		ec.unmarshalInputUpdateNodeFragmentInput,
		ec.unmarshalInputUpdateNodeInput,
		ec.unmarshalInputUpdateNotifInput,
		ec.unmarshalInputUpdatePendingUserInput,
		ec.unmarshalInputUpdatePostInput,
		ec.unmarshalInputUpdateProjectCardInput,
		ec.unmarshalInputUpdateProjectColumnInput,
		ec.unmarshalInputUpdateProjectDraftInput,
		ec.unmarshalInputUpdateProjectFieldInput,
		ec.unmarshalInputUpdateProjectFieldValueInput,
		ec.unmarshalInputUpdateProjectInput,
		ec.unmarshalInputUpdateReactionInput,
		ec.unmarshalInputUpdateRoleExtInput,
		ec.unmarshalInputUpdateTensionInput,
		ec.unmarshalInputUpdateUserEventInput,
		ec.unmarshalInputUpdateUserInput,
		ec.unmarshalInputUpdateUserRightsInput,
		ec.unmarshalInputUpdateVoteInput,
		ec.unmarshalInputUserEventFilter,
		ec.unmarshalInputUserEventOrder,
		ec.unmarshalInputUserEventPatch,
		ec.unmarshalInputUserEventRef,
		ec.unmarshalInputUserFilter,
		ec.unmarshalInputUserOrder,
		ec.unmarshalInputUserPatch,
		ec.unmarshalInputUserRef,
		ec.unmarshalInputUserRightsFilter,
		ec.unmarshalInputUserRightsOrder,
		ec.unmarshalInputUserRightsPatch,
		ec.unmarshalInputUserRightsRef,
		ec.unmarshalInputVoteFilter,
		ec.unmarshalInputVoteOrder,
		ec.unmarshalInputVotePatch,
		ec.unmarshalInputVoteRef,
		ec.unmarshalInputWithinFilter,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._queryMiddleware(ctx, rc.Operation, func(ctx context.Context) (interface{}, error) {
				return ec._Query(ctx, rc.Operation.SelectionSet), nil
			})
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../schema/schema.graphql", Input: `
directive @hook_addLabelInput on ARGUMENT_DEFINITION
directive @hook_addLabel on FIELD_DEFINITION
directive @hook_updateLabelInput on ARGUMENT_DEFINITION
directive @hook_updateLabel on FIELD_DEFINITION
directive @hook_deleteLabelInput on ARGUMENT_DEFINITION
directive @hook_deleteLabel on FIELD_DEFINITION
directive @hook_addRoleExtInput on ARGUMENT_DEFINITION
directive @hook_addRoleExt on FIELD_DEFINITION
directive @hook_updateRoleExtInput on ARGUMENT_DEFINITION
directive @hook_updateRoleExt on FIELD_DEFINITION
directive @hook_deleteRoleExtInput on ARGUMENT_DEFINITION
directive @hook_deleteRoleExt on FIELD_DEFINITION
directive @hook_addProjectInput on ARGUMENT_DEFINITION
directive @hook_addProject on FIELD_DEFINITION
directive @hook_updateProjectInput on ARGUMENT_DEFINITION
directive @hook_updateProject on FIELD_DEFINITION
directive @hook_deleteProjectInput on ARGUMENT_DEFINITION
directive @hook_deleteProject on FIELD_DEFINITION
directive @hook_addTensionInput on ARGUMENT_DEFINITION
directive @hook_addTension on FIELD_DEFINITION
directive @hook_updateTensionInput on ARGUMENT_DEFINITION
directive @hook_updateTension on FIELD_DEFINITION
directive @hook_deleteTensionInput on ARGUMENT_DEFINITION
directive @hook_deleteTension on FIELD_DEFINITION
directive @hook_addCommentInput on ARGUMENT_DEFINITION
directive @hook_addComment on FIELD_DEFINITION
directive @hook_updateCommentInput on ARGUMENT_DEFINITION
directive @hook_updateComment on FIELD_DEFINITION
directive @hook_deleteCommentInput on ARGUMENT_DEFINITION
directive @hook_deleteComment on FIELD_DEFINITION
directive @hook_addReactionInput on ARGUMENT_DEFINITION
directive @hook_addReaction on FIELD_DEFINITION
directive @hook_updateReactionInput on ARGUMENT_DEFINITION
directive @hook_updateReaction on FIELD_DEFINITION
directive @hook_deleteReactionInput on ARGUMENT_DEFINITION
directive @hook_deleteReaction on FIELD_DEFINITION
directive @hook_addContractInput on ARGUMENT_DEFINITION
directive @hook_addContract on FIELD_DEFINITION
directive @hook_updateContractInput on ARGUMENT_DEFINITION
directive @hook_updateContract on FIELD_DEFINITION
directive @hook_deleteContractInput on ARGUMENT_DEFINITION
directive @hook_deleteContract on FIELD_DEFINITION
directive @hook_addVoteInput on ARGUMENT_DEFINITION
directive @hook_addVote on FIELD_DEFINITION
directive @hook_updateVoteInput on ARGUMENT_DEFINITION
directive @hook_updateVote on FIELD_DEFINITION
directive @hook_deleteVoteInput on ARGUMENT_DEFINITION
directive @hook_deleteVote on FIELD_DEFINITION
directive @hook_addUserInput on ARGUMENT_DEFINITION
directive @hook_addUser on FIELD_DEFINITION
directive @hook_updateUserInput on ARGUMENT_DEFINITION
directive @hook_updateUser on FIELD_DEFINITION
directive @hook_deleteUserInput on ARGUMENT_DEFINITION
directive @hook_deleteUser on FIELD_DEFINITION
directive @hook_getLabelInput on ARGUMENT_DEFINITION
directive @hook_queryLabelInput on ARGUMENT_DEFINITION
directive @hook_getRoleExtInput on ARGUMENT_DEFINITION
directive @hook_queryRoleExtInput on ARGUMENT_DEFINITION
directive @hook_getProjectInput on ARGUMENT_DEFINITION
directive @hook_queryProjectInput on ARGUMENT_DEFINITION
directive @hook_getTensionInput on ARGUMENT_DEFINITION
directive @hook_queryTensionInput on ARGUMENT_DEFINITION
directive @hook_getCommentInput on ARGUMENT_DEFINITION
directive @hook_queryCommentInput on ARGUMENT_DEFINITION
directive @hook_getReactionInput on ARGUMENT_DEFINITION
directive @hook_queryReactionInput on ARGUMENT_DEFINITION
directive @hook_getContractInput on ARGUMENT_DEFINITION
directive @hook_queryContractInput on ARGUMENT_DEFINITION
directive @hook_getVoteInput on ARGUMENT_DEFINITION
directive @hook_queryVoteInput on ARGUMENT_DEFINITION
directive @hook_getUserInput on ARGUMENT_DEFINITION
directive @hook_queryUserInput on ARGUMENT_DEFINITION


directive @hidden on FIELD_DEFINITION

directive @private on FIELD_DEFINITION

directive @meta(f: String!, k: String) on FIELD_DEFINITION

directive @isContractValidator on FIELD_DEFINITION

directive @x_add(r: String, f: String, e: [TensionEvent!], n: Int) on INPUT_FIELD_DEFINITION

directive @x_set(r: String, f: String, e: [TensionEvent!], n: Int) on INPUT_FIELD_DEFINITION

directive @x_remove(r: String, f: String, e: [TensionEvent!], n: Int) on INPUT_FIELD_DEFINITION

directive @x_patch(r: String, f: String, e: [TensionEvent!], n: Int) on INPUT_FIELD_DEFINITION

directive @x_alter(r: String, f: String, e: [TensionEvent!], n: Int) on INPUT_FIELD_DEFINITION

directive @x_patch_ro on INPUT_FIELD_DEFINITION

directive @x_ro on INPUT_FIELD_DEFINITION

directive @w_add(a: String!) on INPUT_FIELD_DEFINITION

directive @w_set(a: String!) on INPUT_FIELD_DEFINITION

directive @w_remove(a: String!) on INPUT_FIELD_DEFINITION

directive @w_patch(a: String!) on INPUT_FIELD_DEFINITION

directive @w_alter(a: String!) on INPUT_FIELD_DEFINITION

directive @w_meta_patch(f: String!, k: String) on INPUT_FIELD_DEFINITION

type Node {
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime
  nameid: String!
  rootnameid: String!
  source(filter: BlobFilter): Blob
  name: String!
  about: String
  skills: [String!]
  isRoot: Boolean!
  parent(filter: NodeFilter): Node
  type_: NodeType!
  tensions_out(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension!]
  tensions_in(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension!]
  visibility: NodeVisibility!
  mode: NodeMode!
  rights: Int!
  isArchived: Boolean!
  isPersonal: Boolean
  userCanJoin: Boolean
  guestCanCreateTension: Boolean
  watchers(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User!]
  children(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node!]
  labels(filter: LabelFilter, order: LabelOrder, first: Int, offset: Int): [Label!]
  roles(filter: RoleExtFilter, order: RoleExtOrder, first: Int, offset: Int): [RoleExt!]
  projects(filter: ProjectFilter, order: ProjectOrder, first: Int, offset: Int): [Project!]
  pinned(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension!]
  role_ext(filter: RoleExtFilter): RoleExt
  role_type: RoleType
  color: String
  first_link(filter: UserFilter): User
  contracts(filter: VoteFilter, order: VoteOrder, first: Int, offset: Int): [Vote!]
  events_history(filter: EventFilter, order: EventOrder, first: Int, offset: Int): [Event!] @meta(f:"getNodeHistory", k:"nameid")

  tensions_outAggregate(filter: TensionFilter): TensionAggregateResult
  tensions_inAggregate(filter: TensionFilter): TensionAggregateResult
  watchersAggregate(filter: UserFilter): UserAggregateResult
  childrenAggregate(filter: NodeFilter): NodeAggregateResult
  labelsAggregate(filter: LabelFilter): LabelAggregateResult
  rolesAggregate(filter: RoleExtFilter): RoleExtAggregateResult
  projectsAggregate(filter: ProjectFilter): ProjectAggregateResult
  pinnedAggregate(filter: TensionFilter): TensionAggregateResult
  contractsAggregate(filter: VoteFilter): VoteAggregateResult
  events_historyAggregate(filter: EventFilter): EventAggregateResult
}

type NodeFragment {
  id: ID!
  nameid: String
  name: String
  about: String
  mandate(filter: MandateFilter): Mandate
  skills: [String!]
  visibility: NodeVisibility
  mode: NodeMode
  type_: NodeType
  first_link: String
  role_ext: String
  role_type: RoleType
  color: String
}

type Mandate {
  id: ID!
  purpose: String!
  responsabilities: String
  domains: String
  policies: String
}

type Label {
  id: ID!
  rootnameid: String!
  name: String!
  description: String
  color: String
  tensions(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension!]
  nodes(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node!]

  tensionsAggregate(filter: TensionFilter): TensionAggregateResult
  nodesAggregate(filter: NodeFilter): NodeAggregateResult
}

type RoleExt {
  id: ID!
  rootnameid: String!
  name: String!
  about: String
  role_type: RoleType!
  color: String
  mandate(filter: MandateFilter): Mandate
  roles(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node!]
  nodes(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node!]

  rolesAggregate(filter: NodeFilter): NodeAggregateResult
  nodesAggregate(filter: NodeFilter): NodeAggregateResult
}

type Project {
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime!
  rootnameid: String!
  parentnameid: String!
  nameid: String!
  name: String!
  description: String
  status: ProjectStatus!
  columns(filter: ProjectColumnFilter, order: ProjectColumnOrder, first: Int, offset: Int): [ProjectColumn!]
  fields(filter: ProjectFieldFilter, first: Int, offset: Int): [ProjectField!]
  leaders(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node!]
  nodes(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node!]

  columnsAggregate(filter: ProjectColumnFilter): ProjectColumnAggregateResult
  fieldsAggregate(filter: ProjectFieldFilter): ProjectFieldAggregateResult
  leadersAggregate(filter: NodeFilter): NodeAggregateResult
  nodesAggregate(filter: NodeFilter): NodeAggregateResult
}

type ProjectColumn {
  id: ID!
  name: String!
  description: String
  color: String
  pos: Int!
  col_type: ProjectColumnType!
  cards(filter: ProjectCardFilter, order: ProjectCardOrder, first: Int, offset: Int): [ProjectCard!]
  project(filter: ProjectFilter): Project!
  tensions(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension!]

  cardsAggregate(filter: ProjectCardFilter): ProjectCardAggregateResult
  tensionsAggregate(filter: TensionFilter): TensionAggregateResult
}

type ProjectCard {
  id: ID!
  pos: Int!
  card(filter: CardKindFilter): CardKind!
  pc(filter: ProjectColumnFilter): ProjectColumn!
  values(filter: ProjectFieldValueFilter, order: ProjectFieldValueOrder, first: Int, offset: Int): [ProjectFieldValue!]

  valuesAggregate(filter: ProjectFieldValueFilter): ProjectFieldValueAggregateResult
}

type ProjectField {
  field_type: ProjectFieldType!
  isVisible: Boolean!
  values(filter: ProjectFieldValueFilter, order: ProjectFieldValueOrder, first: Int, offset: Int): [ProjectFieldValue!]

  valuesAggregate(filter: ProjectFieldValueFilter): ProjectFieldValueAggregateResult
}

type ProjectFieldValue {
  field(filter: ProjectFieldFilter): ProjectField!
  value: String!
  pos: Int
}

union CardKind= Tension| ProjectDraft

enum ProjectColumnType {
  NormalColumn
  NoStatusColumn
}

enum ProjectFieldType {
  INT
  STRING
  DATE
  SINGLE_SELECT
}

type Post {
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime
  message: String
}

type ProjectDraft {
  title: String!
  message: String
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime
}

type Tension {
  emitter(filter: NodeFilter): Node!
  emitterid: String!
  receiver(filter: NodeFilter): Node!
  receiverid: String!
  title: String!
  type_: TensionType!
  status: TensionStatus!
  action: TensionAction
  assignees(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User!]
  labels(filter: LabelFilter, order: LabelOrder, first: Int, offset: Int): [Label!]
  comments(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment!]
  blobs(filter: BlobFilter, order: BlobOrder, first: Int, offset: Int): [Blob!]
  history(filter: EventFilter, order: EventOrder, first: Int, offset: Int): [Event!]
  mentions(filter: EventFilter, order: EventOrder, first: Int, offset: Int): [Event!]
  contracts(filter: ContractFilter, order: ContractOrder, first: Int, offset: Int): [Contract!]
  subscribers(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User!]
  project_statuses(filter: ProjectColumnFilter, order: ProjectColumnOrder, first: Int, offset: Int): [ProjectColumn!]
  n_comments: Int
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime
  message: String

  assigneesAggregate(filter: UserFilter): UserAggregateResult
  labelsAggregate(filter: LabelFilter): LabelAggregateResult
  commentsAggregate(filter: CommentFilter): CommentAggregateResult
  blobsAggregate(filter: BlobFilter): BlobAggregateResult
  historyAggregate(filter: EventFilter): EventAggregateResult
  mentionsAggregate(filter: EventFilter): EventAggregateResult
  contractsAggregate(filter: ContractFilter): ContractAggregateResult
  subscribersAggregate(filter: UserFilter): UserAggregateResult
  project_statusesAggregate(filter: ProjectColumnFilter): ProjectColumnAggregateResult
}

type Comment {
  message: String!
  reactions(filter: ReactionFilter, order: ReactionOrder, first: Int, offset: Int): [Reaction!]
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime

  reactionsAggregate(filter: ReactionFilter): ReactionAggregateResult
}

type Reaction {
  id: ID!
  reactionid: String!
  user(filter: UserFilter): User!
  comment(filter: CommentFilter): Comment!
  type_: Int!
}

type Blob {
  tension(filter: TensionFilter): Tension!
  blob_type: BlobType!
  pushedFlag: DateTime
  archivedFlag: DateTime
  node(filter: NodeFragmentFilter): NodeFragment
  md: String
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime
  message: String
}

type Event {
  tension(filter: TensionFilter): Tension!
  event_type: TensionEvent!
  mentioned(filter: TensionFilter): Tension
  old: String
  new: String
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime
  message: String
}

type EventFragment {
  event_type: TensionEvent!
  old: String
  new: String
}

type Contract {
  contractid: String!
  tension(filter: TensionFilter): Tension!
  status: ContractStatus!
  contract_type: ContractType!
  closedAt: DateTime
  event(filter: EventFragmentFilter): EventFragment!
  participants(filter: VoteFilter, order: VoteOrder, first: Int, offset: Int): [Vote!]!
  candidates(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User!]
  pending_candidates(filter: PendingUserFilter, order: PendingUserOrder, first: Int, offset: Int): [PendingUser!]
  comments(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment!]
  isValidator: Boolean @isContractValidator
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime
  message: String

  participantsAggregate(filter: VoteFilter): VoteAggregateResult
  candidatesAggregate(filter: UserFilter): UserAggregateResult
  pending_candidatesAggregate(filter: PendingUserFilter): PendingUserAggregateResult
  commentsAggregate(filter: CommentFilter): CommentAggregateResult
}

type Vote {
  voteid: String!
  contract(filter: ContractFilter): Contract!
  node(filter: NodeFilter): Node!
  data: [Int!]!
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime
  message: String
}

type User {
  id: ID!
  createdAt: DateTime!
  lastAck: DateTime!
  username: String!
  name: String
  email: String! @private
  password: String! @hidden
  bio: String
  location: String
  utc: String
  links: [String!]
  skills: [String!]
  notifyByEmail: Boolean!
  lang: Lang!
  subscriptions(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension!] @private
  watching(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node!] @private
  rights(filter: UserRightsFilter): UserRights!
  roles(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node!]
  tensions_created(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension!] @private
  tensions_assigned(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension!] @private
  contracts(filter: ContractFilter, order: ContractOrder, first: Int, offset: Int): [Contract!] @private
  reactions(filter: ReactionFilter, order: ReactionOrder, first: Int, offset: Int): [Reaction!]
  events(filter: UserEventFilter, order: UserEventOrder, first: Int, offset: Int): [UserEvent!] @private
  markAllAsRead: String
  event_count(filter: EventCountFilter): EventCount @meta(f:"getEventCount", k:"username")

  subscriptionsAggregate(filter: TensionFilter): TensionAggregateResult
  watchingAggregate(filter: NodeFilter): NodeAggregateResult
  rolesAggregate(filter: NodeFilter): NodeAggregateResult
  tensions_createdAggregate(filter: TensionFilter): TensionAggregateResult
  tensions_assignedAggregate(filter: TensionFilter): TensionAggregateResult
  contractsAggregate(filter: ContractFilter): ContractAggregateResult
  reactionsAggregate(filter: ReactionFilter): ReactionAggregateResult
  eventsAggregate(filter: UserEventFilter): UserEventAggregateResult
}

type PendingUser {
  id: ID!
  updatedAt: DateTime
  username: String!
  password: String @hidden
  email: String! @hidden
  email_token: String @hidden
  token: String @hidden
  contracts(filter: ContractFilter, order: ContractOrder, first: Int, offset: Int): [Contract!]
  subscribe: Boolean

  contractsAggregate(filter: ContractFilter): ContractAggregateResult
}

type UserRights {
  type_: UserType!
  canLogin: Boolean!
  canCreateRoot: Boolean!
  maxPublicOrga: Int!
  maxPrivateOrga: Int!
  hasEmailNotifications: Boolean!
}

type UserEvent {
  id: ID!
  createdAt: DateTime!
  isRead: Boolean!
  user(filter: UserFilter): User!
  event(filter: EventKindFilter, first: Int, offset: Int): [EventKind!]
}

union EventKind= Event| Contract| Notif

type Notif {
  tension_(filter: TensionFilter): Tension
  contract(filter: ContractFilter): Contract
  link: String
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime
  message: String
}

type EventCount {
  unread_events: Int
  pending_contracts: Int
  assigned_tensions: Int
}

enum NodeType {
  Circle
  Role
}

enum RoleType {


  Owner

  Member

  Guest

  Retired

  Pending


  Coordinator

  Peer

  Bot

}

enum NodeVisibility {
  Public

  Private

  Secret

}

enum NodeMode {
  Coordinated

  Agile

}

enum TensionStatus {
  Open
  Closed
}

enum TensionType {
  Operational
  Governance
  Help
  Alert
  Announcement

}

enum TensionAction {

  NewRole
  NewCircle
  NewMd

  EditRole
  EditCircle
  EditMd

  ArchivedRole
  ArchivedCircle
  ArchivedMd




}

enum TensionEvent {

  Created
  Reopened
  Closed
  TitleUpdated
  TypeUpdated
  CommentPushed
  AssigneeAdded
  AssigneeRemoved
  LabelAdded
  LabelRemoved
  BlobCreated
  BlobCommitted
  Mentioned
  Pinned
  Unpinned

  BlobPushed
  BlobArchived
  BlobUnarchived
  UserJoined
  UserLeft
  MemberLinked
  MemberUnlinked
  Authority
  Visibility
  Moved
}

enum BlobType {

  OnNode
  OnAbout
  OnMandate
  OnAboutAndMandate

  OnDoc

}

enum ProjectStatus {
  Open
  Closed
}

enum ContractStatus {
  Open
  Closed
  Canceled
}

enum ContractType {


  AnyCoordoDual

  AnyCandidates


  AnyCoordoSource

  AnyCoordoTarget
}

enum UserType {
  Regular

  Pro

  Root

}

enum Lang {
  EN
  FR
}

# Dgraph.Authorization {"Header":"X-Frac6-Auth","Namespace":"https://fractale.co/jwt/claims","Algo":"RS256","VerificationKey":"-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqfBbJAanlwf2mYlBszBA\nxgHw3hTu6gZ9nmej+5fCCdyA85IXhw14+F14o+vLogPe/giFuPMpG9eCOPWKvL/T\nGyahW5Lm8TRB4Pf54fZq5+VKdf5/i9u2e8CelpFvT+zLRdBmNVy9H9MitOF9mSGK\nHviPH1nHzU6TGvuVf44s60LAKliiwagALF+T/3ReDFhoqdLb1J3w4JkxFO6Guw5p\n3aDT+RMjjz9W8XpT3+k8IHocWxcEsuWMKdhuNwOHX2l7yU+/yLOrK1nuAMH7KewC\nCT4gJOan1qFO8NKe37jeQgsuRbhtF5C+L6CKs3n+B2A3ZOYB4gzdJfMLXxW/wwr1\nRQIDAQAB\n-----END PUBLIC KEY-----"}

directive @id on FIELD_DEFINITION

directive @secret(field: String!, pred: String) on OBJECT|INTERFACE

directive @remoteResponse(name: String) on FIELD_DEFINITION

directive @lambdaOnMutate(add: Boolean, update: Boolean, delete: Boolean) on OBJECT|INTERFACE

directive @withSubscription on OBJECT|INTERFACE|FIELD_DEFINITION

directive @custom(http: CustomHTTP, dql: String) on FIELD_DEFINITION

directive @lambda on FIELD_DEFINITION

directive @hasInverse(field: String!) on FIELD_DEFINITION

directive @search(by: [DgraphIndex!]) on FIELD_DEFINITION

directive @dgraph(type: String, pred: String) on OBJECT|INTERFACE|FIELD_DEFINITION

directive @auth(password: AuthRule, query: AuthRule, add: AuthRule, update: AuthRule, delete: AuthRule) on OBJECT|INTERFACE

directive @remote on OBJECT|INTERFACE|UNION|INPUT_OBJECT|ENUM

directive @cascade(fields: [String]) on FIELD

directive @cacheControl(maxAge: Int!) on QUERY

directive @generate(query: GenerateQueryParams, mutation: GenerateMutationParams, subscription: Boolean) on OBJECT|INTERFACE

input AddBlobInput {
  createdBy: UserRef!
  createdAt: DateTime! @w_add(a:"now")
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_alter(r:"isOwner", f:"createdBy")
  tension: TensionRef! @x_add(r:"ref")
  blob_type: BlobType!
  pushedFlag: DateTime
  archivedFlag: DateTime
  node: NodeFragmentRef
  md: String
}

type AddBlobPayload {
  blob(filter: BlobFilter, order: BlobOrder, first: Int, offset: Int): [Blob]
  numUids: Int
}

input AddCommentInput {
  createdBy: UserRef!
  createdAt: DateTime! @w_add(a:"now")
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String
  reactions: [ReactionRef!]
}

type AddCommentPayload {
  comment(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment]
  numUids: Int
}

input AddContractInput {
  createdBy: UserRef!
  createdAt: DateTime! @w_add(a:"now")
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_alter(r:"isOwner", f:"createdBy")
  contractid: String!
  tension: TensionRef! @x_add(r:"ref")
  status: ContractStatus!
  contract_type: ContractType!
  closedAt: DateTime
  event: EventFragmentRef!
  participants: [VoteRef!]!
  candidates: [UserRef!]
  pending_candidates: [PendingUserRef!]
  comments: [CommentRef!] @x_alter(r:"oneByOne")
  isValidator: Boolean
}

type AddContractPayload {
  contract(filter: ContractFilter, order: ContractOrder, first: Int, offset: Int): [Contract]
  numUids: Int
}

input AddEventCountInput {
  unread_events: Int
  pending_contracts: Int
  assigned_tensions: Int
}

type AddEventCountPayload {
  eventCount(filter: EventCountFilter, order: EventCountOrder, first: Int, offset: Int): [EventCount]
  numUids: Int
}

input AddEventFragmentInput {
  event_type: TensionEvent!
  old: String
  new: String
}

type AddEventFragmentPayload {
  eventFragment(filter: EventFragmentFilter, order: EventFragmentOrder, first: Int, offset: Int): [EventFragment]
  numUids: Int
}

input AddEventInput {
  createdBy: UserRef!
  createdAt: DateTime! @w_add(a:"now")
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_alter(r:"isOwner", f:"createdBy")
  tension: TensionRef! @x_add(r:"ref")
  event_type: TensionEvent!
  mentioned: TensionRef @x_add(r:"ref")
  old: String
  new: String
}

type AddEventPayload {
  event(filter: EventFilter, order: EventOrder, first: Int, offset: Int): [Event]
  numUids: Int
}

input AddLabelInput {
  rootnameid: String!
  name: String! @w_alter(a:"lower") @x_alter(r:"unique", f:"rootnameid") @x_alter(r:"minLen", n:1)
  description: String @x_alter(r:"maxLen", n:280)
  color: String
  tensions: [TensionRef!]
  nodes: [NodeRef!] @x_alter(r:"oneByOne") @x_alter(r:"ref")
}

type AddLabelPayload {
  label(filter: LabelFilter, order: LabelOrder, first: Int, offset: Int): [Label]
  numUids: Int
}

input AddMandateInput {
  purpose: String!
  responsabilities: String
  domains: String
  policies: String
}

type AddMandatePayload {
  mandate(filter: MandateFilter, order: MandateOrder, first: Int, offset: Int): [Mandate]
  numUids: Int
}

input AddNodeFragmentInput {
  nameid: String @w_add(a:"lower")
  name: String @x_alter(r:"minLen", n:1)
  about: String @x_alter(r:"maxLen", n:280)
  mandate: MandateRef
  skills: [String!]
  visibility: NodeVisibility
  mode: NodeMode
  type_: NodeType
  first_link: String
  role_ext: String
  role_type: RoleType
  color: String
}

type AddNodeFragmentPayload {
  nodeFragment(filter: NodeFragmentFilter, order: NodeFragmentOrder, first: Int, offset: Int): [NodeFragment]
  numUids: Int
}

input AddNodeInput {
  createdBy: UserRef!
  createdAt: DateTime!
  updatedAt: DateTime
  nameid: String!
  rootnameid: String!
  source: BlobRef
  name: String!
  about: String
  skills: [String!]
  isRoot: Boolean!
  parent: NodeRef
  type_: NodeType!
  tensions_out: [TensionRef!]
  tensions_in: [TensionRef!]
  visibility: NodeVisibility!
  mode: NodeMode!
  rights: Int!
  isArchived: Boolean!
  isPersonal: Boolean
  userCanJoin: Boolean
  guestCanCreateTension: Boolean
  watchers: [UserRef!]
  children: [NodeRef!]
  labels: [LabelRef!]
  roles: [RoleExtRef!]
  projects: [ProjectRef!]
  pinned: [TensionRef!] @x_add(r:"ref")
  role_ext: RoleExtRef
  role_type: RoleType
  color: String
  first_link: UserRef
  contracts: [VoteRef!]
  events_history: [EventRef!]
}

type AddNodePayload {
  node(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node]
  numUids: Int
}

input AddNotifInput {
  createdBy: UserRef!
  createdAt: DateTime! @w_add(a:"now")
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_alter(r:"isOwner", f:"createdBy")
  tension_: TensionRef
  contract: ContractRef
  link: String
}

type AddNotifPayload {
  notif(filter: NotifFilter, order: NotifOrder, first: Int, offset: Int): [Notif]
  numUids: Int
}

input AddPendingUserInput {
  updatedAt: DateTime
  username: String! @w_alter(a:"lower")
  password: String
  email: String! @w_alter(a:"lower")
  email_token: String
  token: String
  contracts: [ContractRef!]
  subscribe: Boolean
}

type AddPendingUserPayload {
  pendingUser(filter: PendingUserFilter, order: PendingUserOrder, first: Int, offset: Int): [PendingUser]
  numUids: Int
}

input AddProjectCardInput {
  pos: Int!
  card: CardKindRef! @x_alter(r:"ref")
  pc: ProjectColumnRef! @x_alter(r:"ref")
  values: [ProjectFieldValueRef!]
}

type AddProjectCardPayload {
  projectCard(filter: ProjectCardFilter, order: ProjectCardOrder, first: Int, offset: Int): [ProjectCard]
  numUids: Int
}

input AddProjectColumnInput {
  name: String!
  description: String @x_alter(r:"maxLen", n:280)
  color: String
  pos: Int!
  col_type: ProjectColumnType!
  cards: [ProjectCardRef!]
  project: ProjectRef! @x_alter(r:"ref")
  tensions: [TensionRef!]
}

type AddProjectColumnPayload {
  projectColumn(filter: ProjectColumnFilter, order: ProjectColumnOrder, first: Int, offset: Int): [ProjectColumn]
  numUids: Int
}

input AddProjectDraftInput {
  createdBy: UserRef!
  createdAt: DateTime! @w_add(a:"now")
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String
  title: String!
}

type AddProjectDraftPayload {
  projectDraft(filter: ProjectDraftFilter, order: ProjectDraftOrder, first: Int, offset: Int): [ProjectDraft]
  numUids: Int
}

input AddProjectFieldInput {
  field_type: ProjectFieldType!
  isVisible: Boolean!
  values: [ProjectFieldValueRef!]
}

type AddProjectFieldPayload {
  projectField(filter: ProjectFieldFilter, first: Int, offset: Int): [ProjectField]
  numUids: Int
}

input AddProjectFieldValueInput {
  field: ProjectFieldRef!
  value: String!
  pos: Int
}

type AddProjectFieldValuePayload {
  projectFieldValue(filter: ProjectFieldValueFilter, order: ProjectFieldValueOrder, first: Int, offset: Int): [ProjectFieldValue]
  numUids: Int
}

input AddProjectInput {
  createdBy: UserRef!
  createdAt: DateTime!
  updatedAt: DateTime!
  rootnameid: String!
  parentnameid: String!
  nameid: String! @w_alter(a:"lower") @x_alter(r:"unique", f:"parentnameid") @x_alter(r:"minLen", n:1)
  name: String! @x_alter(r:"minLen", n:1) @x_alter(r:"maxLen", n:100)
  description: String @x_alter(r:"maxLen", n:280)
  status: ProjectStatus!
  columns: [ProjectColumnRef!]
  fields: [ProjectFieldRef!]
  leaders: [NodeRef!] @x_alter(r:"ref")
  nodes: [NodeRef!] @x_alter(r:"oneByOne") @x_alter(r:"ref")
}

type AddProjectPayload {
  project(filter: ProjectFilter, order: ProjectOrder, first: Int, offset: Int): [Project]
  numUids: Int
}

input AddReactionInput {
  reactionid: String!
  user: UserRef! @x_add(r:"ref")
  comment: CommentRef! @x_add(r:"ref")
  type_: Int!
}

type AddReactionPayload {
  reaction(filter: ReactionFilter, order: ReactionOrder, first: Int, offset: Int): [Reaction]
  numUids: Int
}

input AddRoleExtInput {
  rootnameid: String!
  name: String! @w_alter(a:"lower") @x_alter(r:"unique", f:"rootnameid") @x_alter(r:"minLen", n:1)
  about: String @x_alter(r:"maxLen", n:280)
  role_type: RoleType!
  color: String
  mandate: MandateRef
  roles: [NodeRef!]
  nodes: [NodeRef!] @x_alter(r:"oneByOne") @x_alter(r:"ref")
}

type AddRoleExtPayload {
  roleExt(filter: RoleExtFilter, order: RoleExtOrder, first: Int, offset: Int): [RoleExt]
  numUids: Int
}

input AddTensionInput {
  createdBy: UserRef!
  createdAt: DateTime! @w_add(a:"now")
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_alter(r:"isOwner", f:"createdBy")
  emitter: NodeRef!
  emitterid: String!
  receiver: NodeRef!
  receiverid: String!
  title: String!
  type_: TensionType! @x_alter(r:"tensionTypeCheck")
  status: TensionStatus!
  action: TensionAction
  assignees: [UserRef!] @x_alter(r:"hasEvent", e:[AssigneeAdded, AssigneeRemoved]) @x_alter(r:"ref")
  labels: [LabelRef!] @x_alter(r:"hasEvent", e:[LabelAdded, LabelRemoved]) @x_alter(r:"ref")
  comments: [CommentRef!] @x_alter(r:"hasEvent", e:[Created, CommentPushed]) @x_alter(r:"oneByOne")
  blobs: [BlobRef!] @x_alter(r:"hasEvent", e:[BlobCreated, BlobCommitted]) @x_alter(r:"oneByOne")
  history: [EventRef!]
  mentions: [EventRef!]
  contracts: [ContractRef!] @x_add(r:"ref")
  subscribers: [UserRef!] @x_add(r:"ref")
  project_statuses: [ProjectColumnRef!]
  n_comments: Int
}

type AddTensionPayload {
  tension(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension]
  numUids: Int
}

input AddUserEventInput {
  createdAt: DateTime!
  isRead: Boolean!
  user: UserRef!
  event: [EventKindRef!] @x_add(r:"ref")
}

type AddUserEventPayload {
  userEvent(filter: UserEventFilter, order: UserEventOrder, first: Int, offset: Int): [UserEvent]
  numUids: Int
}

input AddUserInput {
  createdAt: DateTime!
  lastAck: DateTime!
  username: String! @w_add(a:"lower")
  name: String
  email: String! @w_add(a:"lower")
  password: String!
  bio: String @x_alter(r:"maxLen", n:280)
  location: String
  utc: String
  links: [String!]
  skills: [String!]
  notifyByEmail: Boolean!
  lang: Lang!
  subscriptions: [TensionRef!] @x_alter(r:"ref")
  watching: [NodeRef!] @x_alter(r:"ref")
  rights: UserRightsRef!
  roles: [NodeRef!] @x_add(r:"ref")
  tensions_created: [TensionRef!] @x_add(r:"ref")
  tensions_assigned: [TensionRef!] @x_add(r:"ref")
  contracts: [ContractRef!] @x_add(r:"ref")
  reactions: [ReactionRef!]
  events: [UserEventRef!]
  markAllAsRead: String
  event_count: EventCountRef
}

type AddUserPayload {
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  numUids: Int
}

input AddUserRightsInput {
  type_: UserType!
  canLogin: Boolean!
  canCreateRoot: Boolean!
  maxPublicOrga: Int!
  maxPrivateOrga: Int!
  hasEmailNotifications: Boolean!
}

type AddUserRightsPayload {
  userRights(filter: UserRightsFilter, order: UserRightsOrder, first: Int, offset: Int): [UserRights]
  numUids: Int
}

input AddVoteInput {
  createdBy: UserRef!
  createdAt: DateTime! @w_add(a:"now")
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_alter(r:"isOwner", f:"createdBy")
  voteid: String!
  contract: ContractRef! @x_add(r:"ref")
  node: NodeRef! @x_add(r:"ref")
  data: [Int!]!
}

type AddVotePayload {
  vote(filter: VoteFilter, order: VoteOrder, first: Int, offset: Int): [Vote]
  numUids: Int
}

input AuthRule {
  and: [AuthRule]
  or: [AuthRule]
  not: AuthRule
  rule: String
}

type BlobAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  messageMin: String
  messageMax: String
  pushedFlagMin: DateTime
  pushedFlagMax: DateTime
  archivedFlagMin: DateTime
  archivedFlagMax: DateTime
  mdMin: String
  mdMax: String
}

input BlobFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  blob_type: BlobType_hash
  pushedFlag: DateTimeFilter
  archivedFlag: DateTimeFilter
  has: [BlobHasFilter]
  and: [BlobFilter]
  or: [BlobFilter]
  not: BlobFilter
}

enum BlobHasFilter {
  createdBy
  createdAt
  updatedAt
  message
  tension
  blob_type
  pushedFlag
  archivedFlag
  node
  md
}

input BlobOrder {
  asc: BlobOrderable
  desc: BlobOrderable
  then: BlobOrder
}

enum BlobOrderable {
  createdAt
  updatedAt
  message
  pushedFlag
  archivedFlag
  md
}

input BlobPatch {
  createdBy: UserRef @x_patch_ro
  createdAt: DateTime @x_patch_ro
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_alter(r:"isOwner", f:"createdBy")
  tension: TensionRef @x_patch_ro
  blob_type: BlobType @x_patch_ro
  pushedFlag: DateTime @x_patch_ro
  archivedFlag: DateTime @x_patch_ro
  node: NodeFragmentRef @x_patch_ro
  md: String @x_patch_ro
}

input BlobRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime @w_add(a:"now")
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_alter(r:"isOwner", f:"createdBy")
  tension: TensionRef @x_add(r:"ref")
  blob_type: BlobType
  pushedFlag: DateTime
  archivedFlag: DateTime
  node: NodeFragmentRef
  md: String
}

input BlobType_hash {
  eq: BlobType
  in: [BlobType]
}

input CardKindFilter {
  memberTypes: [CardKindType!]
  tensionFilter: TensionFilter
  projectDraftFilter: ProjectDraftFilter
}

input CardKindRef {
  tensionRef: TensionRef
  projectDraftRef: ProjectDraftRef
}

enum CardKindType {
  Tension
  ProjectDraft
}

type CommentAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  messageMin: String
  messageMax: String
}

input CommentFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  has: [CommentHasFilter]
  and: [CommentFilter]
  or: [CommentFilter]
  not: CommentFilter
}

enum CommentHasFilter {
  createdBy
  createdAt
  updatedAt
  message
  reactions
}

input CommentOrder {
  asc: CommentOrderable
  desc: CommentOrderable
  then: CommentOrder
}

enum CommentOrderable {
  createdAt
  updatedAt
  message
}

input CommentPatch {
  createdBy: UserRef @x_patch_ro
  createdAt: DateTime @x_patch_ro
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String
  reactions: [ReactionRef!] @x_patch_ro
}

input CommentRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime @w_add(a:"now")
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String
  reactions: [ReactionRef!]
}

input ContainsFilter {
  point: PointRef
  polygon: PolygonRef
}

type ContractAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  messageMin: String
  messageMax: String
  contractidMin: String
  contractidMax: String
  closedAtMin: DateTime
  closedAtMax: DateTime
}

input ContractFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  contractid: StringHashFilter
  status: ContractStatus_hash
  contract_type: ContractType_hash
  closedAt: DateTimeFilter
  has: [ContractHasFilter]
  and: [ContractFilter]
  or: [ContractFilter]
  not: ContractFilter
}

enum ContractHasFilter {
  createdBy
  createdAt
  updatedAt
  message
  contractid
  tension
  status
  contract_type
  closedAt
  event
  participants
  candidates
  pending_candidates
  comments
  isValidator
}

input ContractOrder {
  asc: ContractOrderable
  desc: ContractOrderable
  then: ContractOrder
}

enum ContractOrderable {
  createdAt
  updatedAt
  message
  contractid
  closedAt
}

input ContractPatch {
  createdBy: UserRef @x_patch_ro
  createdAt: DateTime @x_patch_ro
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_alter(r:"isOwner", f:"createdBy")
  tension: TensionRef @x_patch_ro
  status: ContractStatus @x_patch_ro
  contract_type: ContractType @x_patch_ro
  closedAt: DateTime @x_patch_ro
  event: EventFragmentRef @x_patch_ro
  participants: [VoteRef!] @x_patch_ro
  candidates: [UserRef!] @x_patch_ro
  pending_candidates: [PendingUserRef!] @x_patch_ro
  comments: [CommentRef!] @x_alter(r:"oneByOne")
  isValidator: Boolean @x_patch_ro
}

input ContractRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime @w_add(a:"now")
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_alter(r:"isOwner", f:"createdBy")
  contractid: String
  tension: TensionRef @x_add(r:"ref")
  status: ContractStatus
  contract_type: ContractType
  closedAt: DateTime
  event: EventFragmentRef
  participants: [VoteRef!]
  candidates: [UserRef!]
  pending_candidates: [PendingUserRef!]
  comments: [CommentRef!] @x_alter(r:"oneByOne")
  isValidator: Boolean
}

input ContractStatus_hash {
  eq: ContractStatus
  in: [ContractStatus]
}

input ContractType_hash {
  eq: ContractType
  in: [ContractType]
}

input CustomHTTP {
  url: String!
  method: HTTPMethod!
  body: String
  graphql: String
  mode: Mode
  forwardHeaders: [String!]
  secretHeaders: [String!]
  introspectionHeaders: [String!]
  skipIntrospection: Boolean
}

scalar DateTime

input DateTimeFilter {
  eq: DateTime
  in: [DateTime]
  le: DateTime
  lt: DateTime
  ge: DateTime
  gt: DateTime
  between: DateTimeRange
}

input DateTimeRange {
  min: DateTime!
  max: DateTime!
}

type DeleteBlobPayload {
  blob(filter: BlobFilter, order: BlobOrder, first: Int, offset: Int): [Blob]
  msg: String
  numUids: Int
}

type DeleteCommentPayload {
  comment(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment]
  msg: String
  numUids: Int
}

type DeleteContractPayload {
  contract(filter: ContractFilter, order: ContractOrder, first: Int, offset: Int): [Contract]
  msg: String
  numUids: Int
}

type DeleteEventCountPayload {
  eventCount(filter: EventCountFilter, order: EventCountOrder, first: Int, offset: Int): [EventCount]
  msg: String
  numUids: Int
}

type DeleteEventFragmentPayload {
  eventFragment(filter: EventFragmentFilter, order: EventFragmentOrder, first: Int, offset: Int): [EventFragment]
  msg: String
  numUids: Int
}

type DeleteEventPayload {
  event(filter: EventFilter, order: EventOrder, first: Int, offset: Int): [Event]
  msg: String
  numUids: Int
}

type DeleteLabelPayload {
  label(filter: LabelFilter, order: LabelOrder, first: Int, offset: Int): [Label]
  msg: String
  numUids: Int
}

type DeleteMandatePayload {
  mandate(filter: MandateFilter, order: MandateOrder, first: Int, offset: Int): [Mandate]
  msg: String
  numUids: Int
}

type DeleteNodeFragmentPayload {
  nodeFragment(filter: NodeFragmentFilter, order: NodeFragmentOrder, first: Int, offset: Int): [NodeFragment]
  msg: String
  numUids: Int
}

type DeleteNodePayload {
  node(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node]
  msg: String
  numUids: Int
}

type DeleteNotifPayload {
  notif(filter: NotifFilter, order: NotifOrder, first: Int, offset: Int): [Notif]
  msg: String
  numUids: Int
}

type DeletePendingUserPayload {
  pendingUser(filter: PendingUserFilter, order: PendingUserOrder, first: Int, offset: Int): [PendingUser]
  msg: String
  numUids: Int
}

type DeletePostPayload {
  post(filter: PostFilter, order: PostOrder, first: Int, offset: Int): [Post]
  msg: String
  numUids: Int
}

type DeleteProjectCardPayload {
  projectCard(filter: ProjectCardFilter, order: ProjectCardOrder, first: Int, offset: Int): [ProjectCard]
  msg: String
  numUids: Int
}

type DeleteProjectColumnPayload {
  projectColumn(filter: ProjectColumnFilter, order: ProjectColumnOrder, first: Int, offset: Int): [ProjectColumn]
  msg: String
  numUids: Int
}

type DeleteProjectDraftPayload {
  projectDraft(filter: ProjectDraftFilter, order: ProjectDraftOrder, first: Int, offset: Int): [ProjectDraft]
  msg: String
  numUids: Int
}

type DeleteProjectFieldPayload {
  projectField(filter: ProjectFieldFilter, first: Int, offset: Int): [ProjectField]
  msg: String
  numUids: Int
}

type DeleteProjectFieldValuePayload {
  projectFieldValue(filter: ProjectFieldValueFilter, order: ProjectFieldValueOrder, first: Int, offset: Int): [ProjectFieldValue]
  msg: String
  numUids: Int
}

type DeleteProjectPayload {
  project(filter: ProjectFilter, order: ProjectOrder, first: Int, offset: Int): [Project]
  msg: String
  numUids: Int
}

type DeleteReactionPayload {
  reaction(filter: ReactionFilter, order: ReactionOrder, first: Int, offset: Int): [Reaction]
  msg: String
  numUids: Int
}

type DeleteRoleExtPayload {
  roleExt(filter: RoleExtFilter, order: RoleExtOrder, first: Int, offset: Int): [RoleExt]
  msg: String
  numUids: Int
}

type DeleteTensionPayload {
  tension(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension]
  msg: String
  numUids: Int
}

type DeleteUserEventPayload {
  userEvent(filter: UserEventFilter, order: UserEventOrder, first: Int, offset: Int): [UserEvent]
  msg: String
  numUids: Int
}

type DeleteUserPayload {
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  msg: String
  numUids: Int
}

type DeleteUserRightsPayload {
  userRights(filter: UserRightsFilter, order: UserRightsOrder, first: Int, offset: Int): [UserRights]
  msg: String
  numUids: Int
}

type DeleteVotePayload {
  vote(filter: VoteFilter, order: VoteOrder, first: Int, offset: Int): [Vote]
  msg: String
  numUids: Int
}

enum DgraphIndex {
  int
  int64
  float
  bool
  hash
  exact
  term
  fulltext
  trigram
  regexp
  year
  month
  day
  hour
  geo
}

enum ErrorBla {
  ContactCoordo
  OrgaLimitReached
  MemberLimitReached
  EmailLimitReached
  StorageLimitReached
}

type EventAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  messageMin: String
  messageMax: String
  oldMin: String
  oldMax: String
  newMin: String
  newMax: String
}

type EventCountAggregateResult {
  count: Int
  unread_eventsMin: Int
  unread_eventsMax: Int
  unread_eventsSum: Int
  unread_eventsAvg: Float
  pending_contractsMin: Int
  pending_contractsMax: Int
  pending_contractsSum: Int
  pending_contractsAvg: Float
  assigned_tensionsMin: Int
  assigned_tensionsMax: Int
  assigned_tensionsSum: Int
  assigned_tensionsAvg: Float
}

input EventCountFilter {
  has: [EventCountHasFilter]
  and: [EventCountFilter]
  or: [EventCountFilter]
  not: EventCountFilter
}

enum EventCountHasFilter {
  unread_events
  pending_contracts
  assigned_tensions
}

input EventCountOrder {
  asc: EventCountOrderable
  desc: EventCountOrderable
  then: EventCountOrder
}

enum EventCountOrderable {
  unread_events
  pending_contracts
  assigned_tensions
}

input EventCountPatch {
  unread_events: Int @x_patch_ro
  pending_contracts: Int @x_patch_ro
  assigned_tensions: Int @x_patch_ro
}

input EventCountRef {
  unread_events: Int
  pending_contracts: Int
  assigned_tensions: Int
}

input EventFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  event_type: TensionEvent_hash
  has: [EventHasFilter]
  and: [EventFilter]
  or: [EventFilter]
  not: EventFilter
}

type EventFragmentAggregateResult {
  count: Int
  oldMin: String
  oldMax: String
  newMin: String
  newMax: String
}

input EventFragmentFilter {
  event_type: TensionEvent_hash
  has: [EventFragmentHasFilter]
  and: [EventFragmentFilter]
  or: [EventFragmentFilter]
  not: EventFragmentFilter
}

enum EventFragmentHasFilter {
  event_type
  old
  new
}

input EventFragmentOrder {
  asc: EventFragmentOrderable
  desc: EventFragmentOrderable
  then: EventFragmentOrder
}

enum EventFragmentOrderable {
  old
  new
}

input EventFragmentPatch {
  event_type: TensionEvent @x_patch_ro
  old: String @x_patch_ro
  new: String @x_patch_ro
}

input EventFragmentRef {
  event_type: TensionEvent
  old: String
  new: String
}

enum EventHasFilter {
  createdBy
  createdAt
  updatedAt
  message
  tension
  event_type
  mentioned
  old
  new
}

input EventKindFilter {
  memberTypes: [EventKindType!]
  eventFilter: EventFilter
  contractFilter: ContractFilter
  notifFilter: NotifFilter
}

input EventKindRef {
  eventRef: EventRef
  contractRef: ContractRef
  notifRef: NotifRef
}

enum EventKindType {
  Event
  Contract
  Notif
}

input EventOrder {
  asc: EventOrderable
  desc: EventOrderable
  then: EventOrder
}

enum EventOrderable {
  createdAt
  updatedAt
  message
  old
  new
}

input EventPatch {
  createdBy: UserRef @x_patch_ro
  createdAt: DateTime @x_patch_ro
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_alter(r:"isOwner", f:"createdBy")
  tension: TensionRef @x_patch_ro
  event_type: TensionEvent @x_patch_ro
  mentioned: TensionRef @x_patch_ro
  old: String @x_patch_ro
  new: String @x_patch_ro
}

input EventRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime @w_add(a:"now")
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_alter(r:"isOwner", f:"createdBy")
  tension: TensionRef @x_add(r:"ref")
  event_type: TensionEvent
  mentioned: TensionRef @x_add(r:"ref")
  old: String
  new: String
}

input FloatFilter {
  eq: Float
  in: [Float]
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: FloatRange
}

input FloatRange {
  min: Float!
  max: Float!
}

input GenerateMutationParams {
  add: Boolean
  update: Boolean
  delete: Boolean
}

input GenerateQueryParams {
  get: Boolean
  query: Boolean
  password: Boolean
  aggregate: Boolean
}

enum HTTPMethod {
  GET
  POST
  PUT
  PATCH
  DELETE
}

scalar Int64

input Int64Filter {
  eq: Int64
  in: [Int64]
  le: Int64
  lt: Int64
  ge: Int64
  gt: Int64
  between: Int64Range
}

input Int64Range {
  min: Int64!
  max: Int64!
}

input IntersectsFilter {
  polygon: PolygonRef
  multiPolygon: MultiPolygonRef
}

input IntFilter {
  eq: Int
  in: [Int]
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: IntRange
}

input IntRange {
  min: Int!
  max: Int!
}

type LabelAggregateResult {
  count: Int
  rootnameidMin: String
  rootnameidMax: String
  nameMin: String
  nameMax: String
  descriptionMin: String
  descriptionMax: String
  colorMin: String
  colorMax: String
}

input LabelFilter {
  id: [ID!]
  rootnameid: StringHashFilter
  name: StringHashFilter_StringTermFilter @w_alter(a:"lower")
  has: [LabelHasFilter]
  and: [LabelFilter]
  or: [LabelFilter]
  not: LabelFilter
}

enum LabelHasFilter {
  rootnameid
  name
  description
  color
  tensions
  nodes
}

input LabelOrder {
  asc: LabelOrderable
  desc: LabelOrderable
  then: LabelOrder
}

enum LabelOrderable {
  rootnameid
  name
  description
  color
}

input LabelPatch {
  rootnameid: String @x_patch_ro
  name: String @w_alter(a:"lower") @x_alter(r:"unique", f:"rootnameid") @x_alter(r:"minLen", n:1)
  description: String @x_alter(r:"maxLen", n:280)
  color: String
  tensions: [TensionRef!] @x_ro
  nodes: [NodeRef!] @x_alter(r:"oneByOne") @x_alter(r:"ref")
}

input LabelRef {
  id: ID
  rootnameid: String
  name: String @w_alter(a:"lower") @x_alter(r:"unique", f:"rootnameid") @x_alter(r:"minLen", n:1)
  description: String @x_alter(r:"maxLen", n:280)
  color: String
  tensions: [TensionRef!] @x_ro
  nodes: [NodeRef!] @x_alter(r:"oneByOne") @x_alter(r:"ref")
}

type MandateAggregateResult {
  count: Int
  purposeMin: String
  purposeMax: String
  responsabilitiesMin: String
  responsabilitiesMax: String
  domainsMin: String
  domainsMax: String
  policiesMin: String
  policiesMax: String
}

input MandateFilter {
  id: [ID!]
  purpose: StringFullTextFilter
  has: [MandateHasFilter]
  and: [MandateFilter]
  or: [MandateFilter]
  not: MandateFilter
}

enum MandateHasFilter {
  purpose
  responsabilities
  domains
  policies
}

input MandateOrder {
  asc: MandateOrderable
  desc: MandateOrderable
  then: MandateOrder
}

enum MandateOrderable {
  purpose
  responsabilities
  domains
  policies
}

input MandatePatch {
  purpose: String
  responsabilities: String
  domains: String
  policies: String
}

input MandateRef {
  id: ID
  purpose: String
  responsabilities: String
  domains: String
  policies: String
}

enum Mode {
  BATCH
  SINGLE
}

type MultiPolygon {
  polygons: [Polygon!]!
}

input MultiPolygonRef {
  polygons: [PolygonRef!]!
}

type Mutation {
  addNode(input: [AddNodeInput!]!, upsert: Boolean): AddNodePayload
  updateNode(input: UpdateNodeInput!): UpdateNodePayload
  deleteNode(filter: NodeFilter!): DeleteNodePayload
  addNodeFragment(input: [AddNodeFragmentInput!]!): AddNodeFragmentPayload
  updateNodeFragment(input: UpdateNodeFragmentInput!): UpdateNodeFragmentPayload
  deleteNodeFragment(filter: NodeFragmentFilter!): DeleteNodeFragmentPayload
  addMandate(input: [AddMandateInput!]!): AddMandatePayload
  updateMandate(input: UpdateMandateInput!): UpdateMandatePayload
  deleteMandate(filter: MandateFilter!): DeleteMandatePayload
  addLabel(input: [AddLabelInput!]! @hook_addLabelInput): AddLabelPayload @hook_addLabel
  updateLabel(input: UpdateLabelInput! @hook_updateLabelInput): UpdateLabelPayload @hook_updateLabel
  deleteLabel(filter: LabelFilter! @hook_deleteLabelInput): DeleteLabelPayload @hook_deleteLabel
  addRoleExt(input: [AddRoleExtInput!]! @hook_addRoleExtInput): AddRoleExtPayload @hook_addRoleExt
  updateRoleExt(input: UpdateRoleExtInput! @hook_updateRoleExtInput): UpdateRoleExtPayload @hook_updateRoleExt
  deleteRoleExt(filter: RoleExtFilter! @hook_deleteRoleExtInput): DeleteRoleExtPayload @hook_deleteRoleExt
  addProject(input: [AddProjectInput!]! @hook_addProjectInput): AddProjectPayload @hook_addProject
  updateProject(input: UpdateProjectInput! @hook_updateProjectInput): UpdateProjectPayload @hook_updateProject
  deleteProject(filter: ProjectFilter! @hook_deleteProjectInput): DeleteProjectPayload @hook_deleteProject
  addProjectColumn(input: [AddProjectColumnInput!]!): AddProjectColumnPayload
  updateProjectColumn(input: UpdateProjectColumnInput!): UpdateProjectColumnPayload
  deleteProjectColumn(filter: ProjectColumnFilter!): DeleteProjectColumnPayload
  addProjectCard(input: [AddProjectCardInput!]!): AddProjectCardPayload
  updateProjectCard(input: UpdateProjectCardInput!): UpdateProjectCardPayload
  deleteProjectCard(filter: ProjectCardFilter!): DeleteProjectCardPayload
  addProjectField(input: [AddProjectFieldInput!]!): AddProjectFieldPayload
  updateProjectField(input: UpdateProjectFieldInput!): UpdateProjectFieldPayload
  deleteProjectField(filter: ProjectFieldFilter!): DeleteProjectFieldPayload
  addProjectFieldValue(input: [AddProjectFieldValueInput!]!): AddProjectFieldValuePayload
  updateProjectFieldValue(input: UpdateProjectFieldValueInput!): UpdateProjectFieldValuePayload
  deleteProjectFieldValue(filter: ProjectFieldValueFilter!): DeleteProjectFieldValuePayload
  updatePost(input: UpdatePostInput!): UpdatePostPayload
  deletePost(filter: PostFilter!): DeletePostPayload
  addProjectDraft(input: [AddProjectDraftInput!]!): AddProjectDraftPayload
  updateProjectDraft(input: UpdateProjectDraftInput!): UpdateProjectDraftPayload
  deleteProjectDraft(filter: ProjectDraftFilter!): DeleteProjectDraftPayload
  addTension(input: [AddTensionInput!]! @hook_addTensionInput): AddTensionPayload @hook_addTension
  updateTension(input: UpdateTensionInput! @hook_updateTensionInput): UpdateTensionPayload @hook_updateTension
  deleteTension(filter: TensionFilter! @hook_deleteTensionInput): DeleteTensionPayload @hook_deleteTension
  addComment(input: [AddCommentInput!]! @hook_addCommentInput): AddCommentPayload @hook_addComment
  updateComment(input: UpdateCommentInput! @hook_updateCommentInput): UpdateCommentPayload @hook_updateComment
  deleteComment(filter: CommentFilter! @hook_deleteCommentInput): DeleteCommentPayload @hook_deleteComment
  addReaction(input: [AddReactionInput!]! @hook_addReactionInput, upsert: Boolean): AddReactionPayload @hook_addReaction
  updateReaction(input: UpdateReactionInput! @hook_updateReactionInput): UpdateReactionPayload @hook_updateReaction
  deleteReaction(filter: ReactionFilter! @hook_deleteReactionInput): DeleteReactionPayload @hook_deleteReaction
  addBlob(input: [AddBlobInput!]!): AddBlobPayload
  updateBlob(input: UpdateBlobInput!): UpdateBlobPayload
  deleteBlob(filter: BlobFilter!): DeleteBlobPayload
  addEvent(input: [AddEventInput!]!): AddEventPayload
  updateEvent(input: UpdateEventInput!): UpdateEventPayload
  deleteEvent(filter: EventFilter!): DeleteEventPayload
  addEventFragment(input: [AddEventFragmentInput!]!): AddEventFragmentPayload
  updateEventFragment(input: UpdateEventFragmentInput!): UpdateEventFragmentPayload
  deleteEventFragment(filter: EventFragmentFilter!): DeleteEventFragmentPayload
  addContract(input: [AddContractInput!]! @hook_addContractInput, upsert: Boolean): AddContractPayload @hook_addContract
  updateContract(input: UpdateContractInput! @hook_updateContractInput): UpdateContractPayload @hook_updateContract
  deleteContract(filter: ContractFilter! @hook_deleteContractInput): DeleteContractPayload @hook_deleteContract
  addVote(input: [AddVoteInput!]! @hook_addVoteInput, upsert: Boolean): AddVotePayload @hook_addVote
  updateVote(input: UpdateVoteInput! @hook_updateVoteInput): UpdateVotePayload @hook_updateVote
  deleteVote(filter: VoteFilter! @hook_deleteVoteInput): DeleteVotePayload @hook_deleteVote
  addUser(input: [AddUserInput!]! @hook_addUserInput, upsert: Boolean): AddUserPayload @hook_addUser
  updateUser(input: UpdateUserInput! @hook_updateUserInput): UpdateUserPayload @hook_updateUser
  deleteUser(filter: UserFilter! @hook_deleteUserInput): DeleteUserPayload @hook_deleteUser
  addPendingUser(input: [AddPendingUserInput!]!, upsert: Boolean): AddPendingUserPayload
  updatePendingUser(input: UpdatePendingUserInput!): UpdatePendingUserPayload
  deletePendingUser(filter: PendingUserFilter!): DeletePendingUserPayload
  addUserRights(input: [AddUserRightsInput!]!): AddUserRightsPayload
  updateUserRights(input: UpdateUserRightsInput!): UpdateUserRightsPayload
  deleteUserRights(filter: UserRightsFilter!): DeleteUserRightsPayload
  addUserEvent(input: [AddUserEventInput!]!): AddUserEventPayload
  updateUserEvent(input: UpdateUserEventInput!): UpdateUserEventPayload
  deleteUserEvent(filter: UserEventFilter!): DeleteUserEventPayload
  addNotif(input: [AddNotifInput!]!): AddNotifPayload
  updateNotif(input: UpdateNotifInput!): UpdateNotifPayload
  deleteNotif(filter: NotifFilter!): DeleteNotifPayload
  addEventCount(input: [AddEventCountInput!]!): AddEventCountPayload
  updateEventCount(input: UpdateEventCountInput!): UpdateEventCountPayload
  deleteEventCount(filter: EventCountFilter!): DeleteEventCountPayload
}

input NearFilter {
  distance: Float!
  coordinate: PointRef!
}

type NodeAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  nameidMin: String
  nameidMax: String
  rootnameidMin: String
  rootnameidMax: String
  nameMin: String
  nameMax: String
  aboutMin: String
  aboutMax: String
  rightsMin: Int
  rightsMax: Int
  rightsSum: Int
  rightsAvg: Float
  colorMin: String
  colorMax: String
}

input NodeFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  nameid: StringHashFilter_StringRegExpFilter
  rootnameid: StringHashFilter_StringRegExpFilter
  name: StringFullTextFilter
  about: StringFullTextFilter
  skills: StringTermFilter
  isRoot: Boolean
  type_: NodeType_hash
  visibility: NodeVisibility_hash
  mode: NodeMode_hash
  isArchived: Boolean
  isPersonal: Boolean
  role_type: RoleType_hash
  has: [NodeHasFilter]
  and: [NodeFilter]
  or: [NodeFilter]
  not: NodeFilter
}

type NodeFragmentAggregateResult {
  count: Int
  nameidMin: String
  nameidMax: String
  nameMin: String
  nameMax: String
  aboutMin: String
  aboutMax: String
  first_linkMin: String
  first_linkMax: String
  role_extMin: String
  role_extMax: String
  colorMin: String
  colorMax: String
}

input NodeFragmentFilter {
  id: [ID!]
  has: [NodeFragmentHasFilter]
  and: [NodeFragmentFilter]
  or: [NodeFragmentFilter]
  not: NodeFragmentFilter
}

enum NodeFragmentHasFilter {
  nameid
  name
  about
  mandate
  skills
  visibility
  mode
  type_
  first_link
  role_ext
  role_type
  color
}

input NodeFragmentOrder {
  asc: NodeFragmentOrderable
  desc: NodeFragmentOrderable
  then: NodeFragmentOrder
}

enum NodeFragmentOrderable {
  nameid
  name
  about
  first_link
  role_ext
  color
}

input NodeFragmentPatch {
  nameid: String @x_patch_ro
  name: String @x_alter(r:"minLen", n:1)
  about: String @x_alter(r:"maxLen", n:280)
  mandate: MandateRef
  skills: [String!]
  visibility: NodeVisibility @x_patch_ro
  mode: NodeMode @x_patch_ro
  type_: NodeType @x_patch_ro
  first_link: String @x_patch_ro
  role_ext: String @x_patch_ro
  role_type: RoleType @x_patch_ro
  color: String @x_patch_ro
}

input NodeFragmentRef {
  id: ID
  nameid: String @w_add(a:"lower")
  name: String @x_alter(r:"minLen", n:1)
  about: String @x_alter(r:"maxLen", n:280)
  mandate: MandateRef
  skills: [String!]
  visibility: NodeVisibility
  mode: NodeMode
  type_: NodeType
  first_link: String
  role_ext: String
  role_type: RoleType
  color: String
}

enum NodeHasFilter {
  createdBy
  createdAt
  updatedAt
  nameid
  rootnameid
  source
  name
  about
  skills
  isRoot
  parent
  type_
  tensions_out
  tensions_in
  visibility
  mode
  rights
  isArchived
  isPersonal
  userCanJoin
  guestCanCreateTension
  watchers
  children
  labels
  roles
  projects
  pinned
  role_ext
  role_type
  color
  first_link
  contracts
  events_history
}

input NodeMode_hash {
  eq: NodeMode
  in: [NodeMode]
}

input NodeOrder {
  asc: NodeOrderable
  desc: NodeOrderable
  then: NodeOrder
}

enum NodeOrderable {
  createdAt
  updatedAt
  nameid
  rootnameid
  name
  about
  rights
  color
}

input NodePatch {
  createdBy: UserRef @x_patch_ro
  createdAt: DateTime @x_patch_ro
  updatedAt: DateTime @x_patch_ro
  rootnameid: String @x_patch_ro
  source: BlobRef @x_patch_ro
  name: String @x_patch_ro
  about: String @x_patch_ro
  skills: [String!] @x_patch_ro
  isRoot: Boolean @x_patch_ro
  parent: NodeRef @x_patch_ro
  type_: NodeType @x_patch_ro
  tensions_out: [TensionRef!] @x_patch_ro
  tensions_in: [TensionRef!] @x_patch_ro
  visibility: NodeVisibility @x_patch_ro
  mode: NodeMode @x_patch_ro
  rights: Int @x_patch_ro
  isArchived: Boolean @x_patch_ro
  isPersonal: Boolean @x_patch_ro
  userCanJoin: Boolean @x_patch_ro
  guestCanCreateTension: Boolean @x_patch_ro
  watchers: [UserRef!] @x_patch_ro
  children: [NodeRef!] @x_patch_ro
  labels: [LabelRef!] @x_patch_ro
  roles: [RoleExtRef!] @x_patch_ro
  projects: [ProjectRef!] @x_patch_ro
  pinned: [TensionRef!] @x_patch_ro
  role_ext: RoleExtRef @x_patch_ro
  role_type: RoleType @x_patch_ro
  color: String @x_patch_ro
  first_link: UserRef @x_patch_ro
  contracts: [VoteRef!] @x_patch_ro
  events_history: [EventRef!] @x_patch_ro
}

input NodeRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime
  updatedAt: DateTime
  nameid: String
  rootnameid: String
  source: BlobRef
  name: String
  about: String
  skills: [String!]
  isRoot: Boolean
  parent: NodeRef
  type_: NodeType
  tensions_out: [TensionRef!]
  tensions_in: [TensionRef!]
  visibility: NodeVisibility
  mode: NodeMode
  rights: Int
  isArchived: Boolean
  isPersonal: Boolean
  userCanJoin: Boolean
  guestCanCreateTension: Boolean
  watchers: [UserRef!]
  children: [NodeRef!]
  labels: [LabelRef!]
  roles: [RoleExtRef!]
  projects: [ProjectRef!]
  pinned: [TensionRef!] @x_add(r:"ref")
  role_ext: RoleExtRef
  role_type: RoleType
  color: String
  first_link: UserRef
  contracts: [VoteRef!]
  events_history: [EventRef!]
}

input NodeType_hash {
  eq: NodeType
  in: [NodeType]
}

input NodeVisibility_hash {
  eq: NodeVisibility
  in: [NodeVisibility]
}

type NotifAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  messageMin: String
  messageMax: String
  linkMin: String
  linkMax: String
}

input NotifFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  has: [NotifHasFilter]
  and: [NotifFilter]
  or: [NotifFilter]
  not: NotifFilter
}

enum NotifHasFilter {
  createdBy
  createdAt
  updatedAt
  message
  tension_
  contract
  link
}

input NotifOrder {
  asc: NotifOrderable
  desc: NotifOrderable
  then: NotifOrder
}

enum NotifOrderable {
  createdAt
  updatedAt
  message
  link
}

input NotifPatch {
  createdBy: UserRef @x_patch_ro
  createdAt: DateTime @x_patch_ro
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_alter(r:"isOwner", f:"createdBy")
  tension_: TensionRef @x_patch_ro
  contract: ContractRef @x_patch_ro
  link: String @x_patch_ro
}

input NotifRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime @w_add(a:"now")
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_alter(r:"isOwner", f:"createdBy")
  tension_: TensionRef
  contract: ContractRef
  link: String
}

type PendingUserAggregateResult {
  count: Int
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  usernameMin: String
  usernameMax: String
  passwordMin: String
  passwordMax: String
  emailMin: String
  emailMax: String
  email_tokenMin: String
  email_tokenMax: String
  tokenMin: String
  tokenMax: String
}

input PendingUserFilter {
  id: [ID!]
  username: StringHashFilter @w_alter(a:"lower")
  email: StringHashFilter @w_alter(a:"lower")
  email_token: StringHashFilter
  token: StringHashFilter
  has: [PendingUserHasFilter]
  and: [PendingUserFilter]
  or: [PendingUserFilter]
  not: PendingUserFilter
}

enum PendingUserHasFilter {
  updatedAt
  username
  password
  email
  email_token
  token
  contracts
  subscribe
}

input PendingUserOrder {
  asc: PendingUserOrderable
  desc: PendingUserOrderable
  then: PendingUserOrder
}

enum PendingUserOrderable {
  updatedAt
  username
  password
  email
  email_token
  token
}

input PendingUserPatch {
  updatedAt: DateTime @x_patch_ro
  password: String @x_patch_ro
  email_token: String @x_patch_ro
  token: String @x_patch_ro
  contracts: [ContractRef!] @x_patch_ro
  subscribe: Boolean @x_patch_ro
}

input PendingUserRef {
  id: ID
  updatedAt: DateTime
  username: String @w_alter(a:"lower")
  password: String
  email: String @w_alter(a:"lower")
  email_token: String
  token: String
  contracts: [ContractRef!]
  subscribe: Boolean
}

type Point {
  longitude: Float!
  latitude: Float!
}

input PointGeoFilter {
  near: NearFilter
  within: WithinFilter
}

type PointList {
  points: [Point!]!
}

input PointListRef {
  points: [PointRef!]!
}

input PointRef {
  longitude: Float!
  latitude: Float!
}

type Polygon {
  coordinates: [PointList!]!
}

input PolygonGeoFilter {
  near: NearFilter
  within: WithinFilter
  contains: ContainsFilter
  intersects: IntersectsFilter
}

input PolygonRef {
  coordinates: [PointListRef!]!
}

type PostAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  messageMin: String
  messageMax: String
}

input PostFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  has: [PostHasFilter]
  and: [PostFilter]
  or: [PostFilter]
  not: PostFilter
}

enum PostHasFilter {
  createdBy
  createdAt
  updatedAt
  message
}

input PostOrder {
  asc: PostOrderable
  desc: PostOrderable
  then: PostOrder
}

enum PostOrderable {
  createdAt
  updatedAt
  message
}

input PostPatch {
  createdBy: UserRef @x_patch_ro
  createdAt: DateTime @x_patch_ro
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_alter(r:"isOwner", f:"createdBy")
}

input PostRef {
  id: ID!
}

type ProjectAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  rootnameidMin: String
  rootnameidMax: String
  parentnameidMin: String
  parentnameidMax: String
  nameidMin: String
  nameidMax: String
  nameMin: String
  nameMax: String
  descriptionMin: String
  descriptionMax: String
}

type ProjectCardAggregateResult {
  count: Int
  posMin: Int
  posMax: Int
  posSum: Int
  posAvg: Float
}

input ProjectCardFilter {
  id: [ID!]
  has: [ProjectCardHasFilter]
  and: [ProjectCardFilter]
  or: [ProjectCardFilter]
  not: ProjectCardFilter
}

enum ProjectCardHasFilter {
  pos
  card
  pc
  values
}

input ProjectCardOrder {
  asc: ProjectCardOrderable
  desc: ProjectCardOrderable
  then: ProjectCardOrder
}

enum ProjectCardOrderable {
  pos
}

input ProjectCardPatch {
  pos: Int
  card: CardKindRef @x_alter(r:"ref")
  pc: ProjectColumnRef @x_alter(r:"ref")
  values: [ProjectFieldValueRef!] @x_patch_ro
}

input ProjectCardRef {
  id: ID
  pos: Int
  card: CardKindRef @x_alter(r:"ref")
  pc: ProjectColumnRef @x_alter(r:"ref")
  values: [ProjectFieldValueRef!]
}

type ProjectColumnAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
  descriptionMin: String
  descriptionMax: String
  colorMin: String
  colorMax: String
  posMin: Int
  posMax: Int
  posSum: Int
  posAvg: Float
}

input ProjectColumnFilter {
  id: [ID!]
  has: [ProjectColumnHasFilter]
  and: [ProjectColumnFilter]
  or: [ProjectColumnFilter]
  not: ProjectColumnFilter
}

enum ProjectColumnHasFilter {
  name
  description
  color
  pos
  col_type
  cards
  project
  tensions
}

input ProjectColumnOrder {
  asc: ProjectColumnOrderable
  desc: ProjectColumnOrderable
  then: ProjectColumnOrder
}

enum ProjectColumnOrderable {
  name
  description
  color
  pos
}

input ProjectColumnPatch {
  name: String
  description: String @x_alter(r:"maxLen", n:280)
  color: String
  pos: Int
  col_type: ProjectColumnType
  cards: [ProjectCardRef!] @x_patch_ro
  project: ProjectRef @x_alter(r:"ref")
  tensions: [TensionRef!] @x_patch_ro
}

input ProjectColumnRef {
  id: ID
  name: String
  description: String @x_alter(r:"maxLen", n:280)
  color: String
  pos: Int
  col_type: ProjectColumnType
  cards: [ProjectCardRef!]
  project: ProjectRef @x_alter(r:"ref")
  tensions: [TensionRef!]
}

type ProjectDraftAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  messageMin: String
  messageMax: String
  titleMin: String
  titleMax: String
}

input ProjectDraftFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  has: [ProjectDraftHasFilter]
  and: [ProjectDraftFilter]
  or: [ProjectDraftFilter]
  not: ProjectDraftFilter
}

enum ProjectDraftHasFilter {
  createdBy
  createdAt
  updatedAt
  message
  title
}

input ProjectDraftOrder {
  asc: ProjectDraftOrderable
  desc: ProjectDraftOrderable
  then: ProjectDraftOrder
}

enum ProjectDraftOrderable {
  createdAt
  updatedAt
  message
  title
}

input ProjectDraftPatch {
  createdBy: UserRef @x_patch_ro
  createdAt: DateTime @x_patch_ro
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String
  title: String
}

input ProjectDraftRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime @w_add(a:"now")
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String
  title: String
}

type ProjectFieldAggregateResult {
  count: Int
}

input ProjectFieldFilter {
  has: [ProjectFieldHasFilter]
  and: [ProjectFieldFilter]
  or: [ProjectFieldFilter]
  not: ProjectFieldFilter
}

enum ProjectFieldHasFilter {
  field_type
  isVisible
  values
}

input ProjectFieldPatch {
  field_type: ProjectFieldType @x_patch_ro
  isVisible: Boolean @x_patch_ro
  values: [ProjectFieldValueRef!] @x_patch_ro
}

input ProjectFieldRef {
  field_type: ProjectFieldType
  isVisible: Boolean
  values: [ProjectFieldValueRef!]
}

type ProjectFieldValueAggregateResult {
  count: Int
  valueMin: String
  valueMax: String
  posMin: Int
  posMax: Int
  posSum: Int
  posAvg: Float
}

input ProjectFieldValueFilter {
  has: [ProjectFieldValueHasFilter]
  and: [ProjectFieldValueFilter]
  or: [ProjectFieldValueFilter]
  not: ProjectFieldValueFilter
}

enum ProjectFieldValueHasFilter {
  field
  value
  pos
}

input ProjectFieldValueOrder {
  asc: ProjectFieldValueOrderable
  desc: ProjectFieldValueOrderable
  then: ProjectFieldValueOrder
}

enum ProjectFieldValueOrderable {
  value
  pos
}

input ProjectFieldValuePatch {
  field: ProjectFieldRef @x_patch_ro
  value: String @x_patch_ro
  pos: Int @x_patch_ro
}

input ProjectFieldValueRef {
  field: ProjectFieldRef
  value: String
  pos: Int
}

input ProjectFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  rootnameid: StringHashFilter
  parentnameid: StringHashFilter
  nameid: StringHashFilter @w_alter(a:"lower")
  name: StringFullTextFilter
  status: ProjectStatus_hash
  has: [ProjectHasFilter]
  and: [ProjectFilter]
  or: [ProjectFilter]
  not: ProjectFilter
}

enum ProjectHasFilter {
  createdBy
  createdAt
  updatedAt
  rootnameid
  parentnameid
  nameid
  name
  description
  status
  columns
  fields
  leaders
  nodes
}

input ProjectOrder {
  asc: ProjectOrderable
  desc: ProjectOrderable
  then: ProjectOrder
}

enum ProjectOrderable {
  createdAt
  updatedAt
  rootnameid
  parentnameid
  nameid
  name
  description
}

input ProjectPatch {
  createdBy: UserRef @x_patch_ro
  createdAt: DateTime @x_patch_ro
  updatedAt: DateTime @x_patch_ro
  rootnameid: String @x_patch_ro
  parentnameid: String @x_patch_ro
  nameid: String @w_alter(a:"lower") @x_alter(r:"unique", f:"parentnameid") @x_alter(r:"minLen", n:1)
  name: String @x_alter(r:"minLen", n:1) @x_alter(r:"maxLen", n:100)
  description: String @x_alter(r:"maxLen", n:280)
  status: ProjectStatus
  columns: [ProjectColumnRef!]
  fields: [ProjectFieldRef!] @x_patch_ro
  leaders: [NodeRef!] @x_alter(r:"ref")
  nodes: [NodeRef!] @x_alter(r:"oneByOne") @x_alter(r:"ref")
}

input ProjectRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime
  updatedAt: DateTime
  rootnameid: String
  parentnameid: String
  nameid: String @w_alter(a:"lower") @x_alter(r:"unique", f:"parentnameid") @x_alter(r:"minLen", n:1)
  name: String @x_alter(r:"minLen", n:1) @x_alter(r:"maxLen", n:100)
  description: String @x_alter(r:"maxLen", n:280)
  status: ProjectStatus
  columns: [ProjectColumnRef!]
  fields: [ProjectFieldRef!]
  leaders: [NodeRef!] @x_alter(r:"ref")
  nodes: [NodeRef!] @x_alter(r:"oneByOne") @x_alter(r:"ref")
}

input ProjectStatus_hash {
  eq: ProjectStatus
  in: [ProjectStatus]
}

type Query {
  getNode(id: ID, nameid: String): Node
  queryNode(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node]
  aggregateNode(filter: NodeFilter): NodeAggregateResult
  getNodeFragment(id: ID!): NodeFragment
  queryNodeFragment(filter: NodeFragmentFilter, order: NodeFragmentOrder, first: Int, offset: Int): [NodeFragment]
  aggregateNodeFragment(filter: NodeFragmentFilter): NodeFragmentAggregateResult
  getMandate(id: ID!): Mandate
  queryMandate(filter: MandateFilter, order: MandateOrder, first: Int, offset: Int): [Mandate]
  aggregateMandate(filter: MandateFilter): MandateAggregateResult
  getLabel(id: ID!): Label
  queryLabel(filter: LabelFilter @hook_queryLabelInput, order: LabelOrder, first: Int, offset: Int): [Label]
  aggregateLabel(filter: LabelFilter): LabelAggregateResult
  getRoleExt(id: ID!): RoleExt
  queryRoleExt(filter: RoleExtFilter @hook_queryRoleExtInput, order: RoleExtOrder, first: Int, offset: Int): [RoleExt]
  aggregateRoleExt(filter: RoleExtFilter): RoleExtAggregateResult
  getProject(id: ID!): Project
  queryProject(filter: ProjectFilter @hook_queryProjectInput, order: ProjectOrder, first: Int, offset: Int): [Project]
  aggregateProject(filter: ProjectFilter): ProjectAggregateResult
  getProjectColumn(id: ID!): ProjectColumn
  queryProjectColumn(filter: ProjectColumnFilter, order: ProjectColumnOrder, first: Int, offset: Int): [ProjectColumn]
  aggregateProjectColumn(filter: ProjectColumnFilter): ProjectColumnAggregateResult
  getProjectCard(id: ID!): ProjectCard
  queryProjectCard(filter: ProjectCardFilter, order: ProjectCardOrder, first: Int, offset: Int): [ProjectCard]
  aggregateProjectCard(filter: ProjectCardFilter): ProjectCardAggregateResult
  queryProjectField(filter: ProjectFieldFilter, first: Int, offset: Int): [ProjectField]
  aggregateProjectField(filter: ProjectFieldFilter): ProjectFieldAggregateResult
  queryProjectFieldValue(filter: ProjectFieldValueFilter, order: ProjectFieldValueOrder, first: Int, offset: Int): [ProjectFieldValue]
  aggregateProjectFieldValue(filter: ProjectFieldValueFilter): ProjectFieldValueAggregateResult
  getPost(id: ID!): Post
  queryPost(filter: PostFilter, order: PostOrder, first: Int, offset: Int): [Post]
  aggregatePost(filter: PostFilter): PostAggregateResult
  getProjectDraft(id: ID!): ProjectDraft
  queryProjectDraft(filter: ProjectDraftFilter, order: ProjectDraftOrder, first: Int, offset: Int): [ProjectDraft]
  aggregateProjectDraft(filter: ProjectDraftFilter): ProjectDraftAggregateResult
  getTension(id: ID!): Tension
  queryTension(filter: TensionFilter @hook_queryTensionInput, order: TensionOrder, first: Int, offset: Int): [Tension]
  aggregateTension(filter: TensionFilter): TensionAggregateResult
  getComment(id: ID!): Comment
  queryComment(filter: CommentFilter @hook_queryCommentInput, order: CommentOrder, first: Int, offset: Int): [Comment]
  aggregateComment(filter: CommentFilter): CommentAggregateResult
  getReaction(id: ID, reactionid: String): Reaction
  queryReaction(filter: ReactionFilter @hook_queryReactionInput, order: ReactionOrder, first: Int, offset: Int): [Reaction]
  aggregateReaction(filter: ReactionFilter): ReactionAggregateResult
  getBlob(id: ID!): Blob
  queryBlob(filter: BlobFilter, order: BlobOrder, first: Int, offset: Int): [Blob]
  aggregateBlob(filter: BlobFilter): BlobAggregateResult
  getEvent(id: ID!): Event
  queryEvent(filter: EventFilter, order: EventOrder, first: Int, offset: Int): [Event]
  aggregateEvent(filter: EventFilter): EventAggregateResult
  queryEventFragment(filter: EventFragmentFilter, order: EventFragmentOrder, first: Int, offset: Int): [EventFragment]
  aggregateEventFragment(filter: EventFragmentFilter): EventFragmentAggregateResult
  getContract(id: ID, contractid: String): Contract
  queryContract(filter: ContractFilter @hook_queryContractInput, order: ContractOrder, first: Int, offset: Int): [Contract]
  aggregateContract(filter: ContractFilter): ContractAggregateResult
  getVote(id: ID, voteid: String): Vote
  queryVote(filter: VoteFilter @hook_queryVoteInput, order: VoteOrder, first: Int, offset: Int): [Vote]
  aggregateVote(filter: VoteFilter): VoteAggregateResult
  getUser(id: ID, username: String, email: String): User
  queryUser(filter: UserFilter @hook_queryUserInput, order: UserOrder, first: Int, offset: Int): [User]
  aggregateUser(filter: UserFilter): UserAggregateResult
  getPendingUser(id: ID, username: String, email: String): PendingUser
  queryPendingUser(filter: PendingUserFilter, order: PendingUserOrder, first: Int, offset: Int): [PendingUser]
  aggregatePendingUser(filter: PendingUserFilter): PendingUserAggregateResult
  queryUserRights(filter: UserRightsFilter, order: UserRightsOrder, first: Int, offset: Int): [UserRights]
  aggregateUserRights(filter: UserRightsFilter): UserRightsAggregateResult
  getUserEvent(id: ID!): UserEvent
  queryUserEvent(filter: UserEventFilter, order: UserEventOrder, first: Int, offset: Int): [UserEvent]
  aggregateUserEvent(filter: UserEventFilter): UserEventAggregateResult
  getNotif(id: ID!): Notif
  queryNotif(filter: NotifFilter, order: NotifOrder, first: Int, offset: Int): [Notif]
  aggregateNotif(filter: NotifFilter): NotifAggregateResult
  queryEventCount(filter: EventCountFilter, order: EventCountOrder, first: Int, offset: Int): [EventCount]
  aggregateEventCount(filter: EventCountFilter): EventCountAggregateResult
}

type ReactionAggregateResult {
  count: Int
  reactionidMin: String
  reactionidMax: String
  type_Min: Int
  type_Max: Int
  type_Sum: Int
  type_Avg: Float
}

input ReactionFilter {
  id: [ID!]
  reactionid: StringHashFilter
  has: [ReactionHasFilter]
  and: [ReactionFilter]
  or: [ReactionFilter]
  not: ReactionFilter
}

enum ReactionHasFilter {
  reactionid
  user
  comment
  type_
}

input ReactionOrder {
  asc: ReactionOrderable
  desc: ReactionOrderable
  then: ReactionOrder
}

enum ReactionOrderable {
  reactionid
  type_
}

input ReactionPatch {
  user: UserRef @x_patch_ro
  comment: CommentRef @x_patch_ro
  type_: Int @x_patch_ro
}

input ReactionRef {
  id: ID
  reactionid: String
  user: UserRef @x_add(r:"ref")
  comment: CommentRef @x_add(r:"ref")
  type_: Int
}

type RoleExtAggregateResult {
  count: Int
  rootnameidMin: String
  rootnameidMax: String
  nameMin: String
  nameMax: String
  aboutMin: String
  aboutMax: String
  colorMin: String
  colorMax: String
}

input RoleExtFilter {
  id: [ID!]
  rootnameid: StringHashFilter
  name: StringHashFilter_StringTermFilter @w_alter(a:"lower")
  has: [RoleExtHasFilter]
  and: [RoleExtFilter]
  or: [RoleExtFilter]
  not: RoleExtFilter
}

enum RoleExtHasFilter {
  rootnameid
  name
  about
  role_type
  color
  mandate
  roles
  nodes
}

input RoleExtOrder {
  asc: RoleExtOrderable
  desc: RoleExtOrderable
  then: RoleExtOrder
}

enum RoleExtOrderable {
  rootnameid
  name
  about
  color
}

input RoleExtPatch {
  rootnameid: String @x_patch_ro
  name: String @w_alter(a:"lower") @x_alter(r:"unique", f:"rootnameid") @x_alter(r:"minLen", n:1)
  about: String @x_alter(r:"maxLen", n:280)
  role_type: RoleType
  color: String
  mandate: MandateRef
  roles: [NodeRef!] @x_ro
  nodes: [NodeRef!] @x_alter(r:"oneByOne") @x_alter(r:"ref")
}

input RoleExtRef {
  id: ID
  rootnameid: String
  name: String @w_alter(a:"lower") @x_alter(r:"unique", f:"rootnameid") @x_alter(r:"minLen", n:1)
  about: String @x_alter(r:"maxLen", n:280)
  role_type: RoleType
  color: String
  mandate: MandateRef
  roles: [NodeRef!] @x_ro
  nodes: [NodeRef!] @x_alter(r:"oneByOne") @x_alter(r:"ref")
}

input RoleType_hash {
  eq: RoleType
  in: [RoleType]
}

input StringExactFilter {
  eq: String
  in: [String]
  le: String
  lt: String
  ge: String
  gt: String
  between: StringRange
}

input StringFullTextFilter {
  alloftext: String
  anyoftext: String
}

input StringHashFilter {
  eq: String
  in: [String]
}

input StringHashFilter_StringRegExpFilter {
  eq: String
  in: [String]
  regexp: String
}

input StringHashFilter_StringTermFilter {
  eq: String
  in: [String]
  allofterms: String
  anyofterms: String
}

input StringRange {
  min: String!
  max: String!
}

input StringRegExpFilter {
  regexp: String
}

input StringTermFilter {
  allofterms: String
  anyofterms: String
}

type TensionAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  messageMin: String
  messageMax: String
  emitteridMin: String
  emitteridMax: String
  receiveridMin: String
  receiveridMax: String
  titleMin: String
  titleMax: String
  n_commentsMin: Int
  n_commentsMax: Int
  n_commentsSum: Int
  n_commentsAvg: Float
}

input TensionEvent_hash {
  eq: TensionEvent
  in: [TensionEvent]
}

input TensionFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  emitterid: StringHashFilter_StringRegExpFilter
  receiverid: StringHashFilter_StringRegExpFilter
  title: StringFullTextFilter
  type_: TensionType_hash
  status: TensionStatus_hash
  has: [TensionHasFilter]
  and: [TensionFilter]
  or: [TensionFilter]
  not: TensionFilter
}

enum TensionHasFilter {
  createdBy
  createdAt
  updatedAt
  message
  emitter
  emitterid
  receiver
  receiverid
  title
  type_
  status
  action
  assignees
  labels
  comments
  blobs
  history
  mentions
  contracts
  subscribers
  project_statuses
  n_comments
}

input TensionOrder {
  asc: TensionOrderable
  desc: TensionOrderable
  then: TensionOrder
}

enum TensionOrderable {
  createdAt
  updatedAt
  message
  emitterid
  receiverid
  title
  n_comments
}

input TensionPatch {
  createdBy: UserRef @x_patch_ro
  createdAt: DateTime @x_patch_ro
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_alter(r:"isOwner", f:"createdBy")
  emitter: NodeRef @x_patch_ro
  emitterid: String @x_patch_ro
  receiver: NodeRef @x_patch_ro
  receiverid: String @x_patch_ro
  title: String @x_patch_ro
  type_: TensionType @x_alter(r:"tensionTypeCheck")
  status: TensionStatus @x_patch_ro
  action: TensionAction @x_patch_ro
  assignees: [UserRef!] @x_alter(r:"hasEvent", e:[AssigneeAdded, AssigneeRemoved]) @x_alter(r:"ref")
  labels: [LabelRef!] @x_alter(r:"hasEvent", e:[LabelAdded, LabelRemoved]) @x_alter(r:"ref")
  comments: [CommentRef!] @x_alter(r:"hasEvent", e:[Created, CommentPushed]) @x_alter(r:"oneByOne")
  blobs: [BlobRef!] @x_alter(r:"hasEvent", e:[BlobCreated, BlobCommitted]) @x_alter(r:"oneByOne")
  history: [EventRef!]
  mentions: [EventRef!] @x_patch_ro
  contracts: [ContractRef!] @x_patch_ro
  subscribers: [UserRef!] @x_patch_ro
  project_statuses: [ProjectColumnRef!] @x_patch_ro
  n_comments: Int @x_patch_ro
}

input TensionRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime @w_add(a:"now")
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_alter(r:"isOwner", f:"createdBy")
  emitter: NodeRef
  emitterid: String
  receiver: NodeRef
  receiverid: String
  title: String
  type_: TensionType @x_alter(r:"tensionTypeCheck")
  status: TensionStatus
  action: TensionAction
  assignees: [UserRef!] @x_alter(r:"hasEvent", e:[AssigneeAdded, AssigneeRemoved]) @x_alter(r:"ref")
  labels: [LabelRef!] @x_alter(r:"hasEvent", e:[LabelAdded, LabelRemoved]) @x_alter(r:"ref")
  comments: [CommentRef!] @x_alter(r:"hasEvent", e:[Created, CommentPushed]) @x_alter(r:"oneByOne")
  blobs: [BlobRef!] @x_alter(r:"hasEvent", e:[BlobCreated, BlobCommitted]) @x_alter(r:"oneByOne")
  history: [EventRef!]
  mentions: [EventRef!]
  contracts: [ContractRef!] @x_add(r:"ref")
  subscribers: [UserRef!] @x_add(r:"ref")
  project_statuses: [ProjectColumnRef!]
  n_comments: Int
}

input TensionStatus_hash {
  eq: TensionStatus
  in: [TensionStatus]
}

input TensionType_hash {
  eq: TensionType
  in: [TensionType]
}

input UpdateBlobInput {
  filter: BlobFilter!
  set: BlobPatch
  remove: BlobPatch
}

type UpdateBlobPayload {
  blob(filter: BlobFilter, order: BlobOrder, first: Int, offset: Int): [Blob]
  numUids: Int
}

input UpdateCommentInput {
  filter: CommentFilter!
  set: CommentPatch
  remove: CommentPatch
}

type UpdateCommentPayload {
  comment(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment]
  numUids: Int
}

input UpdateContractInput {
  filter: ContractFilter!
  set: ContractPatch
  remove: ContractPatch
}

type UpdateContractPayload {
  contract(filter: ContractFilter, order: ContractOrder, first: Int, offset: Int): [Contract]
  numUids: Int
}

input UpdateEventCountInput {
  filter: EventCountFilter!
  set: EventCountPatch
  remove: EventCountPatch
}

type UpdateEventCountPayload {
  eventCount(filter: EventCountFilter, order: EventCountOrder, first: Int, offset: Int): [EventCount]
  numUids: Int
}

input UpdateEventFragmentInput {
  filter: EventFragmentFilter!
  set: EventFragmentPatch
  remove: EventFragmentPatch
}

type UpdateEventFragmentPayload {
  eventFragment(filter: EventFragmentFilter, order: EventFragmentOrder, first: Int, offset: Int): [EventFragment]
  numUids: Int
}

input UpdateEventInput {
  filter: EventFilter!
  set: EventPatch
  remove: EventPatch
}

type UpdateEventPayload {
  event(filter: EventFilter, order: EventOrder, first: Int, offset: Int): [Event]
  numUids: Int
}

input UpdateLabelInput {
  filter: LabelFilter!
  set: LabelPatch
  remove: LabelPatch
}

type UpdateLabelPayload {
  label(filter: LabelFilter, order: LabelOrder, first: Int, offset: Int): [Label]
  numUids: Int
}

input UpdateMandateInput {
  filter: MandateFilter!
  set: MandatePatch
  remove: MandatePatch
}

type UpdateMandatePayload {
  mandate(filter: MandateFilter, order: MandateOrder, first: Int, offset: Int): [Mandate]
  numUids: Int
}

input UpdateNodeFragmentInput {
  filter: NodeFragmentFilter!
  set: NodeFragmentPatch
  remove: NodeFragmentPatch
}

type UpdateNodeFragmentPayload {
  nodeFragment(filter: NodeFragmentFilter, order: NodeFragmentOrder, first: Int, offset: Int): [NodeFragment]
  numUids: Int
}

input UpdateNodeInput {
  filter: NodeFilter!
  set: NodePatch
  remove: NodePatch
}

type UpdateNodePayload {
  node(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node]
  numUids: Int
}

input UpdateNotifInput {
  filter: NotifFilter!
  set: NotifPatch
  remove: NotifPatch
}

type UpdateNotifPayload {
  notif(filter: NotifFilter, order: NotifOrder, first: Int, offset: Int): [Notif]
  numUids: Int
}

input UpdatePendingUserInput {
  filter: PendingUserFilter!
  set: PendingUserPatch
  remove: PendingUserPatch
}

type UpdatePendingUserPayload {
  pendingUser(filter: PendingUserFilter, order: PendingUserOrder, first: Int, offset: Int): [PendingUser]
  numUids: Int
}

input UpdatePostInput {
  filter: PostFilter!
  set: PostPatch
  remove: PostPatch
}

type UpdatePostPayload {
  post(filter: PostFilter, order: PostOrder, first: Int, offset: Int): [Post]
  numUids: Int
}

input UpdateProjectCardInput {
  filter: ProjectCardFilter!
  set: ProjectCardPatch
  remove: ProjectCardPatch
}

type UpdateProjectCardPayload {
  projectCard(filter: ProjectCardFilter, order: ProjectCardOrder, first: Int, offset: Int): [ProjectCard]
  numUids: Int
}

input UpdateProjectColumnInput {
  filter: ProjectColumnFilter!
  set: ProjectColumnPatch
  remove: ProjectColumnPatch
}

type UpdateProjectColumnPayload {
  projectColumn(filter: ProjectColumnFilter, order: ProjectColumnOrder, first: Int, offset: Int): [ProjectColumn]
  numUids: Int
}

input UpdateProjectDraftInput {
  filter: ProjectDraftFilter!
  set: ProjectDraftPatch
  remove: ProjectDraftPatch
}

type UpdateProjectDraftPayload {
  projectDraft(filter: ProjectDraftFilter, order: ProjectDraftOrder, first: Int, offset: Int): [ProjectDraft]
  numUids: Int
}

input UpdateProjectFieldInput {
  filter: ProjectFieldFilter!
  set: ProjectFieldPatch
  remove: ProjectFieldPatch
}

type UpdateProjectFieldPayload {
  projectField(filter: ProjectFieldFilter, first: Int, offset: Int): [ProjectField]
  numUids: Int
}

input UpdateProjectFieldValueInput {
  filter: ProjectFieldValueFilter!
  set: ProjectFieldValuePatch
  remove: ProjectFieldValuePatch
}

type UpdateProjectFieldValuePayload {
  projectFieldValue(filter: ProjectFieldValueFilter, order: ProjectFieldValueOrder, first: Int, offset: Int): [ProjectFieldValue]
  numUids: Int
}

input UpdateProjectInput {
  filter: ProjectFilter!
  set: ProjectPatch
  remove: ProjectPatch
}

type UpdateProjectPayload {
  project(filter: ProjectFilter, order: ProjectOrder, first: Int, offset: Int): [Project]
  numUids: Int
}

input UpdateReactionInput {
  filter: ReactionFilter!
  set: ReactionPatch
  remove: ReactionPatch
}

type UpdateReactionPayload {
  reaction(filter: ReactionFilter, order: ReactionOrder, first: Int, offset: Int): [Reaction]
  numUids: Int
}

input UpdateRoleExtInput {
  filter: RoleExtFilter!
  set: RoleExtPatch
  remove: RoleExtPatch
}

type UpdateRoleExtPayload {
  roleExt(filter: RoleExtFilter, order: RoleExtOrder, first: Int, offset: Int): [RoleExt]
  numUids: Int
}

input UpdateTensionInput {
  filter: TensionFilter!
  set: TensionPatch
  remove: TensionPatch
}

type UpdateTensionPayload {
  tension(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension]
  numUids: Int
}

input UpdateUserEventInput {
  filter: UserEventFilter!
  set: UserEventPatch
  remove: UserEventPatch
}

type UpdateUserEventPayload {
  userEvent(filter: UserEventFilter, order: UserEventOrder, first: Int, offset: Int): [UserEvent]
  numUids: Int
}

input UpdateUserInput {
  filter: UserFilter!
  set: UserPatch
  remove: UserPatch
}

type UpdateUserPayload {
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  numUids: Int
}

input UpdateUserRightsInput {
  filter: UserRightsFilter!
  set: UserRightsPatch
  remove: UserRightsPatch
}

type UpdateUserRightsPayload {
  userRights(filter: UserRightsFilter, order: UserRightsOrder, first: Int, offset: Int): [UserRights]
  numUids: Int
}

input UpdateVoteInput {
  filter: VoteFilter!
  set: VotePatch
  remove: VotePatch
}

type UpdateVotePayload {
  vote(filter: VoteFilter, order: VoteOrder, first: Int, offset: Int): [Vote]
  numUids: Int
}

type UserAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  lastAckMin: DateTime
  lastAckMax: DateTime
  usernameMin: String
  usernameMax: String
  nameMin: String
  nameMax: String
  emailMin: String
  emailMax: String
  passwordMin: String
  passwordMax: String
  bioMin: String
  bioMax: String
  locationMin: String
  locationMax: String
  utcMin: String
  utcMax: String
  markAllAsReadMin: String
  markAllAsReadMax: String
}

type UserEventAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
}

input UserEventFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  isRead: Boolean
  has: [UserEventHasFilter]
  and: [UserEventFilter]
  or: [UserEventFilter]
  not: UserEventFilter
}

enum UserEventHasFilter {
  createdAt
  isRead
  user
  event
}

input UserEventOrder {
  asc: UserEventOrderable
  desc: UserEventOrderable
  then: UserEventOrder
}

enum UserEventOrderable {
  createdAt
}

input UserEventPatch {
  createdAt: DateTime @x_patch_ro
  isRead: Boolean
  user: UserRef @x_patch_ro
  event: [EventKindRef!] @x_patch_ro
}

input UserEventRef {
  id: ID
  createdAt: DateTime
  isRead: Boolean
  user: UserRef
  event: [EventKindRef!] @x_add(r:"ref")
}

input UserFilter {
  id: [ID!]
  username: StringHashFilter_StringRegExpFilter
  name: StringRegExpFilter
  email: StringHashFilter
  has: [UserHasFilter]
  and: [UserFilter]
  or: [UserFilter]
  not: UserFilter
}

enum UserHasFilter {
  createdAt
  lastAck
  username
  name
  email
  password
  bio
  location
  utc
  links
  skills
  notifyByEmail
  lang
  subscriptions
  watching
  rights
  roles
  tensions_created
  tensions_assigned
  contracts
  reactions
  events
  markAllAsRead
  event_count
}

input UserOrder {
  asc: UserOrderable
  desc: UserOrderable
  then: UserOrder
}

enum UserOrderable {
  createdAt
  lastAck
  username
  name
  email
  password
  bio
  location
  utc
  markAllAsRead
}

input UserPatch {
  createdAt: DateTime @x_patch_ro
  lastAck: DateTime @x_patch_ro
  name: String @x_patch
  password: String @x_patch_ro
  bio: String @x_patch @x_alter(r:"maxLen", n:280)
  location: String @x_patch
  utc: String @x_patch
  links: [String!] @x_patch
  skills: [String!] @x_patch
  notifyByEmail: Boolean @x_patch
  lang: Lang @x_patch
  subscriptions: [TensionRef!] @x_patch @x_alter(r:"ref")
  watching: [NodeRef!] @x_patch @x_alter(r:"ref")
  rights: UserRightsRef @x_patch_ro
  roles: [NodeRef!] @x_patch_ro
  tensions_created: [TensionRef!] @x_patch_ro
  tensions_assigned: [TensionRef!] @x_patch_ro
  contracts: [ContractRef!] @x_patch_ro
  reactions: [ReactionRef!]
  events: [UserEventRef!]
  markAllAsRead: String @w_meta_patch(f:"markAllAsRead", k:"username")
  event_count: EventCountRef @x_patch_ro
}

input UserRef {
  id: ID
  createdAt: DateTime
  lastAck: DateTime
  username: String @w_add(a:"lower")
  name: String @x_patch
  email: String @w_add(a:"lower")
  password: String
  bio: String @x_patch @x_alter(r:"maxLen", n:280)
  location: String @x_patch
  utc: String @x_patch
  links: [String!] @x_patch
  skills: [String!] @x_patch
  notifyByEmail: Boolean @x_patch
  lang: Lang @x_patch
  subscriptions: [TensionRef!] @x_patch @x_alter(r:"ref")
  watching: [NodeRef!] @x_patch @x_alter(r:"ref")
  rights: UserRightsRef
  roles: [NodeRef!] @x_add(r:"ref")
  tensions_created: [TensionRef!] @x_add(r:"ref")
  tensions_assigned: [TensionRef!] @x_add(r:"ref")
  contracts: [ContractRef!] @x_add(r:"ref")
  reactions: [ReactionRef!]
  events: [UserEventRef!]
  markAllAsRead: String @w_meta_patch(f:"markAllAsRead", k:"username")
  event_count: EventCountRef
}

type UserRightsAggregateResult {
  count: Int
  maxPublicOrgaMin: Int
  maxPublicOrgaMax: Int
  maxPublicOrgaSum: Int
  maxPublicOrgaAvg: Float
  maxPrivateOrgaMin: Int
  maxPrivateOrgaMax: Int
  maxPrivateOrgaSum: Int
  maxPrivateOrgaAvg: Float
}

input UserRightsFilter {
  has: [UserRightsHasFilter]
  and: [UserRightsFilter]
  or: [UserRightsFilter]
  not: UserRightsFilter
}

enum UserRightsHasFilter {
  type_
  canLogin
  canCreateRoot
  maxPublicOrga
  maxPrivateOrga
  hasEmailNotifications
}

input UserRightsOrder {
  asc: UserRightsOrderable
  desc: UserRightsOrderable
  then: UserRightsOrder
}

enum UserRightsOrderable {
  maxPublicOrga
  maxPrivateOrga
}

input UserRightsPatch {
  type_: UserType @x_patch_ro
  canLogin: Boolean @x_patch_ro
  canCreateRoot: Boolean @x_patch_ro
  maxPublicOrga: Int @x_patch_ro
  maxPrivateOrga: Int @x_patch_ro
  hasEmailNotifications: Boolean @x_patch_ro
}

input UserRightsRef {
  type_: UserType
  canLogin: Boolean
  canCreateRoot: Boolean
  maxPublicOrga: Int
  maxPrivateOrga: Int
  hasEmailNotifications: Boolean
}

type VoteAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  messageMin: String
  messageMax: String
  voteidMin: String
  voteidMax: String
}

input VoteFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  voteid: StringHashFilter
  has: [VoteHasFilter]
  and: [VoteFilter]
  or: [VoteFilter]
  not: VoteFilter
}

enum VoteHasFilter {
  createdBy
  createdAt
  updatedAt
  message
  voteid
  contract
  node
  data
}

input VoteOrder {
  asc: VoteOrderable
  desc: VoteOrderable
  then: VoteOrder
}

enum VoteOrderable {
  createdAt
  updatedAt
  message
  voteid
}

input VotePatch {
  createdBy: UserRef @x_patch_ro
  createdAt: DateTime @x_patch_ro
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_alter(r:"isOwner", f:"createdBy")
  contract: ContractRef @x_patch_ro
  node: NodeRef @x_patch_ro
  data: [Int!] @x_patch_ro
}

input VoteRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime @w_add(a:"now")
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_alter(r:"isOwner", f:"createdBy")
  voteid: String
  contract: ContractRef @x_add(r:"ref")
  node: NodeRef @x_add(r:"ref")
  data: [Int!]
}

input WithinFilter {
  polygon: PolygonRef!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
