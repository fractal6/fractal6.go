// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fractale/fractal6.go/graph/model"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
	Auth                     func(ctx context.Context, obj interface{}, next graphql.Resolver, password *model.AuthRule, query *model.AuthRule, add *model.AuthRule, update *model.AuthRule, delete *model.AuthRule) (res interface{}, err error)
	CacheControl             func(ctx context.Context, obj interface{}, next graphql.Resolver, maxAge int) (res interface{}, err error)
	Cascade                  func(ctx context.Context, obj interface{}, next graphql.Resolver, fields []*string) (res interface{}, err error)
	Custom                   func(ctx context.Context, obj interface{}, next graphql.Resolver, http *model.CustomHTTP, dql *string) (res interface{}, err error)
	Default                  func(ctx context.Context, obj interface{}, next graphql.Resolver, add *model.DgraphDefault, update *model.DgraphDefault) (res interface{}, err error)
	Dgraph                   func(ctx context.Context, obj interface{}, next graphql.Resolver, typeArg *string, pred *string) (res interface{}, err error)
	Generate                 func(ctx context.Context, obj interface{}, next graphql.Resolver, query *model.GenerateQueryParams, mutation *model.GenerateMutationParams, subscription *bool) (res interface{}, err error)
	HasInverse               func(ctx context.Context, obj interface{}, next graphql.Resolver, field string) (res interface{}, err error)
	Hidden                   func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addComment          func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addCommentInput     func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addContract         func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addContractInput    func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addLabel            func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addLabelInput       func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addReaction         func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addReactionInput    func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addRoleExt          func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addRoleExtInput     func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addTension          func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addTensionInput     func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addUser             func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addUserInput        func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addVote             func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_addVoteInput        func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteComment       func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteCommentInput  func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteContract      func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteContractInput func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteLabel         func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteLabelInput    func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteReaction      func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteReactionInput func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteRoleExt       func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteRoleExtInput  func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteTension       func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteTensionInput  func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteUser          func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteUserInput     func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteVote          func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_deleteVoteInput     func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_getCommentInput     func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_getContractInput    func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_getLabelInput       func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_getReactionInput    func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_getRoleExtInput     func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_getTensionInput     func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_getUserInput        func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_getVoteInput        func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_queryCommentInput   func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_queryContractInput  func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_queryLabelInput     func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_queryReactionInput  func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_queryRoleExtInput   func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_queryTensionInput   func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_queryUserInput      func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_queryVoteInput      func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateComment       func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateCommentInput  func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateContract      func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateContractInput func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateLabel         func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateLabelInput    func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateReaction      func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateReactionInput func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateRoleExt       func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateRoleExtInput  func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateTension       func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateTensionInput  func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateUser          func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateUserInput     func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateVote          func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Hook_updateVoteInput     func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Id                       func(ctx context.Context, obj interface{}, next graphql.Resolver, interfaceArg *bool) (res interface{}, err error)
	IsContractValidator      func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Lambda                   func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	LambdaOnMutate           func(ctx context.Context, obj interface{}, next graphql.Resolver, add *bool, update *bool, delete *bool) (res interface{}, err error)
	Meta                     func(ctx context.Context, obj interface{}, next graphql.Resolver, f string, k *string) (res interface{}, err error)
	Private                  func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Remote                   func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	RemoteResponse           func(ctx context.Context, obj interface{}, next graphql.Resolver, name *string) (res interface{}, err error)
	Search                   func(ctx context.Context, obj interface{}, next graphql.Resolver, by []model.DgraphIndex) (res interface{}, err error)
	Secret                   func(ctx context.Context, obj interface{}, next graphql.Resolver, field string, pred *string) (res interface{}, err error)
	W_add                    func(ctx context.Context, obj interface{}, next graphql.Resolver, a string) (res interface{}, err error)
	W_alter                  func(ctx context.Context, obj interface{}, next graphql.Resolver, a string) (res interface{}, err error)
	W_meta_patch             func(ctx context.Context, obj interface{}, next graphql.Resolver, f string, k *string) (res interface{}, err error)
	W_patch                  func(ctx context.Context, obj interface{}, next graphql.Resolver, a string) (res interface{}, err error)
	W_remove                 func(ctx context.Context, obj interface{}, next graphql.Resolver, a string) (res interface{}, err error)
	W_set                    func(ctx context.Context, obj interface{}, next graphql.Resolver, a string) (res interface{}, err error)
	WithSubscription         func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	X_add                    func(ctx context.Context, obj interface{}, next graphql.Resolver, r *string, f *string, e []model.TensionEvent, n *int) (res interface{}, err error)
	X_alter                  func(ctx context.Context, obj interface{}, next graphql.Resolver, r *string, f *string, e []model.TensionEvent, n *int) (res interface{}, err error)
	X_patch                  func(ctx context.Context, obj interface{}, next graphql.Resolver, r *string, f *string, e []model.TensionEvent, n *int) (res interface{}, err error)
	X_patch_ro               func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	X_remove                 func(ctx context.Context, obj interface{}, next graphql.Resolver, r *string, f *string, e []model.TensionEvent, n *int) (res interface{}, err error)
	X_ro                     func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	X_set                    func(ctx context.Context, obj interface{}, next graphql.Resolver, r *string, f *string, e []model.TensionEvent, n *int) (res interface{}, err error)
}

type ComplexityRoot struct {
	AddBlobPayload struct {
		Blob    func(childComplexity int, filter *model.BlobFilter, order *model.BlobOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	AddCommentPayload struct {
		Comment func(childComplexity int, filter *model.CommentFilter, order *model.CommentOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	AddContractPayload struct {
		Contract func(childComplexity int, filter *model.ContractFilter, order *model.ContractOrder, first *int, offset *int) int
		NumUids  func(childComplexity int) int
	}

	AddEventCountPayload struct {
		EventCount func(childComplexity int, filter *model.EventCountFilter, order *model.EventCountOrder, first *int, offset *int) int
		NumUids    func(childComplexity int) int
	}

	AddEventFragmentPayload struct {
		EventFragment func(childComplexity int, filter *model.EventFragmentFilter, order *model.EventFragmentOrder, first *int, offset *int) int
		NumUids       func(childComplexity int) int
	}

	AddEventPayload struct {
		Event   func(childComplexity int, filter *model.EventFilter, order *model.EventOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	AddLabelPayload struct {
		Label   func(childComplexity int, filter *model.LabelFilter, order *model.LabelOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	AddMandatePayload struct {
		Mandate func(childComplexity int, filter *model.MandateFilter, order *model.MandateOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	AddNodeFragmentPayload struct {
		NodeFragment func(childComplexity int, filter *model.NodeFragmentFilter, order *model.NodeFragmentOrder, first *int, offset *int) int
		NumUids      func(childComplexity int) int
	}

	AddNodePayload struct {
		Node    func(childComplexity int, filter *model.NodeFilter, order *model.NodeOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	AddNotifPayload struct {
		Notif   func(childComplexity int, filter *model.NotifFilter, order *model.NotifOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	AddOrgaAggPayload struct {
		NumUids func(childComplexity int) int
		OrgaAgg func(childComplexity int, filter *model.OrgaAggFilter, order *model.OrgaAggOrder, first *int, offset *int) int
	}

	AddPendingUserPayload struct {
		NumUids     func(childComplexity int) int
		PendingUser func(childComplexity int, filter *model.PendingUserFilter, order *model.PendingUserOrder, first *int, offset *int) int
	}

	AddReactionPayload struct {
		NumUids  func(childComplexity int) int
		Reaction func(childComplexity int, filter *model.ReactionFilter, order *model.ReactionOrder, first *int, offset *int) int
	}

	AddRoleExtPayload struct {
		NumUids func(childComplexity int) int
		RoleExt func(childComplexity int, filter *model.RoleExtFilter, order *model.RoleExtOrder, first *int, offset *int) int
	}

	AddTensionPayload struct {
		NumUids func(childComplexity int) int
		Tension func(childComplexity int, filter *model.TensionFilter, order *model.TensionOrder, first *int, offset *int) int
	}

	AddUserEventPayload struct {
		NumUids   func(childComplexity int) int
		UserEvent func(childComplexity int, filter *model.UserEventFilter, order *model.UserEventOrder, first *int, offset *int) int
	}

	AddUserPayload struct {
		NumUids func(childComplexity int) int
		User    func(childComplexity int, filter *model.UserFilter, order *model.UserOrder, first *int, offset *int) int
	}

	AddUserRightsPayload struct {
		NumUids    func(childComplexity int) int
		UserRights func(childComplexity int, filter *model.UserRightsFilter, order *model.UserRightsOrder, first *int, offset *int) int
	}

	AddVotePayload struct {
		NumUids func(childComplexity int) int
		Vote    func(childComplexity int, filter *model.VoteFilter, order *model.VoteOrder, first *int, offset *int) int
	}

	Blob struct {
		ArchivedFlag func(childComplexity int) int
		BlobType     func(childComplexity int) int
		CreatedAt    func(childComplexity int) int
		CreatedBy    func(childComplexity int, filter *model.UserFilter) int
		ID           func(childComplexity int) int
		Md           func(childComplexity int) int
		Message      func(childComplexity int) int
		Node         func(childComplexity int, filter *model.NodeFragmentFilter) int
		PushedFlag   func(childComplexity int) int
		Tension      func(childComplexity int, filter *model.TensionFilter) int
		UpdatedAt    func(childComplexity int) int
	}

	BlobAggregateResult struct {
		ArchivedFlagMax func(childComplexity int) int
		ArchivedFlagMin func(childComplexity int) int
		Count           func(childComplexity int) int
		CreatedAtMax    func(childComplexity int) int
		CreatedAtMin    func(childComplexity int) int
		MdMax           func(childComplexity int) int
		MdMin           func(childComplexity int) int
		MessageMax      func(childComplexity int) int
		MessageMin      func(childComplexity int) int
		PushedFlagMax   func(childComplexity int) int
		PushedFlagMin   func(childComplexity int) int
		UpdatedAtMax    func(childComplexity int) int
		UpdatedAtMin    func(childComplexity int) int
	}

	Comment struct {
		CreatedAt          func(childComplexity int) int
		CreatedBy          func(childComplexity int, filter *model.UserFilter) int
		ID                 func(childComplexity int) int
		Message            func(childComplexity int) int
		Reactions          func(childComplexity int, filter *model.ReactionFilter, order *model.ReactionOrder, first *int, offset *int) int
		ReactionsAggregate func(childComplexity int, filter *model.ReactionFilter) int
		UpdatedAt          func(childComplexity int) int
	}

	CommentAggregateResult struct {
		Count        func(childComplexity int) int
		CreatedAtMax func(childComplexity int) int
		CreatedAtMin func(childComplexity int) int
		MessageMax   func(childComplexity int) int
		MessageMin   func(childComplexity int) int
		UpdatedAtMax func(childComplexity int) int
		UpdatedAtMin func(childComplexity int) int
	}

	Contract struct {
		Candidates                 func(childComplexity int, filter *model.UserFilter, order *model.UserOrder, first *int, offset *int) int
		CandidatesAggregate        func(childComplexity int, filter *model.UserFilter) int
		ClosedAt                   func(childComplexity int) int
		Comments                   func(childComplexity int, filter *model.CommentFilter, order *model.CommentOrder, first *int, offset *int) int
		CommentsAggregate          func(childComplexity int, filter *model.CommentFilter) int
		ContractType               func(childComplexity int) int
		Contractid                 func(childComplexity int) int
		CreatedAt                  func(childComplexity int) int
		CreatedBy                  func(childComplexity int, filter *model.UserFilter) int
		Event                      func(childComplexity int, filter *model.EventFragmentFilter) int
		ID                         func(childComplexity int) int
		IsValidator                func(childComplexity int) int
		Message                    func(childComplexity int) int
		Participants               func(childComplexity int, filter *model.VoteFilter, order *model.VoteOrder, first *int, offset *int) int
		ParticipantsAggregate      func(childComplexity int, filter *model.VoteFilter) int
		PendingCandidates          func(childComplexity int, filter *model.PendingUserFilter, order *model.PendingUserOrder, first *int, offset *int) int
		PendingCandidatesAggregate func(childComplexity int, filter *model.PendingUserFilter) int
		Status                     func(childComplexity int) int
		Tension                    func(childComplexity int, filter *model.TensionFilter) int
		UpdatedAt                  func(childComplexity int) int
	}

	ContractAggregateResult struct {
		ClosedAtMax   func(childComplexity int) int
		ClosedAtMin   func(childComplexity int) int
		ContractidMax func(childComplexity int) int
		ContractidMin func(childComplexity int) int
		Count         func(childComplexity int) int
		CreatedAtMax  func(childComplexity int) int
		CreatedAtMin  func(childComplexity int) int
		MessageMax    func(childComplexity int) int
		MessageMin    func(childComplexity int) int
		UpdatedAtMax  func(childComplexity int) int
		UpdatedAtMin  func(childComplexity int) int
	}

	DeleteBlobPayload struct {
		Blob    func(childComplexity int, filter *model.BlobFilter, order *model.BlobOrder, first *int, offset *int) int
		Msg     func(childComplexity int) int
		NumUids func(childComplexity int) int
	}

	DeleteCommentPayload struct {
		Comment func(childComplexity int, filter *model.CommentFilter, order *model.CommentOrder, first *int, offset *int) int
		Msg     func(childComplexity int) int
		NumUids func(childComplexity int) int
	}

	DeleteContractPayload struct {
		Contract func(childComplexity int, filter *model.ContractFilter, order *model.ContractOrder, first *int, offset *int) int
		Msg      func(childComplexity int) int
		NumUids  func(childComplexity int) int
	}

	DeleteEventCountPayload struct {
		EventCount func(childComplexity int, filter *model.EventCountFilter, order *model.EventCountOrder, first *int, offset *int) int
		Msg        func(childComplexity int) int
		NumUids    func(childComplexity int) int
	}

	DeleteEventFragmentPayload struct {
		EventFragment func(childComplexity int, filter *model.EventFragmentFilter, order *model.EventFragmentOrder, first *int, offset *int) int
		Msg           func(childComplexity int) int
		NumUids       func(childComplexity int) int
	}

	DeleteEventPayload struct {
		Event   func(childComplexity int, filter *model.EventFilter, order *model.EventOrder, first *int, offset *int) int
		Msg     func(childComplexity int) int
		NumUids func(childComplexity int) int
	}

	DeleteLabelPayload struct {
		Label   func(childComplexity int, filter *model.LabelFilter, order *model.LabelOrder, first *int, offset *int) int
		Msg     func(childComplexity int) int
		NumUids func(childComplexity int) int
	}

	DeleteMandatePayload struct {
		Mandate func(childComplexity int, filter *model.MandateFilter, order *model.MandateOrder, first *int, offset *int) int
		Msg     func(childComplexity int) int
		NumUids func(childComplexity int) int
	}

	DeleteNodeFragmentPayload struct {
		Msg          func(childComplexity int) int
		NodeFragment func(childComplexity int, filter *model.NodeFragmentFilter, order *model.NodeFragmentOrder, first *int, offset *int) int
		NumUids      func(childComplexity int) int
	}

	DeleteNodePayload struct {
		Msg     func(childComplexity int) int
		Node    func(childComplexity int, filter *model.NodeFilter, order *model.NodeOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	DeleteNotifPayload struct {
		Msg     func(childComplexity int) int
		Notif   func(childComplexity int, filter *model.NotifFilter, order *model.NotifOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	DeleteOrgaAggPayload struct {
		Msg     func(childComplexity int) int
		NumUids func(childComplexity int) int
		OrgaAgg func(childComplexity int, filter *model.OrgaAggFilter, order *model.OrgaAggOrder, first *int, offset *int) int
	}

	DeletePendingUserPayload struct {
		Msg         func(childComplexity int) int
		NumUids     func(childComplexity int) int
		PendingUser func(childComplexity int, filter *model.PendingUserFilter, order *model.PendingUserOrder, first *int, offset *int) int
	}

	DeletePostPayload struct {
		Msg     func(childComplexity int) int
		NumUids func(childComplexity int) int
		Post    func(childComplexity int, filter *model.PostFilter, order *model.PostOrder, first *int, offset *int) int
	}

	DeleteReactionPayload struct {
		Msg      func(childComplexity int) int
		NumUids  func(childComplexity int) int
		Reaction func(childComplexity int, filter *model.ReactionFilter, order *model.ReactionOrder, first *int, offset *int) int
	}

	DeleteRoleExtPayload struct {
		Msg     func(childComplexity int) int
		NumUids func(childComplexity int) int
		RoleExt func(childComplexity int, filter *model.RoleExtFilter, order *model.RoleExtOrder, first *int, offset *int) int
	}

	DeleteTensionPayload struct {
		Msg     func(childComplexity int) int
		NumUids func(childComplexity int) int
		Tension func(childComplexity int, filter *model.TensionFilter, order *model.TensionOrder, first *int, offset *int) int
	}

	DeleteUserEventPayload struct {
		Msg       func(childComplexity int) int
		NumUids   func(childComplexity int) int
		UserEvent func(childComplexity int, filter *model.UserEventFilter, order *model.UserEventOrder, first *int, offset *int) int
	}

	DeleteUserPayload struct {
		Msg     func(childComplexity int) int
		NumUids func(childComplexity int) int
		User    func(childComplexity int, filter *model.UserFilter, order *model.UserOrder, first *int, offset *int) int
	}

	DeleteUserRightsPayload struct {
		Msg        func(childComplexity int) int
		NumUids    func(childComplexity int) int
		UserRights func(childComplexity int, filter *model.UserRightsFilter, order *model.UserRightsOrder, first *int, offset *int) int
	}

	DeleteVotePayload struct {
		Msg     func(childComplexity int) int
		NumUids func(childComplexity int) int
		Vote    func(childComplexity int, filter *model.VoteFilter, order *model.VoteOrder, first *int, offset *int) int
	}

	Event struct {
		CreatedAt func(childComplexity int) int
		CreatedBy func(childComplexity int, filter *model.UserFilter) int
		EventType func(childComplexity int) int
		ID        func(childComplexity int) int
		Mentioned func(childComplexity int, filter *model.TensionFilter) int
		Message   func(childComplexity int) int
		New       func(childComplexity int) int
		Old       func(childComplexity int) int
		Tension   func(childComplexity int, filter *model.TensionFilter) int
		UpdatedAt func(childComplexity int) int
	}

	EventAggregateResult struct {
		Count        func(childComplexity int) int
		CreatedAtMax func(childComplexity int) int
		CreatedAtMin func(childComplexity int) int
		MessageMax   func(childComplexity int) int
		MessageMin   func(childComplexity int) int
		NewMax       func(childComplexity int) int
		NewMin       func(childComplexity int) int
		OldMax       func(childComplexity int) int
		OldMin       func(childComplexity int) int
		UpdatedAtMax func(childComplexity int) int
		UpdatedAtMin func(childComplexity int) int
	}

	EventCount struct {
		AssignedTensions func(childComplexity int) int
		PendingContracts func(childComplexity int) int
		UnreadEvents     func(childComplexity int) int
	}

	EventCountAggregateResult struct {
		AssignedTensionsAvg func(childComplexity int) int
		AssignedTensionsMax func(childComplexity int) int
		AssignedTensionsMin func(childComplexity int) int
		AssignedTensionsSum func(childComplexity int) int
		Count               func(childComplexity int) int
		PendingContractsAvg func(childComplexity int) int
		PendingContractsMax func(childComplexity int) int
		PendingContractsMin func(childComplexity int) int
		PendingContractsSum func(childComplexity int) int
		UnreadEventsAvg     func(childComplexity int) int
		UnreadEventsMax     func(childComplexity int) int
		UnreadEventsMin     func(childComplexity int) int
		UnreadEventsSum     func(childComplexity int) int
	}

	EventFragment struct {
		EventType func(childComplexity int) int
		New       func(childComplexity int) int
		Old       func(childComplexity int) int
	}

	EventFragmentAggregateResult struct {
		Count  func(childComplexity int) int
		NewMax func(childComplexity int) int
		NewMin func(childComplexity int) int
		OldMax func(childComplexity int) int
		OldMin func(childComplexity int) int
	}

	Label struct {
		Color             func(childComplexity int) int
		Description       func(childComplexity int) int
		ID                func(childComplexity int) int
		Name              func(childComplexity int) int
		Nodes             func(childComplexity int, filter *model.NodeFilter, order *model.NodeOrder, first *int, offset *int) int
		NodesAggregate    func(childComplexity int, filter *model.NodeFilter) int
		Rootnameid        func(childComplexity int) int
		Tensions          func(childComplexity int, filter *model.TensionFilter, order *model.TensionOrder, first *int, offset *int) int
		TensionsAggregate func(childComplexity int, filter *model.TensionFilter) int
	}

	LabelAggregateResult struct {
		ColorMax       func(childComplexity int) int
		ColorMin       func(childComplexity int) int
		Count          func(childComplexity int) int
		DescriptionMax func(childComplexity int) int
		DescriptionMin func(childComplexity int) int
		NameMax        func(childComplexity int) int
		NameMin        func(childComplexity int) int
		RootnameidMax  func(childComplexity int) int
		RootnameidMin  func(childComplexity int) int
	}

	Mandate struct {
		Domains          func(childComplexity int) int
		ID               func(childComplexity int) int
		Policies         func(childComplexity int) int
		Purpose          func(childComplexity int) int
		Responsabilities func(childComplexity int) int
	}

	MandateAggregateResult struct {
		Count               func(childComplexity int) int
		DomainsMax          func(childComplexity int) int
		DomainsMin          func(childComplexity int) int
		PoliciesMax         func(childComplexity int) int
		PoliciesMin         func(childComplexity int) int
		PurposeMax          func(childComplexity int) int
		PurposeMin          func(childComplexity int) int
		ResponsabilitiesMax func(childComplexity int) int
		ResponsabilitiesMin func(childComplexity int) int
	}

	MultiPolygon struct {
		Polygons func(childComplexity int) int
	}

	Mutation struct {
		AddBlob             func(childComplexity int, input []*model.AddBlobInput) int
		AddComment          func(childComplexity int, input []*model.AddCommentInput) int
		AddContract         func(childComplexity int, input []*model.AddContractInput, upsert *bool) int
		AddEvent            func(childComplexity int, input []*model.AddEventInput) int
		AddEventCount       func(childComplexity int, input []*model.AddEventCountInput) int
		AddEventFragment    func(childComplexity int, input []*model.AddEventFragmentInput) int
		AddLabel            func(childComplexity int, input []*model.AddLabelInput) int
		AddMandate          func(childComplexity int, input []*model.AddMandateInput) int
		AddNode             func(childComplexity int, input []*model.AddNodeInput, upsert *bool) int
		AddNodeFragment     func(childComplexity int, input []*model.AddNodeFragmentInput) int
		AddNotif            func(childComplexity int, input []*model.AddNotifInput) int
		AddOrgaAgg          func(childComplexity int, input []*model.AddOrgaAggInput) int
		AddPendingUser      func(childComplexity int, input []*model.AddPendingUserInput, upsert *bool) int
		AddReaction         func(childComplexity int, input []*model.AddReactionInput, upsert *bool) int
		AddRoleExt          func(childComplexity int, input []*model.AddRoleExtInput) int
		AddTension          func(childComplexity int, input []*model.AddTensionInput) int
		AddUser             func(childComplexity int, input []*model.AddUserInput, upsert *bool) int
		AddUserEvent        func(childComplexity int, input []*model.AddUserEventInput) int
		AddUserRights       func(childComplexity int, input []*model.AddUserRightsInput) int
		AddVote             func(childComplexity int, input []*model.AddVoteInput, upsert *bool) int
		DeleteBlob          func(childComplexity int, filter model.BlobFilter) int
		DeleteComment       func(childComplexity int, filter model.CommentFilter) int
		DeleteContract      func(childComplexity int, filter model.ContractFilter) int
		DeleteEvent         func(childComplexity int, filter model.EventFilter) int
		DeleteEventCount    func(childComplexity int, filter model.EventCountFilter) int
		DeleteEventFragment func(childComplexity int, filter model.EventFragmentFilter) int
		DeleteLabel         func(childComplexity int, filter model.LabelFilter) int
		DeleteMandate       func(childComplexity int, filter model.MandateFilter) int
		DeleteNode          func(childComplexity int, filter model.NodeFilter) int
		DeleteNodeFragment  func(childComplexity int, filter model.NodeFragmentFilter) int
		DeleteNotif         func(childComplexity int, filter model.NotifFilter) int
		DeleteOrgaAgg       func(childComplexity int, filter model.OrgaAggFilter) int
		DeletePendingUser   func(childComplexity int, filter model.PendingUserFilter) int
		DeletePost          func(childComplexity int, filter model.PostFilter) int
		DeleteReaction      func(childComplexity int, filter model.ReactionFilter) int
		DeleteRoleExt       func(childComplexity int, filter model.RoleExtFilter) int
		DeleteTension       func(childComplexity int, filter model.TensionFilter) int
		DeleteUser          func(childComplexity int, filter model.UserFilter) int
		DeleteUserEvent     func(childComplexity int, filter model.UserEventFilter) int
		DeleteUserRights    func(childComplexity int, filter model.UserRightsFilter) int
		DeleteVote          func(childComplexity int, filter model.VoteFilter) int
		UpdateBlob          func(childComplexity int, input model.UpdateBlobInput) int
		UpdateComment       func(childComplexity int, input model.UpdateCommentInput) int
		UpdateContract      func(childComplexity int, input model.UpdateContractInput) int
		UpdateEvent         func(childComplexity int, input model.UpdateEventInput) int
		UpdateEventCount    func(childComplexity int, input model.UpdateEventCountInput) int
		UpdateEventFragment func(childComplexity int, input model.UpdateEventFragmentInput) int
		UpdateLabel         func(childComplexity int, input model.UpdateLabelInput) int
		UpdateMandate       func(childComplexity int, input model.UpdateMandateInput) int
		UpdateNode          func(childComplexity int, input model.UpdateNodeInput) int
		UpdateNodeFragment  func(childComplexity int, input model.UpdateNodeFragmentInput) int
		UpdateNotif         func(childComplexity int, input model.UpdateNotifInput) int
		UpdateOrgaAgg       func(childComplexity int, input model.UpdateOrgaAggInput) int
		UpdatePendingUser   func(childComplexity int, input model.UpdatePendingUserInput) int
		UpdatePost          func(childComplexity int, input model.UpdatePostInput) int
		UpdateReaction      func(childComplexity int, input model.UpdateReactionInput) int
		UpdateRoleExt       func(childComplexity int, input model.UpdateRoleExtInput) int
		UpdateTension       func(childComplexity int, input model.UpdateTensionInput) int
		UpdateUser          func(childComplexity int, input model.UpdateUserInput) int
		UpdateUserEvent     func(childComplexity int, input model.UpdateUserEventInput) int
		UpdateUserRights    func(childComplexity int, input model.UpdateUserRightsInput) int
		UpdateVote          func(childComplexity int, input model.UpdateVoteInput) int
	}

	Node struct {
		About                  func(childComplexity int) int
		Children               func(childComplexity int, filter *model.NodeFilter, order *model.NodeOrder, first *int, offset *int) int
		ChildrenAggregate      func(childComplexity int, filter *model.NodeFilter) int
		Color                  func(childComplexity int) int
		Contracts              func(childComplexity int, filter *model.VoteFilter, order *model.VoteOrder, first *int, offset *int) int
		ContractsAggregate     func(childComplexity int, filter *model.VoteFilter) int
		CreatedAt              func(childComplexity int) int
		CreatedBy              func(childComplexity int, filter *model.UserFilter) int
		EventsHistory          func(childComplexity int, filter *model.EventFilter, order *model.EventOrder, first *int, offset *int) int
		EventsHistoryAggregate func(childComplexity int, filter *model.EventFilter) int
		FirstLink              func(childComplexity int, filter *model.UserFilter) int
		GuestCanCreateTension  func(childComplexity int) int
		ID                     func(childComplexity int) int
		IsArchived             func(childComplexity int) int
		IsPersonal             func(childComplexity int) int
		IsRoot                 func(childComplexity int) int
		Labels                 func(childComplexity int, filter *model.LabelFilter, order *model.LabelOrder, first *int, offset *int) int
		LabelsAggregate        func(childComplexity int, filter *model.LabelFilter) int
		Mode                   func(childComplexity int) int
		Name                   func(childComplexity int) int
		Nameid                 func(childComplexity int) int
		OrgaAgg                func(childComplexity int, filter *model.OrgaAggFilter) int
		Parent                 func(childComplexity int, filter *model.NodeFilter) int
		Rights                 func(childComplexity int) int
		RoleExt                func(childComplexity int, filter *model.RoleExtFilter) int
		RoleType               func(childComplexity int) int
		Roles                  func(childComplexity int, filter *model.RoleExtFilter, order *model.RoleExtOrder, first *int, offset *int) int
		RolesAggregate         func(childComplexity int, filter *model.RoleExtFilter) int
		Rootnameid             func(childComplexity int) int
		SecondLink             func(childComplexity int, filter *model.UserFilter) int
		Skills                 func(childComplexity int) int
		Source                 func(childComplexity int, filter *model.BlobFilter) int
		TensionsIn             func(childComplexity int, filter *model.TensionFilter, order *model.TensionOrder, first *int, offset *int) int
		TensionsInAggregate    func(childComplexity int, filter *model.TensionFilter) int
		TensionsOut            func(childComplexity int, filter *model.TensionFilter, order *model.TensionOrder, first *int, offset *int) int
		TensionsOutAggregate   func(childComplexity int, filter *model.TensionFilter) int
		Type                   func(childComplexity int) int
		UpdatedAt              func(childComplexity int) int
		UserCanJoin            func(childComplexity int) int
		Visibility             func(childComplexity int) int
		Watchers               func(childComplexity int, filter *model.UserFilter, order *model.UserOrder, first *int, offset *int) int
		WatchersAggregate      func(childComplexity int, filter *model.UserFilter) int
	}

	NodeAggregateResult struct {
		AboutMax      func(childComplexity int) int
		AboutMin      func(childComplexity int) int
		ColorMax      func(childComplexity int) int
		ColorMin      func(childComplexity int) int
		Count         func(childComplexity int) int
		CreatedAtMax  func(childComplexity int) int
		CreatedAtMin  func(childComplexity int) int
		NameMax       func(childComplexity int) int
		NameMin       func(childComplexity int) int
		NameidMax     func(childComplexity int) int
		NameidMin     func(childComplexity int) int
		RightsAvg     func(childComplexity int) int
		RightsMax     func(childComplexity int) int
		RightsMin     func(childComplexity int) int
		RightsSum     func(childComplexity int) int
		RootnameidMax func(childComplexity int) int
		RootnameidMin func(childComplexity int) int
		UpdatedAtMax  func(childComplexity int) int
		UpdatedAtMin  func(childComplexity int) int
	}

	NodeFragment struct {
		About      func(childComplexity int) int
		Color      func(childComplexity int) int
		FirstLink  func(childComplexity int) int
		ID         func(childComplexity int) int
		Mandate    func(childComplexity int, filter *model.MandateFilter) int
		Mode       func(childComplexity int) int
		Name       func(childComplexity int) int
		Nameid     func(childComplexity int) int
		RoleExt    func(childComplexity int) int
		RoleType   func(childComplexity int) int
		SecondLink func(childComplexity int) int
		Skills     func(childComplexity int) int
		Type       func(childComplexity int) int
		Visibility func(childComplexity int) int
	}

	NodeFragmentAggregateResult struct {
		AboutMax      func(childComplexity int) int
		AboutMin      func(childComplexity int) int
		ColorMax      func(childComplexity int) int
		ColorMin      func(childComplexity int) int
		Count         func(childComplexity int) int
		FirstLinkMax  func(childComplexity int) int
		FirstLinkMin  func(childComplexity int) int
		NameMax       func(childComplexity int) int
		NameMin       func(childComplexity int) int
		NameidMax     func(childComplexity int) int
		NameidMin     func(childComplexity int) int
		RoleExtMax    func(childComplexity int) int
		RoleExtMin    func(childComplexity int) int
		SecondLinkMax func(childComplexity int) int
		SecondLinkMin func(childComplexity int) int
	}

	Notif struct {
		Contract  func(childComplexity int, filter *model.ContractFilter) int
		CreatedAt func(childComplexity int) int
		CreatedBy func(childComplexity int, filter *model.UserFilter) int
		ID        func(childComplexity int) int
		Link      func(childComplexity int) int
		Message   func(childComplexity int) int
		Tension   func(childComplexity int, filter *model.TensionFilter) int
		UpdatedAt func(childComplexity int) int
	}

	NotifAggregateResult struct {
		Count        func(childComplexity int) int
		CreatedAtMax func(childComplexity int) int
		CreatedAtMin func(childComplexity int) int
		LinkMax      func(childComplexity int) int
		LinkMin      func(childComplexity int) int
		MessageMax   func(childComplexity int) int
		MessageMin   func(childComplexity int) int
		UpdatedAtMax func(childComplexity int) int
		UpdatedAtMin func(childComplexity int) int
	}

	OrgaAgg struct {
		NGuests  func(childComplexity int) int
		NMembers func(childComplexity int) int
	}

	OrgaAggAggregateResult struct {
		Count       func(childComplexity int) int
		NGuestsAvg  func(childComplexity int) int
		NGuestsMax  func(childComplexity int) int
		NGuestsMin  func(childComplexity int) int
		NGuestsSum  func(childComplexity int) int
		NMembersAvg func(childComplexity int) int
		NMembersMax func(childComplexity int) int
		NMembersMin func(childComplexity int) int
		NMembersSum func(childComplexity int) int
	}

	PendingUser struct {
		Contracts          func(childComplexity int, filter *model.ContractFilter, order *model.ContractOrder, first *int, offset *int) int
		ContractsAggregate func(childComplexity int, filter *model.ContractFilter) int
		Email              func(childComplexity int) int
		EmailToken         func(childComplexity int) int
		ID                 func(childComplexity int) int
		Password           func(childComplexity int) int
		Subscribe          func(childComplexity int) int
		Token              func(childComplexity int) int
		UpdatedAt          func(childComplexity int) int
		Username           func(childComplexity int) int
	}

	PendingUserAggregateResult struct {
		Count         func(childComplexity int) int
		EmailMax      func(childComplexity int) int
		EmailMin      func(childComplexity int) int
		EmailTokenMax func(childComplexity int) int
		EmailTokenMin func(childComplexity int) int
		PasswordMax   func(childComplexity int) int
		PasswordMin   func(childComplexity int) int
		TokenMax      func(childComplexity int) int
		TokenMin      func(childComplexity int) int
		UpdatedAtMax  func(childComplexity int) int
		UpdatedAtMin  func(childComplexity int) int
		UsernameMax   func(childComplexity int) int
		UsernameMin   func(childComplexity int) int
	}

	Point struct {
		Latitude  func(childComplexity int) int
		Longitude func(childComplexity int) int
	}

	PointList struct {
		Points func(childComplexity int) int
	}

	Polygon struct {
		Coordinates func(childComplexity int) int
	}

	Post struct {
		CreatedAt func(childComplexity int) int
		CreatedBy func(childComplexity int, filter *model.UserFilter) int
		ID        func(childComplexity int) int
		Message   func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	PostAggregateResult struct {
		Count        func(childComplexity int) int
		CreatedAtMax func(childComplexity int) int
		CreatedAtMin func(childComplexity int) int
		MessageMax   func(childComplexity int) int
		MessageMin   func(childComplexity int) int
		UpdatedAtMax func(childComplexity int) int
		UpdatedAtMin func(childComplexity int) int
	}

	Query struct {
		AggregateBlob          func(childComplexity int, filter *model.BlobFilter) int
		AggregateComment       func(childComplexity int, filter *model.CommentFilter) int
		AggregateContract      func(childComplexity int, filter *model.ContractFilter) int
		AggregateEvent         func(childComplexity int, filter *model.EventFilter) int
		AggregateEventCount    func(childComplexity int, filter *model.EventCountFilter) int
		AggregateEventFragment func(childComplexity int, filter *model.EventFragmentFilter) int
		AggregateLabel         func(childComplexity int, filter *model.LabelFilter) int
		AggregateMandate       func(childComplexity int, filter *model.MandateFilter) int
		AggregateNode          func(childComplexity int, filter *model.NodeFilter) int
		AggregateNodeFragment  func(childComplexity int, filter *model.NodeFragmentFilter) int
		AggregateNotif         func(childComplexity int, filter *model.NotifFilter) int
		AggregateOrgaAgg       func(childComplexity int, filter *model.OrgaAggFilter) int
		AggregatePendingUser   func(childComplexity int, filter *model.PendingUserFilter) int
		AggregatePost          func(childComplexity int, filter *model.PostFilter) int
		AggregateReaction      func(childComplexity int, filter *model.ReactionFilter) int
		AggregateRoleExt       func(childComplexity int, filter *model.RoleExtFilter) int
		AggregateTension       func(childComplexity int, filter *model.TensionFilter) int
		AggregateUser          func(childComplexity int, filter *model.UserFilter) int
		AggregateUserEvent     func(childComplexity int, filter *model.UserEventFilter) int
		AggregateUserRights    func(childComplexity int, filter *model.UserRightsFilter) int
		AggregateVote          func(childComplexity int, filter *model.VoteFilter) int
		GetBlob                func(childComplexity int, id string) int
		GetComment             func(childComplexity int, id string) int
		GetContract            func(childComplexity int, id *string, contractid *string) int
		GetEvent               func(childComplexity int, id string) int
		GetLabel               func(childComplexity int, id string) int
		GetMandate             func(childComplexity int, id string) int
		GetNode                func(childComplexity int, id *string, nameid *string) int
		GetNodeFragment        func(childComplexity int, id string) int
		GetNotif               func(childComplexity int, id string) int
		GetPendingUser         func(childComplexity int, id *string, username *string, email *string) int
		GetPost                func(childComplexity int, id string) int
		GetReaction            func(childComplexity int, id *string, reactionid *string) int
		GetRoleExt             func(childComplexity int, id string) int
		GetTension             func(childComplexity int, id string) int
		GetUser                func(childComplexity int, id *string, username *string, email *string) int
		GetUserEvent           func(childComplexity int, id string) int
		GetVote                func(childComplexity int, id *string, voteid *string) int
		QueryBlob              func(childComplexity int, filter *model.BlobFilter, order *model.BlobOrder, first *int, offset *int) int
		QueryComment           func(childComplexity int, filter *model.CommentFilter, order *model.CommentOrder, first *int, offset *int) int
		QueryContract          func(childComplexity int, filter *model.ContractFilter, order *model.ContractOrder, first *int, offset *int) int
		QueryEvent             func(childComplexity int, filter *model.EventFilter, order *model.EventOrder, first *int, offset *int) int
		QueryEventCount        func(childComplexity int, filter *model.EventCountFilter, order *model.EventCountOrder, first *int, offset *int) int
		QueryEventFragment     func(childComplexity int, filter *model.EventFragmentFilter, order *model.EventFragmentOrder, first *int, offset *int) int
		QueryLabel             func(childComplexity int, filter *model.LabelFilter, order *model.LabelOrder, first *int, offset *int) int
		QueryMandate           func(childComplexity int, filter *model.MandateFilter, order *model.MandateOrder, first *int, offset *int) int
		QueryNode              func(childComplexity int, filter *model.NodeFilter, order *model.NodeOrder, first *int, offset *int) int
		QueryNodeFragment      func(childComplexity int, filter *model.NodeFragmentFilter, order *model.NodeFragmentOrder, first *int, offset *int) int
		QueryNotif             func(childComplexity int, filter *model.NotifFilter, order *model.NotifOrder, first *int, offset *int) int
		QueryOrgaAgg           func(childComplexity int, filter *model.OrgaAggFilter, order *model.OrgaAggOrder, first *int, offset *int) int
		QueryPendingUser       func(childComplexity int, filter *model.PendingUserFilter, order *model.PendingUserOrder, first *int, offset *int) int
		QueryPost              func(childComplexity int, filter *model.PostFilter, order *model.PostOrder, first *int, offset *int) int
		QueryReaction          func(childComplexity int, filter *model.ReactionFilter, order *model.ReactionOrder, first *int, offset *int) int
		QueryRoleExt           func(childComplexity int, filter *model.RoleExtFilter, order *model.RoleExtOrder, first *int, offset *int) int
		QueryTension           func(childComplexity int, filter *model.TensionFilter, order *model.TensionOrder, first *int, offset *int) int
		QueryUser              func(childComplexity int, filter *model.UserFilter, order *model.UserOrder, first *int, offset *int) int
		QueryUserEvent         func(childComplexity int, filter *model.UserEventFilter, order *model.UserEventOrder, first *int, offset *int) int
		QueryUserRights        func(childComplexity int, filter *model.UserRightsFilter, order *model.UserRightsOrder, first *int, offset *int) int
		QueryVote              func(childComplexity int, filter *model.VoteFilter, order *model.VoteOrder, first *int, offset *int) int
	}

	Reaction struct {
		Comment    func(childComplexity int, filter *model.CommentFilter) int
		ID         func(childComplexity int) int
		Reactionid func(childComplexity int) int
		Type       func(childComplexity int) int
		User       func(childComplexity int, filter *model.UserFilter) int
	}

	ReactionAggregateResult struct {
		Count         func(childComplexity int) int
		ReactionidMax func(childComplexity int) int
		ReactionidMin func(childComplexity int) int
		TypeAvg       func(childComplexity int) int
		TypeMax       func(childComplexity int) int
		TypeMin       func(childComplexity int) int
		TypeSum       func(childComplexity int) int
	}

	RoleExt struct {
		About          func(childComplexity int) int
		Color          func(childComplexity int) int
		ID             func(childComplexity int) int
		Mandate        func(childComplexity int, filter *model.MandateFilter) int
		Name           func(childComplexity int) int
		Nodes          func(childComplexity int, filter *model.NodeFilter, order *model.NodeOrder, first *int, offset *int) int
		NodesAggregate func(childComplexity int, filter *model.NodeFilter) int
		RoleType       func(childComplexity int) int
		Roles          func(childComplexity int, filter *model.NodeFilter, order *model.NodeOrder, first *int, offset *int) int
		RolesAggregate func(childComplexity int, filter *model.NodeFilter) int
		Rootnameid     func(childComplexity int) int
	}

	RoleExtAggregateResult struct {
		AboutMax      func(childComplexity int) int
		AboutMin      func(childComplexity int) int
		ColorMax      func(childComplexity int) int
		ColorMin      func(childComplexity int) int
		Count         func(childComplexity int) int
		NameMax       func(childComplexity int) int
		NameMin       func(childComplexity int) int
		RootnameidMax func(childComplexity int) int
		RootnameidMin func(childComplexity int) int
	}

	Tension struct {
		Action               func(childComplexity int) int
		Assignees            func(childComplexity int, filter *model.UserFilter, order *model.UserOrder, first *int, offset *int) int
		AssigneesAggregate   func(childComplexity int, filter *model.UserFilter) int
		Blobs                func(childComplexity int, filter *model.BlobFilter, order *model.BlobOrder, first *int, offset *int) int
		BlobsAggregate       func(childComplexity int, filter *model.BlobFilter) int
		Comments             func(childComplexity int, filter *model.CommentFilter, order *model.CommentOrder, first *int, offset *int) int
		CommentsAggregate    func(childComplexity int, filter *model.CommentFilter) int
		Contracts            func(childComplexity int, filter *model.ContractFilter, order *model.ContractOrder, first *int, offset *int) int
		ContractsAggregate   func(childComplexity int, filter *model.ContractFilter) int
		CreatedAt            func(childComplexity int) int
		CreatedBy            func(childComplexity int, filter *model.UserFilter) int
		Emitter              func(childComplexity int, filter *model.NodeFilter) int
		Emitterid            func(childComplexity int) int
		History              func(childComplexity int, filter *model.EventFilter, order *model.EventOrder, first *int, offset *int) int
		HistoryAggregate     func(childComplexity int, filter *model.EventFilter) int
		ID                   func(childComplexity int) int
		Labels               func(childComplexity int, filter *model.LabelFilter, order *model.LabelOrder, first *int, offset *int) int
		LabelsAggregate      func(childComplexity int, filter *model.LabelFilter) int
		Mentions             func(childComplexity int, filter *model.EventFilter, order *model.EventOrder, first *int, offset *int) int
		MentionsAggregate    func(childComplexity int, filter *model.EventFilter) int
		Message              func(childComplexity int) int
		NComments            func(childComplexity int) int
		NOpenContracts       func(childComplexity int) int
		Receiver             func(childComplexity int, filter *model.NodeFilter) int
		Receiverid           func(childComplexity int) int
		Status               func(childComplexity int) int
		Subscribers          func(childComplexity int, filter *model.UserFilter, order *model.UserOrder, first *int, offset *int) int
		SubscribersAggregate func(childComplexity int, filter *model.UserFilter) int
		Title                func(childComplexity int) int
		Type                 func(childComplexity int) int
		UpdatedAt            func(childComplexity int) int
	}

	TensionAggregateResult struct {
		Count             func(childComplexity int) int
		CreatedAtMax      func(childComplexity int) int
		CreatedAtMin      func(childComplexity int) int
		EmitteridMax      func(childComplexity int) int
		EmitteridMin      func(childComplexity int) int
		MessageMax        func(childComplexity int) int
		MessageMin        func(childComplexity int) int
		NCommentsAvg      func(childComplexity int) int
		NCommentsMax      func(childComplexity int) int
		NCommentsMin      func(childComplexity int) int
		NCommentsSum      func(childComplexity int) int
		NOpenContractsAvg func(childComplexity int) int
		NOpenContractsMax func(childComplexity int) int
		NOpenContractsMin func(childComplexity int) int
		NOpenContractsSum func(childComplexity int) int
		ReceiveridMax     func(childComplexity int) int
		ReceiveridMin     func(childComplexity int) int
		TitleMax          func(childComplexity int) int
		TitleMin          func(childComplexity int) int
		UpdatedAtMax      func(childComplexity int) int
		UpdatedAtMin      func(childComplexity int) int
	}

	UpdateBlobPayload struct {
		Blob    func(childComplexity int, filter *model.BlobFilter, order *model.BlobOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	UpdateCommentPayload struct {
		Comment func(childComplexity int, filter *model.CommentFilter, order *model.CommentOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	UpdateContractPayload struct {
		Contract func(childComplexity int, filter *model.ContractFilter, order *model.ContractOrder, first *int, offset *int) int
		NumUids  func(childComplexity int) int
	}

	UpdateEventCountPayload struct {
		EventCount func(childComplexity int, filter *model.EventCountFilter, order *model.EventCountOrder, first *int, offset *int) int
		NumUids    func(childComplexity int) int
	}

	UpdateEventFragmentPayload struct {
		EventFragment func(childComplexity int, filter *model.EventFragmentFilter, order *model.EventFragmentOrder, first *int, offset *int) int
		NumUids       func(childComplexity int) int
	}

	UpdateEventPayload struct {
		Event   func(childComplexity int, filter *model.EventFilter, order *model.EventOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	UpdateLabelPayload struct {
		Label   func(childComplexity int, filter *model.LabelFilter, order *model.LabelOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	UpdateMandatePayload struct {
		Mandate func(childComplexity int, filter *model.MandateFilter, order *model.MandateOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	UpdateNodeFragmentPayload struct {
		NodeFragment func(childComplexity int, filter *model.NodeFragmentFilter, order *model.NodeFragmentOrder, first *int, offset *int) int
		NumUids      func(childComplexity int) int
	}

	UpdateNodePayload struct {
		Node    func(childComplexity int, filter *model.NodeFilter, order *model.NodeOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	UpdateNotifPayload struct {
		Notif   func(childComplexity int, filter *model.NotifFilter, order *model.NotifOrder, first *int, offset *int) int
		NumUids func(childComplexity int) int
	}

	UpdateOrgaAggPayload struct {
		NumUids func(childComplexity int) int
		OrgaAgg func(childComplexity int, filter *model.OrgaAggFilter, order *model.OrgaAggOrder, first *int, offset *int) int
	}

	UpdatePendingUserPayload struct {
		NumUids     func(childComplexity int) int
		PendingUser func(childComplexity int, filter *model.PendingUserFilter, order *model.PendingUserOrder, first *int, offset *int) int
	}

	UpdatePostPayload struct {
		NumUids func(childComplexity int) int
		Post    func(childComplexity int, filter *model.PostFilter, order *model.PostOrder, first *int, offset *int) int
	}

	UpdateReactionPayload struct {
		NumUids  func(childComplexity int) int
		Reaction func(childComplexity int, filter *model.ReactionFilter, order *model.ReactionOrder, first *int, offset *int) int
	}

	UpdateRoleExtPayload struct {
		NumUids func(childComplexity int) int
		RoleExt func(childComplexity int, filter *model.RoleExtFilter, order *model.RoleExtOrder, first *int, offset *int) int
	}

	UpdateTensionPayload struct {
		NumUids func(childComplexity int) int
		Tension func(childComplexity int, filter *model.TensionFilter, order *model.TensionOrder, first *int, offset *int) int
	}

	UpdateUserEventPayload struct {
		NumUids   func(childComplexity int) int
		UserEvent func(childComplexity int, filter *model.UserEventFilter, order *model.UserEventOrder, first *int, offset *int) int
	}

	UpdateUserPayload struct {
		NumUids func(childComplexity int) int
		User    func(childComplexity int, filter *model.UserFilter, order *model.UserOrder, first *int, offset *int) int
	}

	UpdateUserRightsPayload struct {
		NumUids    func(childComplexity int) int
		UserRights func(childComplexity int, filter *model.UserRightsFilter, order *model.UserRightsOrder, first *int, offset *int) int
	}

	UpdateVotePayload struct {
		NumUids func(childComplexity int) int
		Vote    func(childComplexity int, filter *model.VoteFilter, order *model.VoteOrder, first *int, offset *int) int
	}

	User struct {
		BackedRoles               func(childComplexity int, filter *model.NodeFilter, order *model.NodeOrder, first *int, offset *int) int
		BackedRolesAggregate      func(childComplexity int, filter *model.NodeFilter) int
		Bio                       func(childComplexity int) int
		Contracts                 func(childComplexity int, filter *model.ContractFilter, order *model.ContractOrder, first *int, offset *int) int
		ContractsAggregate        func(childComplexity int, filter *model.ContractFilter) int
		CreatedAt                 func(childComplexity int) int
		Email                     func(childComplexity int) int
		EventCount                func(childComplexity int, filter *model.EventCountFilter) int
		Events                    func(childComplexity int, filter *model.UserEventFilter, order *model.UserEventOrder, first *int, offset *int) int
		EventsAggregate           func(childComplexity int, filter *model.UserEventFilter) int
		ID                        func(childComplexity int) int
		Lang                      func(childComplexity int) int
		LastAck                   func(childComplexity int) int
		Links                     func(childComplexity int) int
		Location                  func(childComplexity int) int
		MarkAllAsRead             func(childComplexity int) int
		Name                      func(childComplexity int) int
		NotifyByEmail             func(childComplexity int) int
		Password                  func(childComplexity int) int
		Reactions                 func(childComplexity int, filter *model.ReactionFilter, order *model.ReactionOrder, first *int, offset *int) int
		ReactionsAggregate        func(childComplexity int, filter *model.ReactionFilter) int
		Rights                    func(childComplexity int, filter *model.UserRightsFilter) int
		Roles                     func(childComplexity int, filter *model.NodeFilter, order *model.NodeOrder, first *int, offset *int) int
		RolesAggregate            func(childComplexity int, filter *model.NodeFilter) int
		Skills                    func(childComplexity int) int
		Subscriptions             func(childComplexity int, filter *model.TensionFilter, order *model.TensionOrder, first *int, offset *int) int
		SubscriptionsAggregate    func(childComplexity int, filter *model.TensionFilter) int
		TensionsAssigned          func(childComplexity int, filter *model.TensionFilter, order *model.TensionOrder, first *int, offset *int) int
		TensionsAssignedAggregate func(childComplexity int, filter *model.TensionFilter) int
		TensionsCreated           func(childComplexity int, filter *model.TensionFilter, order *model.TensionOrder, first *int, offset *int) int
		TensionsCreatedAggregate  func(childComplexity int, filter *model.TensionFilter) int
		Username                  func(childComplexity int) int
		Utc                       func(childComplexity int) int
		Watching                  func(childComplexity int, filter *model.NodeFilter, order *model.NodeOrder, first *int, offset *int) int
		WatchingAggregate         func(childComplexity int, filter *model.NodeFilter) int
	}

	UserAggregateResult struct {
		BioMax           func(childComplexity int) int
		BioMin           func(childComplexity int) int
		Count            func(childComplexity int) int
		CreatedAtMax     func(childComplexity int) int
		CreatedAtMin     func(childComplexity int) int
		EmailMax         func(childComplexity int) int
		EmailMin         func(childComplexity int) int
		LastAckMax       func(childComplexity int) int
		LastAckMin       func(childComplexity int) int
		LocationMax      func(childComplexity int) int
		LocationMin      func(childComplexity int) int
		MarkAllAsReadMax func(childComplexity int) int
		MarkAllAsReadMin func(childComplexity int) int
		NameMax          func(childComplexity int) int
		NameMin          func(childComplexity int) int
		PasswordMax      func(childComplexity int) int
		PasswordMin      func(childComplexity int) int
		UsernameMax      func(childComplexity int) int
		UsernameMin      func(childComplexity int) int
		UtcMax           func(childComplexity int) int
		UtcMin           func(childComplexity int) int
	}

	UserEvent struct {
		CreatedAt func(childComplexity int) int
		Event     func(childComplexity int, filter *model.EventKindFilter, first *int, offset *int) int
		ID        func(childComplexity int) int
		IsRead    func(childComplexity int) int
		User      func(childComplexity int, filter *model.UserFilter) int
	}

	UserEventAggregateResult struct {
		Count        func(childComplexity int) int
		CreatedAtMax func(childComplexity int) int
		CreatedAtMin func(childComplexity int) int
	}

	UserRights struct {
		CanCreateRoot         func(childComplexity int) int
		CanLogin              func(childComplexity int) int
		HasEmailNotifications func(childComplexity int) int
		MaxPrivateOrga        func(childComplexity int) int
		MaxPublicOrga         func(childComplexity int) int
		Type                  func(childComplexity int) int
	}

	UserRightsAggregateResult struct {
		Count             func(childComplexity int) int
		MaxPrivateOrgaAvg func(childComplexity int) int
		MaxPrivateOrgaMax func(childComplexity int) int
		MaxPrivateOrgaMin func(childComplexity int) int
		MaxPrivateOrgaSum func(childComplexity int) int
		MaxPublicOrgaAvg  func(childComplexity int) int
		MaxPublicOrgaMax  func(childComplexity int) int
		MaxPublicOrgaMin  func(childComplexity int) int
		MaxPublicOrgaSum  func(childComplexity int) int
	}

	Vote struct {
		Contract  func(childComplexity int, filter *model.ContractFilter) int
		CreatedAt func(childComplexity int) int
		CreatedBy func(childComplexity int, filter *model.UserFilter) int
		Data      func(childComplexity int) int
		ID        func(childComplexity int) int
		Message   func(childComplexity int) int
		Node      func(childComplexity int, filter *model.NodeFilter) int
		UpdatedAt func(childComplexity int) int
		Voteid    func(childComplexity int) int
	}

	VoteAggregateResult struct {
		Count        func(childComplexity int) int
		CreatedAtMax func(childComplexity int) int
		CreatedAtMin func(childComplexity int) int
		MessageMax   func(childComplexity int) int
		MessageMin   func(childComplexity int) int
		UpdatedAtMax func(childComplexity int) int
		UpdatedAtMin func(childComplexity int) int
		VoteidMax    func(childComplexity int) int
		VoteidMin    func(childComplexity int) int
	}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "AddBlobPayload.blob":
		if e.complexity.AddBlobPayload.Blob == nil {
			break
		}

		args, err := ec.field_AddBlobPayload_blob_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddBlobPayload.Blob(childComplexity, args["filter"].(*model.BlobFilter), args["order"].(*model.BlobOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddBlobPayload.numUids":
		if e.complexity.AddBlobPayload.NumUids == nil {
			break
		}

		return e.complexity.AddBlobPayload.NumUids(childComplexity), true

	case "AddCommentPayload.comment":
		if e.complexity.AddCommentPayload.Comment == nil {
			break
		}

		args, err := ec.field_AddCommentPayload_comment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddCommentPayload.Comment(childComplexity, args["filter"].(*model.CommentFilter), args["order"].(*model.CommentOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddCommentPayload.numUids":
		if e.complexity.AddCommentPayload.NumUids == nil {
			break
		}

		return e.complexity.AddCommentPayload.NumUids(childComplexity), true

	case "AddContractPayload.contract":
		if e.complexity.AddContractPayload.Contract == nil {
			break
		}

		args, err := ec.field_AddContractPayload_contract_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddContractPayload.Contract(childComplexity, args["filter"].(*model.ContractFilter), args["order"].(*model.ContractOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddContractPayload.numUids":
		if e.complexity.AddContractPayload.NumUids == nil {
			break
		}

		return e.complexity.AddContractPayload.NumUids(childComplexity), true

	case "AddEventCountPayload.eventCount":
		if e.complexity.AddEventCountPayload.EventCount == nil {
			break
		}

		args, err := ec.field_AddEventCountPayload_eventCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddEventCountPayload.EventCount(childComplexity, args["filter"].(*model.EventCountFilter), args["order"].(*model.EventCountOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddEventCountPayload.numUids":
		if e.complexity.AddEventCountPayload.NumUids == nil {
			break
		}

		return e.complexity.AddEventCountPayload.NumUids(childComplexity), true

	case "AddEventFragmentPayload.eventFragment":
		if e.complexity.AddEventFragmentPayload.EventFragment == nil {
			break
		}

		args, err := ec.field_AddEventFragmentPayload_eventFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddEventFragmentPayload.EventFragment(childComplexity, args["filter"].(*model.EventFragmentFilter), args["order"].(*model.EventFragmentOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddEventFragmentPayload.numUids":
		if e.complexity.AddEventFragmentPayload.NumUids == nil {
			break
		}

		return e.complexity.AddEventFragmentPayload.NumUids(childComplexity), true

	case "AddEventPayload.event":
		if e.complexity.AddEventPayload.Event == nil {
			break
		}

		args, err := ec.field_AddEventPayload_event_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddEventPayload.Event(childComplexity, args["filter"].(*model.EventFilter), args["order"].(*model.EventOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddEventPayload.numUids":
		if e.complexity.AddEventPayload.NumUids == nil {
			break
		}

		return e.complexity.AddEventPayload.NumUids(childComplexity), true

	case "AddLabelPayload.label":
		if e.complexity.AddLabelPayload.Label == nil {
			break
		}

		args, err := ec.field_AddLabelPayload_label_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddLabelPayload.Label(childComplexity, args["filter"].(*model.LabelFilter), args["order"].(*model.LabelOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddLabelPayload.numUids":
		if e.complexity.AddLabelPayload.NumUids == nil {
			break
		}

		return e.complexity.AddLabelPayload.NumUids(childComplexity), true

	case "AddMandatePayload.mandate":
		if e.complexity.AddMandatePayload.Mandate == nil {
			break
		}

		args, err := ec.field_AddMandatePayload_mandate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddMandatePayload.Mandate(childComplexity, args["filter"].(*model.MandateFilter), args["order"].(*model.MandateOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddMandatePayload.numUids":
		if e.complexity.AddMandatePayload.NumUids == nil {
			break
		}

		return e.complexity.AddMandatePayload.NumUids(childComplexity), true

	case "AddNodeFragmentPayload.nodeFragment":
		if e.complexity.AddNodeFragmentPayload.NodeFragment == nil {
			break
		}

		args, err := ec.field_AddNodeFragmentPayload_nodeFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddNodeFragmentPayload.NodeFragment(childComplexity, args["filter"].(*model.NodeFragmentFilter), args["order"].(*model.NodeFragmentOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddNodeFragmentPayload.numUids":
		if e.complexity.AddNodeFragmentPayload.NumUids == nil {
			break
		}

		return e.complexity.AddNodeFragmentPayload.NumUids(childComplexity), true

	case "AddNodePayload.node":
		if e.complexity.AddNodePayload.Node == nil {
			break
		}

		args, err := ec.field_AddNodePayload_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddNodePayload.Node(childComplexity, args["filter"].(*model.NodeFilter), args["order"].(*model.NodeOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddNodePayload.numUids":
		if e.complexity.AddNodePayload.NumUids == nil {
			break
		}

		return e.complexity.AddNodePayload.NumUids(childComplexity), true

	case "AddNotifPayload.notif":
		if e.complexity.AddNotifPayload.Notif == nil {
			break
		}

		args, err := ec.field_AddNotifPayload_notif_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddNotifPayload.Notif(childComplexity, args["filter"].(*model.NotifFilter), args["order"].(*model.NotifOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddNotifPayload.numUids":
		if e.complexity.AddNotifPayload.NumUids == nil {
			break
		}

		return e.complexity.AddNotifPayload.NumUids(childComplexity), true

	case "AddOrgaAggPayload.numUids":
		if e.complexity.AddOrgaAggPayload.NumUids == nil {
			break
		}

		return e.complexity.AddOrgaAggPayload.NumUids(childComplexity), true

	case "AddOrgaAggPayload.orgaAgg":
		if e.complexity.AddOrgaAggPayload.OrgaAgg == nil {
			break
		}

		args, err := ec.field_AddOrgaAggPayload_orgaAgg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddOrgaAggPayload.OrgaAgg(childComplexity, args["filter"].(*model.OrgaAggFilter), args["order"].(*model.OrgaAggOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddPendingUserPayload.numUids":
		if e.complexity.AddPendingUserPayload.NumUids == nil {
			break
		}

		return e.complexity.AddPendingUserPayload.NumUids(childComplexity), true

	case "AddPendingUserPayload.pendingUser":
		if e.complexity.AddPendingUserPayload.PendingUser == nil {
			break
		}

		args, err := ec.field_AddPendingUserPayload_pendingUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddPendingUserPayload.PendingUser(childComplexity, args["filter"].(*model.PendingUserFilter), args["order"].(*model.PendingUserOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddReactionPayload.numUids":
		if e.complexity.AddReactionPayload.NumUids == nil {
			break
		}

		return e.complexity.AddReactionPayload.NumUids(childComplexity), true

	case "AddReactionPayload.reaction":
		if e.complexity.AddReactionPayload.Reaction == nil {
			break
		}

		args, err := ec.field_AddReactionPayload_reaction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddReactionPayload.Reaction(childComplexity, args["filter"].(*model.ReactionFilter), args["order"].(*model.ReactionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddRoleExtPayload.numUids":
		if e.complexity.AddRoleExtPayload.NumUids == nil {
			break
		}

		return e.complexity.AddRoleExtPayload.NumUids(childComplexity), true

	case "AddRoleExtPayload.roleExt":
		if e.complexity.AddRoleExtPayload.RoleExt == nil {
			break
		}

		args, err := ec.field_AddRoleExtPayload_roleExt_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddRoleExtPayload.RoleExt(childComplexity, args["filter"].(*model.RoleExtFilter), args["order"].(*model.RoleExtOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddTensionPayload.numUids":
		if e.complexity.AddTensionPayload.NumUids == nil {
			break
		}

		return e.complexity.AddTensionPayload.NumUids(childComplexity), true

	case "AddTensionPayload.tension":
		if e.complexity.AddTensionPayload.Tension == nil {
			break
		}

		args, err := ec.field_AddTensionPayload_tension_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddTensionPayload.Tension(childComplexity, args["filter"].(*model.TensionFilter), args["order"].(*model.TensionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddUserEventPayload.numUids":
		if e.complexity.AddUserEventPayload.NumUids == nil {
			break
		}

		return e.complexity.AddUserEventPayload.NumUids(childComplexity), true

	case "AddUserEventPayload.userEvent":
		if e.complexity.AddUserEventPayload.UserEvent == nil {
			break
		}

		args, err := ec.field_AddUserEventPayload_userEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddUserEventPayload.UserEvent(childComplexity, args["filter"].(*model.UserEventFilter), args["order"].(*model.UserEventOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddUserPayload.numUids":
		if e.complexity.AddUserPayload.NumUids == nil {
			break
		}

		return e.complexity.AddUserPayload.NumUids(childComplexity), true

	case "AddUserPayload.user":
		if e.complexity.AddUserPayload.User == nil {
			break
		}

		args, err := ec.field_AddUserPayload_user_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddUserPayload.User(childComplexity, args["filter"].(*model.UserFilter), args["order"].(*model.UserOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddUserRightsPayload.numUids":
		if e.complexity.AddUserRightsPayload.NumUids == nil {
			break
		}

		return e.complexity.AddUserRightsPayload.NumUids(childComplexity), true

	case "AddUserRightsPayload.userRights":
		if e.complexity.AddUserRightsPayload.UserRights == nil {
			break
		}

		args, err := ec.field_AddUserRightsPayload_userRights_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddUserRightsPayload.UserRights(childComplexity, args["filter"].(*model.UserRightsFilter), args["order"].(*model.UserRightsOrder), args["first"].(*int), args["offset"].(*int)), true

	case "AddVotePayload.numUids":
		if e.complexity.AddVotePayload.NumUids == nil {
			break
		}

		return e.complexity.AddVotePayload.NumUids(childComplexity), true

	case "AddVotePayload.vote":
		if e.complexity.AddVotePayload.Vote == nil {
			break
		}

		args, err := ec.field_AddVotePayload_vote_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AddVotePayload.Vote(childComplexity, args["filter"].(*model.VoteFilter), args["order"].(*model.VoteOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Blob.archivedFlag":
		if e.complexity.Blob.ArchivedFlag == nil {
			break
		}

		return e.complexity.Blob.ArchivedFlag(childComplexity), true

	case "Blob.blob_type":
		if e.complexity.Blob.BlobType == nil {
			break
		}

		return e.complexity.Blob.BlobType(childComplexity), true

	case "Blob.createdAt":
		if e.complexity.Blob.CreatedAt == nil {
			break
		}

		return e.complexity.Blob.CreatedAt(childComplexity), true

	case "Blob.createdBy":
		if e.complexity.Blob.CreatedBy == nil {
			break
		}

		args, err := ec.field_Blob_createdBy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Blob.CreatedBy(childComplexity, args["filter"].(*model.UserFilter)), true

	case "Blob.id":
		if e.complexity.Blob.ID == nil {
			break
		}

		return e.complexity.Blob.ID(childComplexity), true

	case "Blob.md":
		if e.complexity.Blob.Md == nil {
			break
		}

		return e.complexity.Blob.Md(childComplexity), true

	case "Blob.message":
		if e.complexity.Blob.Message == nil {
			break
		}

		return e.complexity.Blob.Message(childComplexity), true

	case "Blob.node":
		if e.complexity.Blob.Node == nil {
			break
		}

		args, err := ec.field_Blob_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Blob.Node(childComplexity, args["filter"].(*model.NodeFragmentFilter)), true

	case "Blob.pushedFlag":
		if e.complexity.Blob.PushedFlag == nil {
			break
		}

		return e.complexity.Blob.PushedFlag(childComplexity), true

	case "Blob.tension":
		if e.complexity.Blob.Tension == nil {
			break
		}

		args, err := ec.field_Blob_tension_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Blob.Tension(childComplexity, args["filter"].(*model.TensionFilter)), true

	case "Blob.updatedAt":
		if e.complexity.Blob.UpdatedAt == nil {
			break
		}

		return e.complexity.Blob.UpdatedAt(childComplexity), true

	case "BlobAggregateResult.archivedFlagMax":
		if e.complexity.BlobAggregateResult.ArchivedFlagMax == nil {
			break
		}

		return e.complexity.BlobAggregateResult.ArchivedFlagMax(childComplexity), true

	case "BlobAggregateResult.archivedFlagMin":
		if e.complexity.BlobAggregateResult.ArchivedFlagMin == nil {
			break
		}

		return e.complexity.BlobAggregateResult.ArchivedFlagMin(childComplexity), true

	case "BlobAggregateResult.count":
		if e.complexity.BlobAggregateResult.Count == nil {
			break
		}

		return e.complexity.BlobAggregateResult.Count(childComplexity), true

	case "BlobAggregateResult.createdAtMax":
		if e.complexity.BlobAggregateResult.CreatedAtMax == nil {
			break
		}

		return e.complexity.BlobAggregateResult.CreatedAtMax(childComplexity), true

	case "BlobAggregateResult.createdAtMin":
		if e.complexity.BlobAggregateResult.CreatedAtMin == nil {
			break
		}

		return e.complexity.BlobAggregateResult.CreatedAtMin(childComplexity), true

	case "BlobAggregateResult.mdMax":
		if e.complexity.BlobAggregateResult.MdMax == nil {
			break
		}

		return e.complexity.BlobAggregateResult.MdMax(childComplexity), true

	case "BlobAggregateResult.mdMin":
		if e.complexity.BlobAggregateResult.MdMin == nil {
			break
		}

		return e.complexity.BlobAggregateResult.MdMin(childComplexity), true

	case "BlobAggregateResult.messageMax":
		if e.complexity.BlobAggregateResult.MessageMax == nil {
			break
		}

		return e.complexity.BlobAggregateResult.MessageMax(childComplexity), true

	case "BlobAggregateResult.messageMin":
		if e.complexity.BlobAggregateResult.MessageMin == nil {
			break
		}

		return e.complexity.BlobAggregateResult.MessageMin(childComplexity), true

	case "BlobAggregateResult.pushedFlagMax":
		if e.complexity.BlobAggregateResult.PushedFlagMax == nil {
			break
		}

		return e.complexity.BlobAggregateResult.PushedFlagMax(childComplexity), true

	case "BlobAggregateResult.pushedFlagMin":
		if e.complexity.BlobAggregateResult.PushedFlagMin == nil {
			break
		}

		return e.complexity.BlobAggregateResult.PushedFlagMin(childComplexity), true

	case "BlobAggregateResult.updatedAtMax":
		if e.complexity.BlobAggregateResult.UpdatedAtMax == nil {
			break
		}

		return e.complexity.BlobAggregateResult.UpdatedAtMax(childComplexity), true

	case "BlobAggregateResult.updatedAtMin":
		if e.complexity.BlobAggregateResult.UpdatedAtMin == nil {
			break
		}

		return e.complexity.BlobAggregateResult.UpdatedAtMin(childComplexity), true

	case "Comment.createdAt":
		if e.complexity.Comment.CreatedAt == nil {
			break
		}

		return e.complexity.Comment.CreatedAt(childComplexity), true

	case "Comment.createdBy":
		if e.complexity.Comment.CreatedBy == nil {
			break
		}

		args, err := ec.field_Comment_createdBy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Comment.CreatedBy(childComplexity, args["filter"].(*model.UserFilter)), true

	case "Comment.id":
		if e.complexity.Comment.ID == nil {
			break
		}

		return e.complexity.Comment.ID(childComplexity), true

	case "Comment.message":
		if e.complexity.Comment.Message == nil {
			break
		}

		return e.complexity.Comment.Message(childComplexity), true

	case "Comment.reactions":
		if e.complexity.Comment.Reactions == nil {
			break
		}

		args, err := ec.field_Comment_reactions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Comment.Reactions(childComplexity, args["filter"].(*model.ReactionFilter), args["order"].(*model.ReactionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Comment.reactionsAggregate":
		if e.complexity.Comment.ReactionsAggregate == nil {
			break
		}

		args, err := ec.field_Comment_reactionsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Comment.ReactionsAggregate(childComplexity, args["filter"].(*model.ReactionFilter)), true

	case "Comment.updatedAt":
		if e.complexity.Comment.UpdatedAt == nil {
			break
		}

		return e.complexity.Comment.UpdatedAt(childComplexity), true

	case "CommentAggregateResult.count":
		if e.complexity.CommentAggregateResult.Count == nil {
			break
		}

		return e.complexity.CommentAggregateResult.Count(childComplexity), true

	case "CommentAggregateResult.createdAtMax":
		if e.complexity.CommentAggregateResult.CreatedAtMax == nil {
			break
		}

		return e.complexity.CommentAggregateResult.CreatedAtMax(childComplexity), true

	case "CommentAggregateResult.createdAtMin":
		if e.complexity.CommentAggregateResult.CreatedAtMin == nil {
			break
		}

		return e.complexity.CommentAggregateResult.CreatedAtMin(childComplexity), true

	case "CommentAggregateResult.messageMax":
		if e.complexity.CommentAggregateResult.MessageMax == nil {
			break
		}

		return e.complexity.CommentAggregateResult.MessageMax(childComplexity), true

	case "CommentAggregateResult.messageMin":
		if e.complexity.CommentAggregateResult.MessageMin == nil {
			break
		}

		return e.complexity.CommentAggregateResult.MessageMin(childComplexity), true

	case "CommentAggregateResult.updatedAtMax":
		if e.complexity.CommentAggregateResult.UpdatedAtMax == nil {
			break
		}

		return e.complexity.CommentAggregateResult.UpdatedAtMax(childComplexity), true

	case "CommentAggregateResult.updatedAtMin":
		if e.complexity.CommentAggregateResult.UpdatedAtMin == nil {
			break
		}

		return e.complexity.CommentAggregateResult.UpdatedAtMin(childComplexity), true

	case "Contract.candidates":
		if e.complexity.Contract.Candidates == nil {
			break
		}

		args, err := ec.field_Contract_candidates_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Contract.Candidates(childComplexity, args["filter"].(*model.UserFilter), args["order"].(*model.UserOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Contract.candidatesAggregate":
		if e.complexity.Contract.CandidatesAggregate == nil {
			break
		}

		args, err := ec.field_Contract_candidatesAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Contract.CandidatesAggregate(childComplexity, args["filter"].(*model.UserFilter)), true

	case "Contract.closedAt":
		if e.complexity.Contract.ClosedAt == nil {
			break
		}

		return e.complexity.Contract.ClosedAt(childComplexity), true

	case "Contract.comments":
		if e.complexity.Contract.Comments == nil {
			break
		}

		args, err := ec.field_Contract_comments_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Contract.Comments(childComplexity, args["filter"].(*model.CommentFilter), args["order"].(*model.CommentOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Contract.commentsAggregate":
		if e.complexity.Contract.CommentsAggregate == nil {
			break
		}

		args, err := ec.field_Contract_commentsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Contract.CommentsAggregate(childComplexity, args["filter"].(*model.CommentFilter)), true

	case "Contract.contract_type":
		if e.complexity.Contract.ContractType == nil {
			break
		}

		return e.complexity.Contract.ContractType(childComplexity), true

	case "Contract.contractid":
		if e.complexity.Contract.Contractid == nil {
			break
		}

		return e.complexity.Contract.Contractid(childComplexity), true

	case "Contract.createdAt":
		if e.complexity.Contract.CreatedAt == nil {
			break
		}

		return e.complexity.Contract.CreatedAt(childComplexity), true

	case "Contract.createdBy":
		if e.complexity.Contract.CreatedBy == nil {
			break
		}

		args, err := ec.field_Contract_createdBy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Contract.CreatedBy(childComplexity, args["filter"].(*model.UserFilter)), true

	case "Contract.event":
		if e.complexity.Contract.Event == nil {
			break
		}

		args, err := ec.field_Contract_event_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Contract.Event(childComplexity, args["filter"].(*model.EventFragmentFilter)), true

	case "Contract.id":
		if e.complexity.Contract.ID == nil {
			break
		}

		return e.complexity.Contract.ID(childComplexity), true

	case "Contract.isValidator":
		if e.complexity.Contract.IsValidator == nil {
			break
		}

		return e.complexity.Contract.IsValidator(childComplexity), true

	case "Contract.message":
		if e.complexity.Contract.Message == nil {
			break
		}

		return e.complexity.Contract.Message(childComplexity), true

	case "Contract.participants":
		if e.complexity.Contract.Participants == nil {
			break
		}

		args, err := ec.field_Contract_participants_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Contract.Participants(childComplexity, args["filter"].(*model.VoteFilter), args["order"].(*model.VoteOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Contract.participantsAggregate":
		if e.complexity.Contract.ParticipantsAggregate == nil {
			break
		}

		args, err := ec.field_Contract_participantsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Contract.ParticipantsAggregate(childComplexity, args["filter"].(*model.VoteFilter)), true

	case "Contract.pending_candidates":
		if e.complexity.Contract.PendingCandidates == nil {
			break
		}

		args, err := ec.field_Contract_pending_candidates_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Contract.PendingCandidates(childComplexity, args["filter"].(*model.PendingUserFilter), args["order"].(*model.PendingUserOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Contract.pending_candidatesAggregate":
		if e.complexity.Contract.PendingCandidatesAggregate == nil {
			break
		}

		args, err := ec.field_Contract_pending_candidatesAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Contract.PendingCandidatesAggregate(childComplexity, args["filter"].(*model.PendingUserFilter)), true

	case "Contract.status":
		if e.complexity.Contract.Status == nil {
			break
		}

		return e.complexity.Contract.Status(childComplexity), true

	case "Contract.tension":
		if e.complexity.Contract.Tension == nil {
			break
		}

		args, err := ec.field_Contract_tension_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Contract.Tension(childComplexity, args["filter"].(*model.TensionFilter)), true

	case "Contract.updatedAt":
		if e.complexity.Contract.UpdatedAt == nil {
			break
		}

		return e.complexity.Contract.UpdatedAt(childComplexity), true

	case "ContractAggregateResult.closedAtMax":
		if e.complexity.ContractAggregateResult.ClosedAtMax == nil {
			break
		}

		return e.complexity.ContractAggregateResult.ClosedAtMax(childComplexity), true

	case "ContractAggregateResult.closedAtMin":
		if e.complexity.ContractAggregateResult.ClosedAtMin == nil {
			break
		}

		return e.complexity.ContractAggregateResult.ClosedAtMin(childComplexity), true

	case "ContractAggregateResult.contractidMax":
		if e.complexity.ContractAggregateResult.ContractidMax == nil {
			break
		}

		return e.complexity.ContractAggregateResult.ContractidMax(childComplexity), true

	case "ContractAggregateResult.contractidMin":
		if e.complexity.ContractAggregateResult.ContractidMin == nil {
			break
		}

		return e.complexity.ContractAggregateResult.ContractidMin(childComplexity), true

	case "ContractAggregateResult.count":
		if e.complexity.ContractAggregateResult.Count == nil {
			break
		}

		return e.complexity.ContractAggregateResult.Count(childComplexity), true

	case "ContractAggregateResult.createdAtMax":
		if e.complexity.ContractAggregateResult.CreatedAtMax == nil {
			break
		}

		return e.complexity.ContractAggregateResult.CreatedAtMax(childComplexity), true

	case "ContractAggregateResult.createdAtMin":
		if e.complexity.ContractAggregateResult.CreatedAtMin == nil {
			break
		}

		return e.complexity.ContractAggregateResult.CreatedAtMin(childComplexity), true

	case "ContractAggregateResult.messageMax":
		if e.complexity.ContractAggregateResult.MessageMax == nil {
			break
		}

		return e.complexity.ContractAggregateResult.MessageMax(childComplexity), true

	case "ContractAggregateResult.messageMin":
		if e.complexity.ContractAggregateResult.MessageMin == nil {
			break
		}

		return e.complexity.ContractAggregateResult.MessageMin(childComplexity), true

	case "ContractAggregateResult.updatedAtMax":
		if e.complexity.ContractAggregateResult.UpdatedAtMax == nil {
			break
		}

		return e.complexity.ContractAggregateResult.UpdatedAtMax(childComplexity), true

	case "ContractAggregateResult.updatedAtMin":
		if e.complexity.ContractAggregateResult.UpdatedAtMin == nil {
			break
		}

		return e.complexity.ContractAggregateResult.UpdatedAtMin(childComplexity), true

	case "DeleteBlobPayload.blob":
		if e.complexity.DeleteBlobPayload.Blob == nil {
			break
		}

		args, err := ec.field_DeleteBlobPayload_blob_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteBlobPayload.Blob(childComplexity, args["filter"].(*model.BlobFilter), args["order"].(*model.BlobOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteBlobPayload.msg":
		if e.complexity.DeleteBlobPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteBlobPayload.Msg(childComplexity), true

	case "DeleteBlobPayload.numUids":
		if e.complexity.DeleteBlobPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteBlobPayload.NumUids(childComplexity), true

	case "DeleteCommentPayload.comment":
		if e.complexity.DeleteCommentPayload.Comment == nil {
			break
		}

		args, err := ec.field_DeleteCommentPayload_comment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteCommentPayload.Comment(childComplexity, args["filter"].(*model.CommentFilter), args["order"].(*model.CommentOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteCommentPayload.msg":
		if e.complexity.DeleteCommentPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteCommentPayload.Msg(childComplexity), true

	case "DeleteCommentPayload.numUids":
		if e.complexity.DeleteCommentPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteCommentPayload.NumUids(childComplexity), true

	case "DeleteContractPayload.contract":
		if e.complexity.DeleteContractPayload.Contract == nil {
			break
		}

		args, err := ec.field_DeleteContractPayload_contract_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteContractPayload.Contract(childComplexity, args["filter"].(*model.ContractFilter), args["order"].(*model.ContractOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteContractPayload.msg":
		if e.complexity.DeleteContractPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteContractPayload.Msg(childComplexity), true

	case "DeleteContractPayload.numUids":
		if e.complexity.DeleteContractPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteContractPayload.NumUids(childComplexity), true

	case "DeleteEventCountPayload.eventCount":
		if e.complexity.DeleteEventCountPayload.EventCount == nil {
			break
		}

		args, err := ec.field_DeleteEventCountPayload_eventCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteEventCountPayload.EventCount(childComplexity, args["filter"].(*model.EventCountFilter), args["order"].(*model.EventCountOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteEventCountPayload.msg":
		if e.complexity.DeleteEventCountPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteEventCountPayload.Msg(childComplexity), true

	case "DeleteEventCountPayload.numUids":
		if e.complexity.DeleteEventCountPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteEventCountPayload.NumUids(childComplexity), true

	case "DeleteEventFragmentPayload.eventFragment":
		if e.complexity.DeleteEventFragmentPayload.EventFragment == nil {
			break
		}

		args, err := ec.field_DeleteEventFragmentPayload_eventFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteEventFragmentPayload.EventFragment(childComplexity, args["filter"].(*model.EventFragmentFilter), args["order"].(*model.EventFragmentOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteEventFragmentPayload.msg":
		if e.complexity.DeleteEventFragmentPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteEventFragmentPayload.Msg(childComplexity), true

	case "DeleteEventFragmentPayload.numUids":
		if e.complexity.DeleteEventFragmentPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteEventFragmentPayload.NumUids(childComplexity), true

	case "DeleteEventPayload.event":
		if e.complexity.DeleteEventPayload.Event == nil {
			break
		}

		args, err := ec.field_DeleteEventPayload_event_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteEventPayload.Event(childComplexity, args["filter"].(*model.EventFilter), args["order"].(*model.EventOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteEventPayload.msg":
		if e.complexity.DeleteEventPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteEventPayload.Msg(childComplexity), true

	case "DeleteEventPayload.numUids":
		if e.complexity.DeleteEventPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteEventPayload.NumUids(childComplexity), true

	case "DeleteLabelPayload.label":
		if e.complexity.DeleteLabelPayload.Label == nil {
			break
		}

		args, err := ec.field_DeleteLabelPayload_label_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteLabelPayload.Label(childComplexity, args["filter"].(*model.LabelFilter), args["order"].(*model.LabelOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteLabelPayload.msg":
		if e.complexity.DeleteLabelPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteLabelPayload.Msg(childComplexity), true

	case "DeleteLabelPayload.numUids":
		if e.complexity.DeleteLabelPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteLabelPayload.NumUids(childComplexity), true

	case "DeleteMandatePayload.mandate":
		if e.complexity.DeleteMandatePayload.Mandate == nil {
			break
		}

		args, err := ec.field_DeleteMandatePayload_mandate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteMandatePayload.Mandate(childComplexity, args["filter"].(*model.MandateFilter), args["order"].(*model.MandateOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteMandatePayload.msg":
		if e.complexity.DeleteMandatePayload.Msg == nil {
			break
		}

		return e.complexity.DeleteMandatePayload.Msg(childComplexity), true

	case "DeleteMandatePayload.numUids":
		if e.complexity.DeleteMandatePayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteMandatePayload.NumUids(childComplexity), true

	case "DeleteNodeFragmentPayload.msg":
		if e.complexity.DeleteNodeFragmentPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteNodeFragmentPayload.Msg(childComplexity), true

	case "DeleteNodeFragmentPayload.nodeFragment":
		if e.complexity.DeleteNodeFragmentPayload.NodeFragment == nil {
			break
		}

		args, err := ec.field_DeleteNodeFragmentPayload_nodeFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteNodeFragmentPayload.NodeFragment(childComplexity, args["filter"].(*model.NodeFragmentFilter), args["order"].(*model.NodeFragmentOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteNodeFragmentPayload.numUids":
		if e.complexity.DeleteNodeFragmentPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteNodeFragmentPayload.NumUids(childComplexity), true

	case "DeleteNodePayload.msg":
		if e.complexity.DeleteNodePayload.Msg == nil {
			break
		}

		return e.complexity.DeleteNodePayload.Msg(childComplexity), true

	case "DeleteNodePayload.node":
		if e.complexity.DeleteNodePayload.Node == nil {
			break
		}

		args, err := ec.field_DeleteNodePayload_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteNodePayload.Node(childComplexity, args["filter"].(*model.NodeFilter), args["order"].(*model.NodeOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteNodePayload.numUids":
		if e.complexity.DeleteNodePayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteNodePayload.NumUids(childComplexity), true

	case "DeleteNotifPayload.msg":
		if e.complexity.DeleteNotifPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteNotifPayload.Msg(childComplexity), true

	case "DeleteNotifPayload.notif":
		if e.complexity.DeleteNotifPayload.Notif == nil {
			break
		}

		args, err := ec.field_DeleteNotifPayload_notif_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteNotifPayload.Notif(childComplexity, args["filter"].(*model.NotifFilter), args["order"].(*model.NotifOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteNotifPayload.numUids":
		if e.complexity.DeleteNotifPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteNotifPayload.NumUids(childComplexity), true

	case "DeleteOrgaAggPayload.msg":
		if e.complexity.DeleteOrgaAggPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteOrgaAggPayload.Msg(childComplexity), true

	case "DeleteOrgaAggPayload.numUids":
		if e.complexity.DeleteOrgaAggPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteOrgaAggPayload.NumUids(childComplexity), true

	case "DeleteOrgaAggPayload.orgaAgg":
		if e.complexity.DeleteOrgaAggPayload.OrgaAgg == nil {
			break
		}

		args, err := ec.field_DeleteOrgaAggPayload_orgaAgg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteOrgaAggPayload.OrgaAgg(childComplexity, args["filter"].(*model.OrgaAggFilter), args["order"].(*model.OrgaAggOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeletePendingUserPayload.msg":
		if e.complexity.DeletePendingUserPayload.Msg == nil {
			break
		}

		return e.complexity.DeletePendingUserPayload.Msg(childComplexity), true

	case "DeletePendingUserPayload.numUids":
		if e.complexity.DeletePendingUserPayload.NumUids == nil {
			break
		}

		return e.complexity.DeletePendingUserPayload.NumUids(childComplexity), true

	case "DeletePendingUserPayload.pendingUser":
		if e.complexity.DeletePendingUserPayload.PendingUser == nil {
			break
		}

		args, err := ec.field_DeletePendingUserPayload_pendingUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeletePendingUserPayload.PendingUser(childComplexity, args["filter"].(*model.PendingUserFilter), args["order"].(*model.PendingUserOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeletePostPayload.msg":
		if e.complexity.DeletePostPayload.Msg == nil {
			break
		}

		return e.complexity.DeletePostPayload.Msg(childComplexity), true

	case "DeletePostPayload.numUids":
		if e.complexity.DeletePostPayload.NumUids == nil {
			break
		}

		return e.complexity.DeletePostPayload.NumUids(childComplexity), true

	case "DeletePostPayload.post":
		if e.complexity.DeletePostPayload.Post == nil {
			break
		}

		args, err := ec.field_DeletePostPayload_post_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeletePostPayload.Post(childComplexity, args["filter"].(*model.PostFilter), args["order"].(*model.PostOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteReactionPayload.msg":
		if e.complexity.DeleteReactionPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteReactionPayload.Msg(childComplexity), true

	case "DeleteReactionPayload.numUids":
		if e.complexity.DeleteReactionPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteReactionPayload.NumUids(childComplexity), true

	case "DeleteReactionPayload.reaction":
		if e.complexity.DeleteReactionPayload.Reaction == nil {
			break
		}

		args, err := ec.field_DeleteReactionPayload_reaction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteReactionPayload.Reaction(childComplexity, args["filter"].(*model.ReactionFilter), args["order"].(*model.ReactionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteRoleExtPayload.msg":
		if e.complexity.DeleteRoleExtPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteRoleExtPayload.Msg(childComplexity), true

	case "DeleteRoleExtPayload.numUids":
		if e.complexity.DeleteRoleExtPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteRoleExtPayload.NumUids(childComplexity), true

	case "DeleteRoleExtPayload.roleExt":
		if e.complexity.DeleteRoleExtPayload.RoleExt == nil {
			break
		}

		args, err := ec.field_DeleteRoleExtPayload_roleExt_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteRoleExtPayload.RoleExt(childComplexity, args["filter"].(*model.RoleExtFilter), args["order"].(*model.RoleExtOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteTensionPayload.msg":
		if e.complexity.DeleteTensionPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteTensionPayload.Msg(childComplexity), true

	case "DeleteTensionPayload.numUids":
		if e.complexity.DeleteTensionPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteTensionPayload.NumUids(childComplexity), true

	case "DeleteTensionPayload.tension":
		if e.complexity.DeleteTensionPayload.Tension == nil {
			break
		}

		args, err := ec.field_DeleteTensionPayload_tension_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteTensionPayload.Tension(childComplexity, args["filter"].(*model.TensionFilter), args["order"].(*model.TensionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteUserEventPayload.msg":
		if e.complexity.DeleteUserEventPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteUserEventPayload.Msg(childComplexity), true

	case "DeleteUserEventPayload.numUids":
		if e.complexity.DeleteUserEventPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteUserEventPayload.NumUids(childComplexity), true

	case "DeleteUserEventPayload.userEvent":
		if e.complexity.DeleteUserEventPayload.UserEvent == nil {
			break
		}

		args, err := ec.field_DeleteUserEventPayload_userEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteUserEventPayload.UserEvent(childComplexity, args["filter"].(*model.UserEventFilter), args["order"].(*model.UserEventOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteUserPayload.msg":
		if e.complexity.DeleteUserPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteUserPayload.Msg(childComplexity), true

	case "DeleteUserPayload.numUids":
		if e.complexity.DeleteUserPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteUserPayload.NumUids(childComplexity), true

	case "DeleteUserPayload.user":
		if e.complexity.DeleteUserPayload.User == nil {
			break
		}

		args, err := ec.field_DeleteUserPayload_user_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteUserPayload.User(childComplexity, args["filter"].(*model.UserFilter), args["order"].(*model.UserOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteUserRightsPayload.msg":
		if e.complexity.DeleteUserRightsPayload.Msg == nil {
			break
		}

		return e.complexity.DeleteUserRightsPayload.Msg(childComplexity), true

	case "DeleteUserRightsPayload.numUids":
		if e.complexity.DeleteUserRightsPayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteUserRightsPayload.NumUids(childComplexity), true

	case "DeleteUserRightsPayload.userRights":
		if e.complexity.DeleteUserRightsPayload.UserRights == nil {
			break
		}

		args, err := ec.field_DeleteUserRightsPayload_userRights_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteUserRightsPayload.UserRights(childComplexity, args["filter"].(*model.UserRightsFilter), args["order"].(*model.UserRightsOrder), args["first"].(*int), args["offset"].(*int)), true

	case "DeleteVotePayload.msg":
		if e.complexity.DeleteVotePayload.Msg == nil {
			break
		}

		return e.complexity.DeleteVotePayload.Msg(childComplexity), true

	case "DeleteVotePayload.numUids":
		if e.complexity.DeleteVotePayload.NumUids == nil {
			break
		}

		return e.complexity.DeleteVotePayload.NumUids(childComplexity), true

	case "DeleteVotePayload.vote":
		if e.complexity.DeleteVotePayload.Vote == nil {
			break
		}

		args, err := ec.field_DeleteVotePayload_vote_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DeleteVotePayload.Vote(childComplexity, args["filter"].(*model.VoteFilter), args["order"].(*model.VoteOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Event.createdAt":
		if e.complexity.Event.CreatedAt == nil {
			break
		}

		return e.complexity.Event.CreatedAt(childComplexity), true

	case "Event.createdBy":
		if e.complexity.Event.CreatedBy == nil {
			break
		}

		args, err := ec.field_Event_createdBy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Event.CreatedBy(childComplexity, args["filter"].(*model.UserFilter)), true

	case "Event.event_type":
		if e.complexity.Event.EventType == nil {
			break
		}

		return e.complexity.Event.EventType(childComplexity), true

	case "Event.id":
		if e.complexity.Event.ID == nil {
			break
		}

		return e.complexity.Event.ID(childComplexity), true

	case "Event.mentioned":
		if e.complexity.Event.Mentioned == nil {
			break
		}

		args, err := ec.field_Event_mentioned_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Event.Mentioned(childComplexity, args["filter"].(*model.TensionFilter)), true

	case "Event.message":
		if e.complexity.Event.Message == nil {
			break
		}

		return e.complexity.Event.Message(childComplexity), true

	case "Event.new":
		if e.complexity.Event.New == nil {
			break
		}

		return e.complexity.Event.New(childComplexity), true

	case "Event.old":
		if e.complexity.Event.Old == nil {
			break
		}

		return e.complexity.Event.Old(childComplexity), true

	case "Event.tension":
		if e.complexity.Event.Tension == nil {
			break
		}

		args, err := ec.field_Event_tension_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Event.Tension(childComplexity, args["filter"].(*model.TensionFilter)), true

	case "Event.updatedAt":
		if e.complexity.Event.UpdatedAt == nil {
			break
		}

		return e.complexity.Event.UpdatedAt(childComplexity), true

	case "EventAggregateResult.count":
		if e.complexity.EventAggregateResult.Count == nil {
			break
		}

		return e.complexity.EventAggregateResult.Count(childComplexity), true

	case "EventAggregateResult.createdAtMax":
		if e.complexity.EventAggregateResult.CreatedAtMax == nil {
			break
		}

		return e.complexity.EventAggregateResult.CreatedAtMax(childComplexity), true

	case "EventAggregateResult.createdAtMin":
		if e.complexity.EventAggregateResult.CreatedAtMin == nil {
			break
		}

		return e.complexity.EventAggregateResult.CreatedAtMin(childComplexity), true

	case "EventAggregateResult.messageMax":
		if e.complexity.EventAggregateResult.MessageMax == nil {
			break
		}

		return e.complexity.EventAggregateResult.MessageMax(childComplexity), true

	case "EventAggregateResult.messageMin":
		if e.complexity.EventAggregateResult.MessageMin == nil {
			break
		}

		return e.complexity.EventAggregateResult.MessageMin(childComplexity), true

	case "EventAggregateResult.newMax":
		if e.complexity.EventAggregateResult.NewMax == nil {
			break
		}

		return e.complexity.EventAggregateResult.NewMax(childComplexity), true

	case "EventAggregateResult.newMin":
		if e.complexity.EventAggregateResult.NewMin == nil {
			break
		}

		return e.complexity.EventAggregateResult.NewMin(childComplexity), true

	case "EventAggregateResult.oldMax":
		if e.complexity.EventAggregateResult.OldMax == nil {
			break
		}

		return e.complexity.EventAggregateResult.OldMax(childComplexity), true

	case "EventAggregateResult.oldMin":
		if e.complexity.EventAggregateResult.OldMin == nil {
			break
		}

		return e.complexity.EventAggregateResult.OldMin(childComplexity), true

	case "EventAggregateResult.updatedAtMax":
		if e.complexity.EventAggregateResult.UpdatedAtMax == nil {
			break
		}

		return e.complexity.EventAggregateResult.UpdatedAtMax(childComplexity), true

	case "EventAggregateResult.updatedAtMin":
		if e.complexity.EventAggregateResult.UpdatedAtMin == nil {
			break
		}

		return e.complexity.EventAggregateResult.UpdatedAtMin(childComplexity), true

	case "EventCount.assigned_tensions":
		if e.complexity.EventCount.AssignedTensions == nil {
			break
		}

		return e.complexity.EventCount.AssignedTensions(childComplexity), true

	case "EventCount.pending_contracts":
		if e.complexity.EventCount.PendingContracts == nil {
			break
		}

		return e.complexity.EventCount.PendingContracts(childComplexity), true

	case "EventCount.unread_events":
		if e.complexity.EventCount.UnreadEvents == nil {
			break
		}

		return e.complexity.EventCount.UnreadEvents(childComplexity), true

	case "EventCountAggregateResult.assigned_tensionsAvg":
		if e.complexity.EventCountAggregateResult.AssignedTensionsAvg == nil {
			break
		}

		return e.complexity.EventCountAggregateResult.AssignedTensionsAvg(childComplexity), true

	case "EventCountAggregateResult.assigned_tensionsMax":
		if e.complexity.EventCountAggregateResult.AssignedTensionsMax == nil {
			break
		}

		return e.complexity.EventCountAggregateResult.AssignedTensionsMax(childComplexity), true

	case "EventCountAggregateResult.assigned_tensionsMin":
		if e.complexity.EventCountAggregateResult.AssignedTensionsMin == nil {
			break
		}

		return e.complexity.EventCountAggregateResult.AssignedTensionsMin(childComplexity), true

	case "EventCountAggregateResult.assigned_tensionsSum":
		if e.complexity.EventCountAggregateResult.AssignedTensionsSum == nil {
			break
		}

		return e.complexity.EventCountAggregateResult.AssignedTensionsSum(childComplexity), true

	case "EventCountAggregateResult.count":
		if e.complexity.EventCountAggregateResult.Count == nil {
			break
		}

		return e.complexity.EventCountAggregateResult.Count(childComplexity), true

	case "EventCountAggregateResult.pending_contractsAvg":
		if e.complexity.EventCountAggregateResult.PendingContractsAvg == nil {
			break
		}

		return e.complexity.EventCountAggregateResult.PendingContractsAvg(childComplexity), true

	case "EventCountAggregateResult.pending_contractsMax":
		if e.complexity.EventCountAggregateResult.PendingContractsMax == nil {
			break
		}

		return e.complexity.EventCountAggregateResult.PendingContractsMax(childComplexity), true

	case "EventCountAggregateResult.pending_contractsMin":
		if e.complexity.EventCountAggregateResult.PendingContractsMin == nil {
			break
		}

		return e.complexity.EventCountAggregateResult.PendingContractsMin(childComplexity), true

	case "EventCountAggregateResult.pending_contractsSum":
		if e.complexity.EventCountAggregateResult.PendingContractsSum == nil {
			break
		}

		return e.complexity.EventCountAggregateResult.PendingContractsSum(childComplexity), true

	case "EventCountAggregateResult.unread_eventsAvg":
		if e.complexity.EventCountAggregateResult.UnreadEventsAvg == nil {
			break
		}

		return e.complexity.EventCountAggregateResult.UnreadEventsAvg(childComplexity), true

	case "EventCountAggregateResult.unread_eventsMax":
		if e.complexity.EventCountAggregateResult.UnreadEventsMax == nil {
			break
		}

		return e.complexity.EventCountAggregateResult.UnreadEventsMax(childComplexity), true

	case "EventCountAggregateResult.unread_eventsMin":
		if e.complexity.EventCountAggregateResult.UnreadEventsMin == nil {
			break
		}

		return e.complexity.EventCountAggregateResult.UnreadEventsMin(childComplexity), true

	case "EventCountAggregateResult.unread_eventsSum":
		if e.complexity.EventCountAggregateResult.UnreadEventsSum == nil {
			break
		}

		return e.complexity.EventCountAggregateResult.UnreadEventsSum(childComplexity), true

	case "EventFragment.event_type":
		if e.complexity.EventFragment.EventType == nil {
			break
		}

		return e.complexity.EventFragment.EventType(childComplexity), true

	case "EventFragment.new":
		if e.complexity.EventFragment.New == nil {
			break
		}

		return e.complexity.EventFragment.New(childComplexity), true

	case "EventFragment.old":
		if e.complexity.EventFragment.Old == nil {
			break
		}

		return e.complexity.EventFragment.Old(childComplexity), true

	case "EventFragmentAggregateResult.count":
		if e.complexity.EventFragmentAggregateResult.Count == nil {
			break
		}

		return e.complexity.EventFragmentAggregateResult.Count(childComplexity), true

	case "EventFragmentAggregateResult.newMax":
		if e.complexity.EventFragmentAggregateResult.NewMax == nil {
			break
		}

		return e.complexity.EventFragmentAggregateResult.NewMax(childComplexity), true

	case "EventFragmentAggregateResult.newMin":
		if e.complexity.EventFragmentAggregateResult.NewMin == nil {
			break
		}

		return e.complexity.EventFragmentAggregateResult.NewMin(childComplexity), true

	case "EventFragmentAggregateResult.oldMax":
		if e.complexity.EventFragmentAggregateResult.OldMax == nil {
			break
		}

		return e.complexity.EventFragmentAggregateResult.OldMax(childComplexity), true

	case "EventFragmentAggregateResult.oldMin":
		if e.complexity.EventFragmentAggregateResult.OldMin == nil {
			break
		}

		return e.complexity.EventFragmentAggregateResult.OldMin(childComplexity), true

	case "Label.color":
		if e.complexity.Label.Color == nil {
			break
		}

		return e.complexity.Label.Color(childComplexity), true

	case "Label.description":
		if e.complexity.Label.Description == nil {
			break
		}

		return e.complexity.Label.Description(childComplexity), true

	case "Label.id":
		if e.complexity.Label.ID == nil {
			break
		}

		return e.complexity.Label.ID(childComplexity), true

	case "Label.name":
		if e.complexity.Label.Name == nil {
			break
		}

		return e.complexity.Label.Name(childComplexity), true

	case "Label.nodes":
		if e.complexity.Label.Nodes == nil {
			break
		}

		args, err := ec.field_Label_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Label.Nodes(childComplexity, args["filter"].(*model.NodeFilter), args["order"].(*model.NodeOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Label.nodesAggregate":
		if e.complexity.Label.NodesAggregate == nil {
			break
		}

		args, err := ec.field_Label_nodesAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Label.NodesAggregate(childComplexity, args["filter"].(*model.NodeFilter)), true

	case "Label.rootnameid":
		if e.complexity.Label.Rootnameid == nil {
			break
		}

		return e.complexity.Label.Rootnameid(childComplexity), true

	case "Label.tensions":
		if e.complexity.Label.Tensions == nil {
			break
		}

		args, err := ec.field_Label_tensions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Label.Tensions(childComplexity, args["filter"].(*model.TensionFilter), args["order"].(*model.TensionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Label.tensionsAggregate":
		if e.complexity.Label.TensionsAggregate == nil {
			break
		}

		args, err := ec.field_Label_tensionsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Label.TensionsAggregate(childComplexity, args["filter"].(*model.TensionFilter)), true

	case "LabelAggregateResult.colorMax":
		if e.complexity.LabelAggregateResult.ColorMax == nil {
			break
		}

		return e.complexity.LabelAggregateResult.ColorMax(childComplexity), true

	case "LabelAggregateResult.colorMin":
		if e.complexity.LabelAggregateResult.ColorMin == nil {
			break
		}

		return e.complexity.LabelAggregateResult.ColorMin(childComplexity), true

	case "LabelAggregateResult.count":
		if e.complexity.LabelAggregateResult.Count == nil {
			break
		}

		return e.complexity.LabelAggregateResult.Count(childComplexity), true

	case "LabelAggregateResult.descriptionMax":
		if e.complexity.LabelAggregateResult.DescriptionMax == nil {
			break
		}

		return e.complexity.LabelAggregateResult.DescriptionMax(childComplexity), true

	case "LabelAggregateResult.descriptionMin":
		if e.complexity.LabelAggregateResult.DescriptionMin == nil {
			break
		}

		return e.complexity.LabelAggregateResult.DescriptionMin(childComplexity), true

	case "LabelAggregateResult.nameMax":
		if e.complexity.LabelAggregateResult.NameMax == nil {
			break
		}

		return e.complexity.LabelAggregateResult.NameMax(childComplexity), true

	case "LabelAggregateResult.nameMin":
		if e.complexity.LabelAggregateResult.NameMin == nil {
			break
		}

		return e.complexity.LabelAggregateResult.NameMin(childComplexity), true

	case "LabelAggregateResult.rootnameidMax":
		if e.complexity.LabelAggregateResult.RootnameidMax == nil {
			break
		}

		return e.complexity.LabelAggregateResult.RootnameidMax(childComplexity), true

	case "LabelAggregateResult.rootnameidMin":
		if e.complexity.LabelAggregateResult.RootnameidMin == nil {
			break
		}

		return e.complexity.LabelAggregateResult.RootnameidMin(childComplexity), true

	case "Mandate.domains":
		if e.complexity.Mandate.Domains == nil {
			break
		}

		return e.complexity.Mandate.Domains(childComplexity), true

	case "Mandate.id":
		if e.complexity.Mandate.ID == nil {
			break
		}

		return e.complexity.Mandate.ID(childComplexity), true

	case "Mandate.policies":
		if e.complexity.Mandate.Policies == nil {
			break
		}

		return e.complexity.Mandate.Policies(childComplexity), true

	case "Mandate.purpose":
		if e.complexity.Mandate.Purpose == nil {
			break
		}

		return e.complexity.Mandate.Purpose(childComplexity), true

	case "Mandate.responsabilities":
		if e.complexity.Mandate.Responsabilities == nil {
			break
		}

		return e.complexity.Mandate.Responsabilities(childComplexity), true

	case "MandateAggregateResult.count":
		if e.complexity.MandateAggregateResult.Count == nil {
			break
		}

		return e.complexity.MandateAggregateResult.Count(childComplexity), true

	case "MandateAggregateResult.domainsMax":
		if e.complexity.MandateAggregateResult.DomainsMax == nil {
			break
		}

		return e.complexity.MandateAggregateResult.DomainsMax(childComplexity), true

	case "MandateAggregateResult.domainsMin":
		if e.complexity.MandateAggregateResult.DomainsMin == nil {
			break
		}

		return e.complexity.MandateAggregateResult.DomainsMin(childComplexity), true

	case "MandateAggregateResult.policiesMax":
		if e.complexity.MandateAggregateResult.PoliciesMax == nil {
			break
		}

		return e.complexity.MandateAggregateResult.PoliciesMax(childComplexity), true

	case "MandateAggregateResult.policiesMin":
		if e.complexity.MandateAggregateResult.PoliciesMin == nil {
			break
		}

		return e.complexity.MandateAggregateResult.PoliciesMin(childComplexity), true

	case "MandateAggregateResult.purposeMax":
		if e.complexity.MandateAggregateResult.PurposeMax == nil {
			break
		}

		return e.complexity.MandateAggregateResult.PurposeMax(childComplexity), true

	case "MandateAggregateResult.purposeMin":
		if e.complexity.MandateAggregateResult.PurposeMin == nil {
			break
		}

		return e.complexity.MandateAggregateResult.PurposeMin(childComplexity), true

	case "MandateAggregateResult.responsabilitiesMax":
		if e.complexity.MandateAggregateResult.ResponsabilitiesMax == nil {
			break
		}

		return e.complexity.MandateAggregateResult.ResponsabilitiesMax(childComplexity), true

	case "MandateAggregateResult.responsabilitiesMin":
		if e.complexity.MandateAggregateResult.ResponsabilitiesMin == nil {
			break
		}

		return e.complexity.MandateAggregateResult.ResponsabilitiesMin(childComplexity), true

	case "MultiPolygon.polygons":
		if e.complexity.MultiPolygon.Polygons == nil {
			break
		}

		return e.complexity.MultiPolygon.Polygons(childComplexity), true

	case "Mutation.addBlob":
		if e.complexity.Mutation.AddBlob == nil {
			break
		}

		args, err := ec.field_Mutation_addBlob_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddBlob(childComplexity, args["input"].([]*model.AddBlobInput)), true

	case "Mutation.addComment":
		if e.complexity.Mutation.AddComment == nil {
			break
		}

		args, err := ec.field_Mutation_addComment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddComment(childComplexity, args["input"].([]*model.AddCommentInput)), true

	case "Mutation.addContract":
		if e.complexity.Mutation.AddContract == nil {
			break
		}

		args, err := ec.field_Mutation_addContract_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddContract(childComplexity, args["input"].([]*model.AddContractInput), args["upsert"].(*bool)), true

	case "Mutation.addEvent":
		if e.complexity.Mutation.AddEvent == nil {
			break
		}

		args, err := ec.field_Mutation_addEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddEvent(childComplexity, args["input"].([]*model.AddEventInput)), true

	case "Mutation.addEventCount":
		if e.complexity.Mutation.AddEventCount == nil {
			break
		}

		args, err := ec.field_Mutation_addEventCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddEventCount(childComplexity, args["input"].([]*model.AddEventCountInput)), true

	case "Mutation.addEventFragment":
		if e.complexity.Mutation.AddEventFragment == nil {
			break
		}

		args, err := ec.field_Mutation_addEventFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddEventFragment(childComplexity, args["input"].([]*model.AddEventFragmentInput)), true

	case "Mutation.addLabel":
		if e.complexity.Mutation.AddLabel == nil {
			break
		}

		args, err := ec.field_Mutation_addLabel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddLabel(childComplexity, args["input"].([]*model.AddLabelInput)), true

	case "Mutation.addMandate":
		if e.complexity.Mutation.AddMandate == nil {
			break
		}

		args, err := ec.field_Mutation_addMandate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddMandate(childComplexity, args["input"].([]*model.AddMandateInput)), true

	case "Mutation.addNode":
		if e.complexity.Mutation.AddNode == nil {
			break
		}

		args, err := ec.field_Mutation_addNode_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddNode(childComplexity, args["input"].([]*model.AddNodeInput), args["upsert"].(*bool)), true

	case "Mutation.addNodeFragment":
		if e.complexity.Mutation.AddNodeFragment == nil {
			break
		}

		args, err := ec.field_Mutation_addNodeFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddNodeFragment(childComplexity, args["input"].([]*model.AddNodeFragmentInput)), true

	case "Mutation.addNotif":
		if e.complexity.Mutation.AddNotif == nil {
			break
		}

		args, err := ec.field_Mutation_addNotif_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddNotif(childComplexity, args["input"].([]*model.AddNotifInput)), true

	case "Mutation.addOrgaAgg":
		if e.complexity.Mutation.AddOrgaAgg == nil {
			break
		}

		args, err := ec.field_Mutation_addOrgaAgg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddOrgaAgg(childComplexity, args["input"].([]*model.AddOrgaAggInput)), true

	case "Mutation.addPendingUser":
		if e.complexity.Mutation.AddPendingUser == nil {
			break
		}

		args, err := ec.field_Mutation_addPendingUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddPendingUser(childComplexity, args["input"].([]*model.AddPendingUserInput), args["upsert"].(*bool)), true

	case "Mutation.addReaction":
		if e.complexity.Mutation.AddReaction == nil {
			break
		}

		args, err := ec.field_Mutation_addReaction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddReaction(childComplexity, args["input"].([]*model.AddReactionInput), args["upsert"].(*bool)), true

	case "Mutation.addRoleExt":
		if e.complexity.Mutation.AddRoleExt == nil {
			break
		}

		args, err := ec.field_Mutation_addRoleExt_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddRoleExt(childComplexity, args["input"].([]*model.AddRoleExtInput)), true

	case "Mutation.addTension":
		if e.complexity.Mutation.AddTension == nil {
			break
		}

		args, err := ec.field_Mutation_addTension_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddTension(childComplexity, args["input"].([]*model.AddTensionInput)), true

	case "Mutation.addUser":
		if e.complexity.Mutation.AddUser == nil {
			break
		}

		args, err := ec.field_Mutation_addUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddUser(childComplexity, args["input"].([]*model.AddUserInput), args["upsert"].(*bool)), true

	case "Mutation.addUserEvent":
		if e.complexity.Mutation.AddUserEvent == nil {
			break
		}

		args, err := ec.field_Mutation_addUserEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddUserEvent(childComplexity, args["input"].([]*model.AddUserEventInput)), true

	case "Mutation.addUserRights":
		if e.complexity.Mutation.AddUserRights == nil {
			break
		}

		args, err := ec.field_Mutation_addUserRights_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddUserRights(childComplexity, args["input"].([]*model.AddUserRightsInput)), true

	case "Mutation.addVote":
		if e.complexity.Mutation.AddVote == nil {
			break
		}

		args, err := ec.field_Mutation_addVote_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddVote(childComplexity, args["input"].([]*model.AddVoteInput), args["upsert"].(*bool)), true

	case "Mutation.deleteBlob":
		if e.complexity.Mutation.DeleteBlob == nil {
			break
		}

		args, err := ec.field_Mutation_deleteBlob_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteBlob(childComplexity, args["filter"].(model.BlobFilter)), true

	case "Mutation.deleteComment":
		if e.complexity.Mutation.DeleteComment == nil {
			break
		}

		args, err := ec.field_Mutation_deleteComment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteComment(childComplexity, args["filter"].(model.CommentFilter)), true

	case "Mutation.deleteContract":
		if e.complexity.Mutation.DeleteContract == nil {
			break
		}

		args, err := ec.field_Mutation_deleteContract_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteContract(childComplexity, args["filter"].(model.ContractFilter)), true

	case "Mutation.deleteEvent":
		if e.complexity.Mutation.DeleteEvent == nil {
			break
		}

		args, err := ec.field_Mutation_deleteEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteEvent(childComplexity, args["filter"].(model.EventFilter)), true

	case "Mutation.deleteEventCount":
		if e.complexity.Mutation.DeleteEventCount == nil {
			break
		}

		args, err := ec.field_Mutation_deleteEventCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteEventCount(childComplexity, args["filter"].(model.EventCountFilter)), true

	case "Mutation.deleteEventFragment":
		if e.complexity.Mutation.DeleteEventFragment == nil {
			break
		}

		args, err := ec.field_Mutation_deleteEventFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteEventFragment(childComplexity, args["filter"].(model.EventFragmentFilter)), true

	case "Mutation.deleteLabel":
		if e.complexity.Mutation.DeleteLabel == nil {
			break
		}

		args, err := ec.field_Mutation_deleteLabel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteLabel(childComplexity, args["filter"].(model.LabelFilter)), true

	case "Mutation.deleteMandate":
		if e.complexity.Mutation.DeleteMandate == nil {
			break
		}

		args, err := ec.field_Mutation_deleteMandate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteMandate(childComplexity, args["filter"].(model.MandateFilter)), true

	case "Mutation.deleteNode":
		if e.complexity.Mutation.DeleteNode == nil {
			break
		}

		args, err := ec.field_Mutation_deleteNode_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteNode(childComplexity, args["filter"].(model.NodeFilter)), true

	case "Mutation.deleteNodeFragment":
		if e.complexity.Mutation.DeleteNodeFragment == nil {
			break
		}

		args, err := ec.field_Mutation_deleteNodeFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteNodeFragment(childComplexity, args["filter"].(model.NodeFragmentFilter)), true

	case "Mutation.deleteNotif":
		if e.complexity.Mutation.DeleteNotif == nil {
			break
		}

		args, err := ec.field_Mutation_deleteNotif_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteNotif(childComplexity, args["filter"].(model.NotifFilter)), true

	case "Mutation.deleteOrgaAgg":
		if e.complexity.Mutation.DeleteOrgaAgg == nil {
			break
		}

		args, err := ec.field_Mutation_deleteOrgaAgg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteOrgaAgg(childComplexity, args["filter"].(model.OrgaAggFilter)), true

	case "Mutation.deletePendingUser":
		if e.complexity.Mutation.DeletePendingUser == nil {
			break
		}

		args, err := ec.field_Mutation_deletePendingUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeletePendingUser(childComplexity, args["filter"].(model.PendingUserFilter)), true

	case "Mutation.deletePost":
		if e.complexity.Mutation.DeletePost == nil {
			break
		}

		args, err := ec.field_Mutation_deletePost_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeletePost(childComplexity, args["filter"].(model.PostFilter)), true

	case "Mutation.deleteReaction":
		if e.complexity.Mutation.DeleteReaction == nil {
			break
		}

		args, err := ec.field_Mutation_deleteReaction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteReaction(childComplexity, args["filter"].(model.ReactionFilter)), true

	case "Mutation.deleteRoleExt":
		if e.complexity.Mutation.DeleteRoleExt == nil {
			break
		}

		args, err := ec.field_Mutation_deleteRoleExt_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteRoleExt(childComplexity, args["filter"].(model.RoleExtFilter)), true

	case "Mutation.deleteTension":
		if e.complexity.Mutation.DeleteTension == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTension_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTension(childComplexity, args["filter"].(model.TensionFilter)), true

	case "Mutation.deleteUser":
		if e.complexity.Mutation.DeleteUser == nil {
			break
		}

		args, err := ec.field_Mutation_deleteUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteUser(childComplexity, args["filter"].(model.UserFilter)), true

	case "Mutation.deleteUserEvent":
		if e.complexity.Mutation.DeleteUserEvent == nil {
			break
		}

		args, err := ec.field_Mutation_deleteUserEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteUserEvent(childComplexity, args["filter"].(model.UserEventFilter)), true

	case "Mutation.deleteUserRights":
		if e.complexity.Mutation.DeleteUserRights == nil {
			break
		}

		args, err := ec.field_Mutation_deleteUserRights_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteUserRights(childComplexity, args["filter"].(model.UserRightsFilter)), true

	case "Mutation.deleteVote":
		if e.complexity.Mutation.DeleteVote == nil {
			break
		}

		args, err := ec.field_Mutation_deleteVote_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteVote(childComplexity, args["filter"].(model.VoteFilter)), true

	case "Mutation.updateBlob":
		if e.complexity.Mutation.UpdateBlob == nil {
			break
		}

		args, err := ec.field_Mutation_updateBlob_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateBlob(childComplexity, args["input"].(model.UpdateBlobInput)), true

	case "Mutation.updateComment":
		if e.complexity.Mutation.UpdateComment == nil {
			break
		}

		args, err := ec.field_Mutation_updateComment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateComment(childComplexity, args["input"].(model.UpdateCommentInput)), true

	case "Mutation.updateContract":
		if e.complexity.Mutation.UpdateContract == nil {
			break
		}

		args, err := ec.field_Mutation_updateContract_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateContract(childComplexity, args["input"].(model.UpdateContractInput)), true

	case "Mutation.updateEvent":
		if e.complexity.Mutation.UpdateEvent == nil {
			break
		}

		args, err := ec.field_Mutation_updateEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEvent(childComplexity, args["input"].(model.UpdateEventInput)), true

	case "Mutation.updateEventCount":
		if e.complexity.Mutation.UpdateEventCount == nil {
			break
		}

		args, err := ec.field_Mutation_updateEventCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEventCount(childComplexity, args["input"].(model.UpdateEventCountInput)), true

	case "Mutation.updateEventFragment":
		if e.complexity.Mutation.UpdateEventFragment == nil {
			break
		}

		args, err := ec.field_Mutation_updateEventFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEventFragment(childComplexity, args["input"].(model.UpdateEventFragmentInput)), true

	case "Mutation.updateLabel":
		if e.complexity.Mutation.UpdateLabel == nil {
			break
		}

		args, err := ec.field_Mutation_updateLabel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateLabel(childComplexity, args["input"].(model.UpdateLabelInput)), true

	case "Mutation.updateMandate":
		if e.complexity.Mutation.UpdateMandate == nil {
			break
		}

		args, err := ec.field_Mutation_updateMandate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMandate(childComplexity, args["input"].(model.UpdateMandateInput)), true

	case "Mutation.updateNode":
		if e.complexity.Mutation.UpdateNode == nil {
			break
		}

		args, err := ec.field_Mutation_updateNode_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateNode(childComplexity, args["input"].(model.UpdateNodeInput)), true

	case "Mutation.updateNodeFragment":
		if e.complexity.Mutation.UpdateNodeFragment == nil {
			break
		}

		args, err := ec.field_Mutation_updateNodeFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateNodeFragment(childComplexity, args["input"].(model.UpdateNodeFragmentInput)), true

	case "Mutation.updateNotif":
		if e.complexity.Mutation.UpdateNotif == nil {
			break
		}

		args, err := ec.field_Mutation_updateNotif_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateNotif(childComplexity, args["input"].(model.UpdateNotifInput)), true

	case "Mutation.updateOrgaAgg":
		if e.complexity.Mutation.UpdateOrgaAgg == nil {
			break
		}

		args, err := ec.field_Mutation_updateOrgaAgg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateOrgaAgg(childComplexity, args["input"].(model.UpdateOrgaAggInput)), true

	case "Mutation.updatePendingUser":
		if e.complexity.Mutation.UpdatePendingUser == nil {
			break
		}

		args, err := ec.field_Mutation_updatePendingUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePendingUser(childComplexity, args["input"].(model.UpdatePendingUserInput)), true

	case "Mutation.updatePost":
		if e.complexity.Mutation.UpdatePost == nil {
			break
		}

		args, err := ec.field_Mutation_updatePost_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePost(childComplexity, args["input"].(model.UpdatePostInput)), true

	case "Mutation.updateReaction":
		if e.complexity.Mutation.UpdateReaction == nil {
			break
		}

		args, err := ec.field_Mutation_updateReaction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateReaction(childComplexity, args["input"].(model.UpdateReactionInput)), true

	case "Mutation.updateRoleExt":
		if e.complexity.Mutation.UpdateRoleExt == nil {
			break
		}

		args, err := ec.field_Mutation_updateRoleExt_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateRoleExt(childComplexity, args["input"].(model.UpdateRoleExtInput)), true

	case "Mutation.updateTension":
		if e.complexity.Mutation.UpdateTension == nil {
			break
		}

		args, err := ec.field_Mutation_updateTension_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTension(childComplexity, args["input"].(model.UpdateTensionInput)), true

	case "Mutation.updateUser":
		if e.complexity.Mutation.UpdateUser == nil {
			break
		}

		args, err := ec.field_Mutation_updateUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUser(childComplexity, args["input"].(model.UpdateUserInput)), true

	case "Mutation.updateUserEvent":
		if e.complexity.Mutation.UpdateUserEvent == nil {
			break
		}

		args, err := ec.field_Mutation_updateUserEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUserEvent(childComplexity, args["input"].(model.UpdateUserEventInput)), true

	case "Mutation.updateUserRights":
		if e.complexity.Mutation.UpdateUserRights == nil {
			break
		}

		args, err := ec.field_Mutation_updateUserRights_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUserRights(childComplexity, args["input"].(model.UpdateUserRightsInput)), true

	case "Mutation.updateVote":
		if e.complexity.Mutation.UpdateVote == nil {
			break
		}

		args, err := ec.field_Mutation_updateVote_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateVote(childComplexity, args["input"].(model.UpdateVoteInput)), true

	case "Node.about":
		if e.complexity.Node.About == nil {
			break
		}

		return e.complexity.Node.About(childComplexity), true

	case "Node.children":
		if e.complexity.Node.Children == nil {
			break
		}

		args, err := ec.field_Node_children_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.Children(childComplexity, args["filter"].(*model.NodeFilter), args["order"].(*model.NodeOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Node.childrenAggregate":
		if e.complexity.Node.ChildrenAggregate == nil {
			break
		}

		args, err := ec.field_Node_childrenAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.ChildrenAggregate(childComplexity, args["filter"].(*model.NodeFilter)), true

	case "Node.color":
		if e.complexity.Node.Color == nil {
			break
		}

		return e.complexity.Node.Color(childComplexity), true

	case "Node.contracts":
		if e.complexity.Node.Contracts == nil {
			break
		}

		args, err := ec.field_Node_contracts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.Contracts(childComplexity, args["filter"].(*model.VoteFilter), args["order"].(*model.VoteOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Node.contractsAggregate":
		if e.complexity.Node.ContractsAggregate == nil {
			break
		}

		args, err := ec.field_Node_contractsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.ContractsAggregate(childComplexity, args["filter"].(*model.VoteFilter)), true

	case "Node.createdAt":
		if e.complexity.Node.CreatedAt == nil {
			break
		}

		return e.complexity.Node.CreatedAt(childComplexity), true

	case "Node.createdBy":
		if e.complexity.Node.CreatedBy == nil {
			break
		}

		args, err := ec.field_Node_createdBy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.CreatedBy(childComplexity, args["filter"].(*model.UserFilter)), true

	case "Node.events_history":
		if e.complexity.Node.EventsHistory == nil {
			break
		}

		args, err := ec.field_Node_events_history_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.EventsHistory(childComplexity, args["filter"].(*model.EventFilter), args["order"].(*model.EventOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Node.events_historyAggregate":
		if e.complexity.Node.EventsHistoryAggregate == nil {
			break
		}

		args, err := ec.field_Node_events_historyAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.EventsHistoryAggregate(childComplexity, args["filter"].(*model.EventFilter)), true

	case "Node.first_link":
		if e.complexity.Node.FirstLink == nil {
			break
		}

		args, err := ec.field_Node_first_link_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.FirstLink(childComplexity, args["filter"].(*model.UserFilter)), true

	case "Node.guestCanCreateTension":
		if e.complexity.Node.GuestCanCreateTension == nil {
			break
		}

		return e.complexity.Node.GuestCanCreateTension(childComplexity), true

	case "Node.id":
		if e.complexity.Node.ID == nil {
			break
		}

		return e.complexity.Node.ID(childComplexity), true

	case "Node.isArchived":
		if e.complexity.Node.IsArchived == nil {
			break
		}

		return e.complexity.Node.IsArchived(childComplexity), true

	case "Node.isPersonal":
		if e.complexity.Node.IsPersonal == nil {
			break
		}

		return e.complexity.Node.IsPersonal(childComplexity), true

	case "Node.isRoot":
		if e.complexity.Node.IsRoot == nil {
			break
		}

		return e.complexity.Node.IsRoot(childComplexity), true

	case "Node.labels":
		if e.complexity.Node.Labels == nil {
			break
		}

		args, err := ec.field_Node_labels_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.Labels(childComplexity, args["filter"].(*model.LabelFilter), args["order"].(*model.LabelOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Node.labelsAggregate":
		if e.complexity.Node.LabelsAggregate == nil {
			break
		}

		args, err := ec.field_Node_labelsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.LabelsAggregate(childComplexity, args["filter"].(*model.LabelFilter)), true

	case "Node.mode":
		if e.complexity.Node.Mode == nil {
			break
		}

		return e.complexity.Node.Mode(childComplexity), true

	case "Node.name":
		if e.complexity.Node.Name == nil {
			break
		}

		return e.complexity.Node.Name(childComplexity), true

	case "Node.nameid":
		if e.complexity.Node.Nameid == nil {
			break
		}

		return e.complexity.Node.Nameid(childComplexity), true

	case "Node.orga_agg":
		if e.complexity.Node.OrgaAgg == nil {
			break
		}

		args, err := ec.field_Node_orga_agg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.OrgaAgg(childComplexity, args["filter"].(*model.OrgaAggFilter)), true

	case "Node.parent":
		if e.complexity.Node.Parent == nil {
			break
		}

		args, err := ec.field_Node_parent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.Parent(childComplexity, args["filter"].(*model.NodeFilter)), true

	case "Node.rights":
		if e.complexity.Node.Rights == nil {
			break
		}

		return e.complexity.Node.Rights(childComplexity), true

	case "Node.role_ext":
		if e.complexity.Node.RoleExt == nil {
			break
		}

		args, err := ec.field_Node_role_ext_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.RoleExt(childComplexity, args["filter"].(*model.RoleExtFilter)), true

	case "Node.role_type":
		if e.complexity.Node.RoleType == nil {
			break
		}

		return e.complexity.Node.RoleType(childComplexity), true

	case "Node.roles":
		if e.complexity.Node.Roles == nil {
			break
		}

		args, err := ec.field_Node_roles_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.Roles(childComplexity, args["filter"].(*model.RoleExtFilter), args["order"].(*model.RoleExtOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Node.rolesAggregate":
		if e.complexity.Node.RolesAggregate == nil {
			break
		}

		args, err := ec.field_Node_rolesAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.RolesAggregate(childComplexity, args["filter"].(*model.RoleExtFilter)), true

	case "Node.rootnameid":
		if e.complexity.Node.Rootnameid == nil {
			break
		}

		return e.complexity.Node.Rootnameid(childComplexity), true

	case "Node.second_link":
		if e.complexity.Node.SecondLink == nil {
			break
		}

		args, err := ec.field_Node_second_link_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.SecondLink(childComplexity, args["filter"].(*model.UserFilter)), true

	case "Node.skills":
		if e.complexity.Node.Skills == nil {
			break
		}

		return e.complexity.Node.Skills(childComplexity), true

	case "Node.source":
		if e.complexity.Node.Source == nil {
			break
		}

		args, err := ec.field_Node_source_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.Source(childComplexity, args["filter"].(*model.BlobFilter)), true

	case "Node.tensions_in":
		if e.complexity.Node.TensionsIn == nil {
			break
		}

		args, err := ec.field_Node_tensions_in_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.TensionsIn(childComplexity, args["filter"].(*model.TensionFilter), args["order"].(*model.TensionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Node.tensions_inAggregate":
		if e.complexity.Node.TensionsInAggregate == nil {
			break
		}

		args, err := ec.field_Node_tensions_inAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.TensionsInAggregate(childComplexity, args["filter"].(*model.TensionFilter)), true

	case "Node.tensions_out":
		if e.complexity.Node.TensionsOut == nil {
			break
		}

		args, err := ec.field_Node_tensions_out_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.TensionsOut(childComplexity, args["filter"].(*model.TensionFilter), args["order"].(*model.TensionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Node.tensions_outAggregate":
		if e.complexity.Node.TensionsOutAggregate == nil {
			break
		}

		args, err := ec.field_Node_tensions_outAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.TensionsOutAggregate(childComplexity, args["filter"].(*model.TensionFilter)), true

	case "Node.type_":
		if e.complexity.Node.Type == nil {
			break
		}

		return e.complexity.Node.Type(childComplexity), true

	case "Node.updatedAt":
		if e.complexity.Node.UpdatedAt == nil {
			break
		}

		return e.complexity.Node.UpdatedAt(childComplexity), true

	case "Node.userCanJoin":
		if e.complexity.Node.UserCanJoin == nil {
			break
		}

		return e.complexity.Node.UserCanJoin(childComplexity), true

	case "Node.visibility":
		if e.complexity.Node.Visibility == nil {
			break
		}

		return e.complexity.Node.Visibility(childComplexity), true

	case "Node.watchers":
		if e.complexity.Node.Watchers == nil {
			break
		}

		args, err := ec.field_Node_watchers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.Watchers(childComplexity, args["filter"].(*model.UserFilter), args["order"].(*model.UserOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Node.watchersAggregate":
		if e.complexity.Node.WatchersAggregate == nil {
			break
		}

		args, err := ec.field_Node_watchersAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Node.WatchersAggregate(childComplexity, args["filter"].(*model.UserFilter)), true

	case "NodeAggregateResult.aboutMax":
		if e.complexity.NodeAggregateResult.AboutMax == nil {
			break
		}

		return e.complexity.NodeAggregateResult.AboutMax(childComplexity), true

	case "NodeAggregateResult.aboutMin":
		if e.complexity.NodeAggregateResult.AboutMin == nil {
			break
		}

		return e.complexity.NodeAggregateResult.AboutMin(childComplexity), true

	case "NodeAggregateResult.colorMax":
		if e.complexity.NodeAggregateResult.ColorMax == nil {
			break
		}

		return e.complexity.NodeAggregateResult.ColorMax(childComplexity), true

	case "NodeAggregateResult.colorMin":
		if e.complexity.NodeAggregateResult.ColorMin == nil {
			break
		}

		return e.complexity.NodeAggregateResult.ColorMin(childComplexity), true

	case "NodeAggregateResult.count":
		if e.complexity.NodeAggregateResult.Count == nil {
			break
		}

		return e.complexity.NodeAggregateResult.Count(childComplexity), true

	case "NodeAggregateResult.createdAtMax":
		if e.complexity.NodeAggregateResult.CreatedAtMax == nil {
			break
		}

		return e.complexity.NodeAggregateResult.CreatedAtMax(childComplexity), true

	case "NodeAggregateResult.createdAtMin":
		if e.complexity.NodeAggregateResult.CreatedAtMin == nil {
			break
		}

		return e.complexity.NodeAggregateResult.CreatedAtMin(childComplexity), true

	case "NodeAggregateResult.nameMax":
		if e.complexity.NodeAggregateResult.NameMax == nil {
			break
		}

		return e.complexity.NodeAggregateResult.NameMax(childComplexity), true

	case "NodeAggregateResult.nameMin":
		if e.complexity.NodeAggregateResult.NameMin == nil {
			break
		}

		return e.complexity.NodeAggregateResult.NameMin(childComplexity), true

	case "NodeAggregateResult.nameidMax":
		if e.complexity.NodeAggregateResult.NameidMax == nil {
			break
		}

		return e.complexity.NodeAggregateResult.NameidMax(childComplexity), true

	case "NodeAggregateResult.nameidMin":
		if e.complexity.NodeAggregateResult.NameidMin == nil {
			break
		}

		return e.complexity.NodeAggregateResult.NameidMin(childComplexity), true

	case "NodeAggregateResult.rightsAvg":
		if e.complexity.NodeAggregateResult.RightsAvg == nil {
			break
		}

		return e.complexity.NodeAggregateResult.RightsAvg(childComplexity), true

	case "NodeAggregateResult.rightsMax":
		if e.complexity.NodeAggregateResult.RightsMax == nil {
			break
		}

		return e.complexity.NodeAggregateResult.RightsMax(childComplexity), true

	case "NodeAggregateResult.rightsMin":
		if e.complexity.NodeAggregateResult.RightsMin == nil {
			break
		}

		return e.complexity.NodeAggregateResult.RightsMin(childComplexity), true

	case "NodeAggregateResult.rightsSum":
		if e.complexity.NodeAggregateResult.RightsSum == nil {
			break
		}

		return e.complexity.NodeAggregateResult.RightsSum(childComplexity), true

	case "NodeAggregateResult.rootnameidMax":
		if e.complexity.NodeAggregateResult.RootnameidMax == nil {
			break
		}

		return e.complexity.NodeAggregateResult.RootnameidMax(childComplexity), true

	case "NodeAggregateResult.rootnameidMin":
		if e.complexity.NodeAggregateResult.RootnameidMin == nil {
			break
		}

		return e.complexity.NodeAggregateResult.RootnameidMin(childComplexity), true

	case "NodeAggregateResult.updatedAtMax":
		if e.complexity.NodeAggregateResult.UpdatedAtMax == nil {
			break
		}

		return e.complexity.NodeAggregateResult.UpdatedAtMax(childComplexity), true

	case "NodeAggregateResult.updatedAtMin":
		if e.complexity.NodeAggregateResult.UpdatedAtMin == nil {
			break
		}

		return e.complexity.NodeAggregateResult.UpdatedAtMin(childComplexity), true

	case "NodeFragment.about":
		if e.complexity.NodeFragment.About == nil {
			break
		}

		return e.complexity.NodeFragment.About(childComplexity), true

	case "NodeFragment.color":
		if e.complexity.NodeFragment.Color == nil {
			break
		}

		return e.complexity.NodeFragment.Color(childComplexity), true

	case "NodeFragment.first_link":
		if e.complexity.NodeFragment.FirstLink == nil {
			break
		}

		return e.complexity.NodeFragment.FirstLink(childComplexity), true

	case "NodeFragment.id":
		if e.complexity.NodeFragment.ID == nil {
			break
		}

		return e.complexity.NodeFragment.ID(childComplexity), true

	case "NodeFragment.mandate":
		if e.complexity.NodeFragment.Mandate == nil {
			break
		}

		args, err := ec.field_NodeFragment_mandate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.NodeFragment.Mandate(childComplexity, args["filter"].(*model.MandateFilter)), true

	case "NodeFragment.mode":
		if e.complexity.NodeFragment.Mode == nil {
			break
		}

		return e.complexity.NodeFragment.Mode(childComplexity), true

	case "NodeFragment.name":
		if e.complexity.NodeFragment.Name == nil {
			break
		}

		return e.complexity.NodeFragment.Name(childComplexity), true

	case "NodeFragment.nameid":
		if e.complexity.NodeFragment.Nameid == nil {
			break
		}

		return e.complexity.NodeFragment.Nameid(childComplexity), true

	case "NodeFragment.role_ext":
		if e.complexity.NodeFragment.RoleExt == nil {
			break
		}

		return e.complexity.NodeFragment.RoleExt(childComplexity), true

	case "NodeFragment.role_type":
		if e.complexity.NodeFragment.RoleType == nil {
			break
		}

		return e.complexity.NodeFragment.RoleType(childComplexity), true

	case "NodeFragment.second_link":
		if e.complexity.NodeFragment.SecondLink == nil {
			break
		}

		return e.complexity.NodeFragment.SecondLink(childComplexity), true

	case "NodeFragment.skills":
		if e.complexity.NodeFragment.Skills == nil {
			break
		}

		return e.complexity.NodeFragment.Skills(childComplexity), true

	case "NodeFragment.type_":
		if e.complexity.NodeFragment.Type == nil {
			break
		}

		return e.complexity.NodeFragment.Type(childComplexity), true

	case "NodeFragment.visibility":
		if e.complexity.NodeFragment.Visibility == nil {
			break
		}

		return e.complexity.NodeFragment.Visibility(childComplexity), true

	case "NodeFragmentAggregateResult.aboutMax":
		if e.complexity.NodeFragmentAggregateResult.AboutMax == nil {
			break
		}

		return e.complexity.NodeFragmentAggregateResult.AboutMax(childComplexity), true

	case "NodeFragmentAggregateResult.aboutMin":
		if e.complexity.NodeFragmentAggregateResult.AboutMin == nil {
			break
		}

		return e.complexity.NodeFragmentAggregateResult.AboutMin(childComplexity), true

	case "NodeFragmentAggregateResult.colorMax":
		if e.complexity.NodeFragmentAggregateResult.ColorMax == nil {
			break
		}

		return e.complexity.NodeFragmentAggregateResult.ColorMax(childComplexity), true

	case "NodeFragmentAggregateResult.colorMin":
		if e.complexity.NodeFragmentAggregateResult.ColorMin == nil {
			break
		}

		return e.complexity.NodeFragmentAggregateResult.ColorMin(childComplexity), true

	case "NodeFragmentAggregateResult.count":
		if e.complexity.NodeFragmentAggregateResult.Count == nil {
			break
		}

		return e.complexity.NodeFragmentAggregateResult.Count(childComplexity), true

	case "NodeFragmentAggregateResult.first_linkMax":
		if e.complexity.NodeFragmentAggregateResult.FirstLinkMax == nil {
			break
		}

		return e.complexity.NodeFragmentAggregateResult.FirstLinkMax(childComplexity), true

	case "NodeFragmentAggregateResult.first_linkMin":
		if e.complexity.NodeFragmentAggregateResult.FirstLinkMin == nil {
			break
		}

		return e.complexity.NodeFragmentAggregateResult.FirstLinkMin(childComplexity), true

	case "NodeFragmentAggregateResult.nameMax":
		if e.complexity.NodeFragmentAggregateResult.NameMax == nil {
			break
		}

		return e.complexity.NodeFragmentAggregateResult.NameMax(childComplexity), true

	case "NodeFragmentAggregateResult.nameMin":
		if e.complexity.NodeFragmentAggregateResult.NameMin == nil {
			break
		}

		return e.complexity.NodeFragmentAggregateResult.NameMin(childComplexity), true

	case "NodeFragmentAggregateResult.nameidMax":
		if e.complexity.NodeFragmentAggregateResult.NameidMax == nil {
			break
		}

		return e.complexity.NodeFragmentAggregateResult.NameidMax(childComplexity), true

	case "NodeFragmentAggregateResult.nameidMin":
		if e.complexity.NodeFragmentAggregateResult.NameidMin == nil {
			break
		}

		return e.complexity.NodeFragmentAggregateResult.NameidMin(childComplexity), true

	case "NodeFragmentAggregateResult.role_extMax":
		if e.complexity.NodeFragmentAggregateResult.RoleExtMax == nil {
			break
		}

		return e.complexity.NodeFragmentAggregateResult.RoleExtMax(childComplexity), true

	case "NodeFragmentAggregateResult.role_extMin":
		if e.complexity.NodeFragmentAggregateResult.RoleExtMin == nil {
			break
		}

		return e.complexity.NodeFragmentAggregateResult.RoleExtMin(childComplexity), true

	case "NodeFragmentAggregateResult.second_linkMax":
		if e.complexity.NodeFragmentAggregateResult.SecondLinkMax == nil {
			break
		}

		return e.complexity.NodeFragmentAggregateResult.SecondLinkMax(childComplexity), true

	case "NodeFragmentAggregateResult.second_linkMin":
		if e.complexity.NodeFragmentAggregateResult.SecondLinkMin == nil {
			break
		}

		return e.complexity.NodeFragmentAggregateResult.SecondLinkMin(childComplexity), true

	case "Notif.contract":
		if e.complexity.Notif.Contract == nil {
			break
		}

		args, err := ec.field_Notif_contract_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Notif.Contract(childComplexity, args["filter"].(*model.ContractFilter)), true

	case "Notif.createdAt":
		if e.complexity.Notif.CreatedAt == nil {
			break
		}

		return e.complexity.Notif.CreatedAt(childComplexity), true

	case "Notif.createdBy":
		if e.complexity.Notif.CreatedBy == nil {
			break
		}

		args, err := ec.field_Notif_createdBy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Notif.CreatedBy(childComplexity, args["filter"].(*model.UserFilter)), true

	case "Notif.id":
		if e.complexity.Notif.ID == nil {
			break
		}

		return e.complexity.Notif.ID(childComplexity), true

	case "Notif.link":
		if e.complexity.Notif.Link == nil {
			break
		}

		return e.complexity.Notif.Link(childComplexity), true

	case "Notif.message":
		if e.complexity.Notif.Message == nil {
			break
		}

		return e.complexity.Notif.Message(childComplexity), true

	case "Notif.tension_":
		if e.complexity.Notif.Tension == nil {
			break
		}

		args, err := ec.field_Notif_tension__args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Notif.Tension(childComplexity, args["filter"].(*model.TensionFilter)), true

	case "Notif.updatedAt":
		if e.complexity.Notif.UpdatedAt == nil {
			break
		}

		return e.complexity.Notif.UpdatedAt(childComplexity), true

	case "NotifAggregateResult.count":
		if e.complexity.NotifAggregateResult.Count == nil {
			break
		}

		return e.complexity.NotifAggregateResult.Count(childComplexity), true

	case "NotifAggregateResult.createdAtMax":
		if e.complexity.NotifAggregateResult.CreatedAtMax == nil {
			break
		}

		return e.complexity.NotifAggregateResult.CreatedAtMax(childComplexity), true

	case "NotifAggregateResult.createdAtMin":
		if e.complexity.NotifAggregateResult.CreatedAtMin == nil {
			break
		}

		return e.complexity.NotifAggregateResult.CreatedAtMin(childComplexity), true

	case "NotifAggregateResult.linkMax":
		if e.complexity.NotifAggregateResult.LinkMax == nil {
			break
		}

		return e.complexity.NotifAggregateResult.LinkMax(childComplexity), true

	case "NotifAggregateResult.linkMin":
		if e.complexity.NotifAggregateResult.LinkMin == nil {
			break
		}

		return e.complexity.NotifAggregateResult.LinkMin(childComplexity), true

	case "NotifAggregateResult.messageMax":
		if e.complexity.NotifAggregateResult.MessageMax == nil {
			break
		}

		return e.complexity.NotifAggregateResult.MessageMax(childComplexity), true

	case "NotifAggregateResult.messageMin":
		if e.complexity.NotifAggregateResult.MessageMin == nil {
			break
		}

		return e.complexity.NotifAggregateResult.MessageMin(childComplexity), true

	case "NotifAggregateResult.updatedAtMax":
		if e.complexity.NotifAggregateResult.UpdatedAtMax == nil {
			break
		}

		return e.complexity.NotifAggregateResult.UpdatedAtMax(childComplexity), true

	case "NotifAggregateResult.updatedAtMin":
		if e.complexity.NotifAggregateResult.UpdatedAtMin == nil {
			break
		}

		return e.complexity.NotifAggregateResult.UpdatedAtMin(childComplexity), true

	case "OrgaAgg.n_guests":
		if e.complexity.OrgaAgg.NGuests == nil {
			break
		}

		return e.complexity.OrgaAgg.NGuests(childComplexity), true

	case "OrgaAgg.n_members":
		if e.complexity.OrgaAgg.NMembers == nil {
			break
		}

		return e.complexity.OrgaAgg.NMembers(childComplexity), true

	case "OrgaAggAggregateResult.count":
		if e.complexity.OrgaAggAggregateResult.Count == nil {
			break
		}

		return e.complexity.OrgaAggAggregateResult.Count(childComplexity), true

	case "OrgaAggAggregateResult.n_guestsAvg":
		if e.complexity.OrgaAggAggregateResult.NGuestsAvg == nil {
			break
		}

		return e.complexity.OrgaAggAggregateResult.NGuestsAvg(childComplexity), true

	case "OrgaAggAggregateResult.n_guestsMax":
		if e.complexity.OrgaAggAggregateResult.NGuestsMax == nil {
			break
		}

		return e.complexity.OrgaAggAggregateResult.NGuestsMax(childComplexity), true

	case "OrgaAggAggregateResult.n_guestsMin":
		if e.complexity.OrgaAggAggregateResult.NGuestsMin == nil {
			break
		}

		return e.complexity.OrgaAggAggregateResult.NGuestsMin(childComplexity), true

	case "OrgaAggAggregateResult.n_guestsSum":
		if e.complexity.OrgaAggAggregateResult.NGuestsSum == nil {
			break
		}

		return e.complexity.OrgaAggAggregateResult.NGuestsSum(childComplexity), true

	case "OrgaAggAggregateResult.n_membersAvg":
		if e.complexity.OrgaAggAggregateResult.NMembersAvg == nil {
			break
		}

		return e.complexity.OrgaAggAggregateResult.NMembersAvg(childComplexity), true

	case "OrgaAggAggregateResult.n_membersMax":
		if e.complexity.OrgaAggAggregateResult.NMembersMax == nil {
			break
		}

		return e.complexity.OrgaAggAggregateResult.NMembersMax(childComplexity), true

	case "OrgaAggAggregateResult.n_membersMin":
		if e.complexity.OrgaAggAggregateResult.NMembersMin == nil {
			break
		}

		return e.complexity.OrgaAggAggregateResult.NMembersMin(childComplexity), true

	case "OrgaAggAggregateResult.n_membersSum":
		if e.complexity.OrgaAggAggregateResult.NMembersSum == nil {
			break
		}

		return e.complexity.OrgaAggAggregateResult.NMembersSum(childComplexity), true

	case "PendingUser.contracts":
		if e.complexity.PendingUser.Contracts == nil {
			break
		}

		args, err := ec.field_PendingUser_contracts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.PendingUser.Contracts(childComplexity, args["filter"].(*model.ContractFilter), args["order"].(*model.ContractOrder), args["first"].(*int), args["offset"].(*int)), true

	case "PendingUser.contractsAggregate":
		if e.complexity.PendingUser.ContractsAggregate == nil {
			break
		}

		args, err := ec.field_PendingUser_contractsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.PendingUser.ContractsAggregate(childComplexity, args["filter"].(*model.ContractFilter)), true

	case "PendingUser.email":
		if e.complexity.PendingUser.Email == nil {
			break
		}

		return e.complexity.PendingUser.Email(childComplexity), true

	case "PendingUser.email_token":
		if e.complexity.PendingUser.EmailToken == nil {
			break
		}

		return e.complexity.PendingUser.EmailToken(childComplexity), true

	case "PendingUser.id":
		if e.complexity.PendingUser.ID == nil {
			break
		}

		return e.complexity.PendingUser.ID(childComplexity), true

	case "PendingUser.password":
		if e.complexity.PendingUser.Password == nil {
			break
		}

		return e.complexity.PendingUser.Password(childComplexity), true

	case "PendingUser.subscribe":
		if e.complexity.PendingUser.Subscribe == nil {
			break
		}

		return e.complexity.PendingUser.Subscribe(childComplexity), true

	case "PendingUser.token":
		if e.complexity.PendingUser.Token == nil {
			break
		}

		return e.complexity.PendingUser.Token(childComplexity), true

	case "PendingUser.updatedAt":
		if e.complexity.PendingUser.UpdatedAt == nil {
			break
		}

		return e.complexity.PendingUser.UpdatedAt(childComplexity), true

	case "PendingUser.username":
		if e.complexity.PendingUser.Username == nil {
			break
		}

		return e.complexity.PendingUser.Username(childComplexity), true

	case "PendingUserAggregateResult.count":
		if e.complexity.PendingUserAggregateResult.Count == nil {
			break
		}

		return e.complexity.PendingUserAggregateResult.Count(childComplexity), true

	case "PendingUserAggregateResult.emailMax":
		if e.complexity.PendingUserAggregateResult.EmailMax == nil {
			break
		}

		return e.complexity.PendingUserAggregateResult.EmailMax(childComplexity), true

	case "PendingUserAggregateResult.emailMin":
		if e.complexity.PendingUserAggregateResult.EmailMin == nil {
			break
		}

		return e.complexity.PendingUserAggregateResult.EmailMin(childComplexity), true

	case "PendingUserAggregateResult.email_tokenMax":
		if e.complexity.PendingUserAggregateResult.EmailTokenMax == nil {
			break
		}

		return e.complexity.PendingUserAggregateResult.EmailTokenMax(childComplexity), true

	case "PendingUserAggregateResult.email_tokenMin":
		if e.complexity.PendingUserAggregateResult.EmailTokenMin == nil {
			break
		}

		return e.complexity.PendingUserAggregateResult.EmailTokenMin(childComplexity), true

	case "PendingUserAggregateResult.passwordMax":
		if e.complexity.PendingUserAggregateResult.PasswordMax == nil {
			break
		}

		return e.complexity.PendingUserAggregateResult.PasswordMax(childComplexity), true

	case "PendingUserAggregateResult.passwordMin":
		if e.complexity.PendingUserAggregateResult.PasswordMin == nil {
			break
		}

		return e.complexity.PendingUserAggregateResult.PasswordMin(childComplexity), true

	case "PendingUserAggregateResult.tokenMax":
		if e.complexity.PendingUserAggregateResult.TokenMax == nil {
			break
		}

		return e.complexity.PendingUserAggregateResult.TokenMax(childComplexity), true

	case "PendingUserAggregateResult.tokenMin":
		if e.complexity.PendingUserAggregateResult.TokenMin == nil {
			break
		}

		return e.complexity.PendingUserAggregateResult.TokenMin(childComplexity), true

	case "PendingUserAggregateResult.updatedAtMax":
		if e.complexity.PendingUserAggregateResult.UpdatedAtMax == nil {
			break
		}

		return e.complexity.PendingUserAggregateResult.UpdatedAtMax(childComplexity), true

	case "PendingUserAggregateResult.updatedAtMin":
		if e.complexity.PendingUserAggregateResult.UpdatedAtMin == nil {
			break
		}

		return e.complexity.PendingUserAggregateResult.UpdatedAtMin(childComplexity), true

	case "PendingUserAggregateResult.usernameMax":
		if e.complexity.PendingUserAggregateResult.UsernameMax == nil {
			break
		}

		return e.complexity.PendingUserAggregateResult.UsernameMax(childComplexity), true

	case "PendingUserAggregateResult.usernameMin":
		if e.complexity.PendingUserAggregateResult.UsernameMin == nil {
			break
		}

		return e.complexity.PendingUserAggregateResult.UsernameMin(childComplexity), true

	case "Point.latitude":
		if e.complexity.Point.Latitude == nil {
			break
		}

		return e.complexity.Point.Latitude(childComplexity), true

	case "Point.longitude":
		if e.complexity.Point.Longitude == nil {
			break
		}

		return e.complexity.Point.Longitude(childComplexity), true

	case "PointList.points":
		if e.complexity.PointList.Points == nil {
			break
		}

		return e.complexity.PointList.Points(childComplexity), true

	case "Polygon.coordinates":
		if e.complexity.Polygon.Coordinates == nil {
			break
		}

		return e.complexity.Polygon.Coordinates(childComplexity), true

	case "Post.createdAt":
		if e.complexity.Post.CreatedAt == nil {
			break
		}

		return e.complexity.Post.CreatedAt(childComplexity), true

	case "Post.createdBy":
		if e.complexity.Post.CreatedBy == nil {
			break
		}

		args, err := ec.field_Post_createdBy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Post.CreatedBy(childComplexity, args["filter"].(*model.UserFilter)), true

	case "Post.id":
		if e.complexity.Post.ID == nil {
			break
		}

		return e.complexity.Post.ID(childComplexity), true

	case "Post.message":
		if e.complexity.Post.Message == nil {
			break
		}

		return e.complexity.Post.Message(childComplexity), true

	case "Post.updatedAt":
		if e.complexity.Post.UpdatedAt == nil {
			break
		}

		return e.complexity.Post.UpdatedAt(childComplexity), true

	case "PostAggregateResult.count":
		if e.complexity.PostAggregateResult.Count == nil {
			break
		}

		return e.complexity.PostAggregateResult.Count(childComplexity), true

	case "PostAggregateResult.createdAtMax":
		if e.complexity.PostAggregateResult.CreatedAtMax == nil {
			break
		}

		return e.complexity.PostAggregateResult.CreatedAtMax(childComplexity), true

	case "PostAggregateResult.createdAtMin":
		if e.complexity.PostAggregateResult.CreatedAtMin == nil {
			break
		}

		return e.complexity.PostAggregateResult.CreatedAtMin(childComplexity), true

	case "PostAggregateResult.messageMax":
		if e.complexity.PostAggregateResult.MessageMax == nil {
			break
		}

		return e.complexity.PostAggregateResult.MessageMax(childComplexity), true

	case "PostAggregateResult.messageMin":
		if e.complexity.PostAggregateResult.MessageMin == nil {
			break
		}

		return e.complexity.PostAggregateResult.MessageMin(childComplexity), true

	case "PostAggregateResult.updatedAtMax":
		if e.complexity.PostAggregateResult.UpdatedAtMax == nil {
			break
		}

		return e.complexity.PostAggregateResult.UpdatedAtMax(childComplexity), true

	case "PostAggregateResult.updatedAtMin":
		if e.complexity.PostAggregateResult.UpdatedAtMin == nil {
			break
		}

		return e.complexity.PostAggregateResult.UpdatedAtMin(childComplexity), true

	case "Query.aggregateBlob":
		if e.complexity.Query.AggregateBlob == nil {
			break
		}

		args, err := ec.field_Query_aggregateBlob_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateBlob(childComplexity, args["filter"].(*model.BlobFilter)), true

	case "Query.aggregateComment":
		if e.complexity.Query.AggregateComment == nil {
			break
		}

		args, err := ec.field_Query_aggregateComment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateComment(childComplexity, args["filter"].(*model.CommentFilter)), true

	case "Query.aggregateContract":
		if e.complexity.Query.AggregateContract == nil {
			break
		}

		args, err := ec.field_Query_aggregateContract_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateContract(childComplexity, args["filter"].(*model.ContractFilter)), true

	case "Query.aggregateEvent":
		if e.complexity.Query.AggregateEvent == nil {
			break
		}

		args, err := ec.field_Query_aggregateEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateEvent(childComplexity, args["filter"].(*model.EventFilter)), true

	case "Query.aggregateEventCount":
		if e.complexity.Query.AggregateEventCount == nil {
			break
		}

		args, err := ec.field_Query_aggregateEventCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateEventCount(childComplexity, args["filter"].(*model.EventCountFilter)), true

	case "Query.aggregateEventFragment":
		if e.complexity.Query.AggregateEventFragment == nil {
			break
		}

		args, err := ec.field_Query_aggregateEventFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateEventFragment(childComplexity, args["filter"].(*model.EventFragmentFilter)), true

	case "Query.aggregateLabel":
		if e.complexity.Query.AggregateLabel == nil {
			break
		}

		args, err := ec.field_Query_aggregateLabel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateLabel(childComplexity, args["filter"].(*model.LabelFilter)), true

	case "Query.aggregateMandate":
		if e.complexity.Query.AggregateMandate == nil {
			break
		}

		args, err := ec.field_Query_aggregateMandate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateMandate(childComplexity, args["filter"].(*model.MandateFilter)), true

	case "Query.aggregateNode":
		if e.complexity.Query.AggregateNode == nil {
			break
		}

		args, err := ec.field_Query_aggregateNode_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateNode(childComplexity, args["filter"].(*model.NodeFilter)), true

	case "Query.aggregateNodeFragment":
		if e.complexity.Query.AggregateNodeFragment == nil {
			break
		}

		args, err := ec.field_Query_aggregateNodeFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateNodeFragment(childComplexity, args["filter"].(*model.NodeFragmentFilter)), true

	case "Query.aggregateNotif":
		if e.complexity.Query.AggregateNotif == nil {
			break
		}

		args, err := ec.field_Query_aggregateNotif_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateNotif(childComplexity, args["filter"].(*model.NotifFilter)), true

	case "Query.aggregateOrgaAgg":
		if e.complexity.Query.AggregateOrgaAgg == nil {
			break
		}

		args, err := ec.field_Query_aggregateOrgaAgg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateOrgaAgg(childComplexity, args["filter"].(*model.OrgaAggFilter)), true

	case "Query.aggregatePendingUser":
		if e.complexity.Query.AggregatePendingUser == nil {
			break
		}

		args, err := ec.field_Query_aggregatePendingUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregatePendingUser(childComplexity, args["filter"].(*model.PendingUserFilter)), true

	case "Query.aggregatePost":
		if e.complexity.Query.AggregatePost == nil {
			break
		}

		args, err := ec.field_Query_aggregatePost_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregatePost(childComplexity, args["filter"].(*model.PostFilter)), true

	case "Query.aggregateReaction":
		if e.complexity.Query.AggregateReaction == nil {
			break
		}

		args, err := ec.field_Query_aggregateReaction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateReaction(childComplexity, args["filter"].(*model.ReactionFilter)), true

	case "Query.aggregateRoleExt":
		if e.complexity.Query.AggregateRoleExt == nil {
			break
		}

		args, err := ec.field_Query_aggregateRoleExt_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateRoleExt(childComplexity, args["filter"].(*model.RoleExtFilter)), true

	case "Query.aggregateTension":
		if e.complexity.Query.AggregateTension == nil {
			break
		}

		args, err := ec.field_Query_aggregateTension_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateTension(childComplexity, args["filter"].(*model.TensionFilter)), true

	case "Query.aggregateUser":
		if e.complexity.Query.AggregateUser == nil {
			break
		}

		args, err := ec.field_Query_aggregateUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateUser(childComplexity, args["filter"].(*model.UserFilter)), true

	case "Query.aggregateUserEvent":
		if e.complexity.Query.AggregateUserEvent == nil {
			break
		}

		args, err := ec.field_Query_aggregateUserEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateUserEvent(childComplexity, args["filter"].(*model.UserEventFilter)), true

	case "Query.aggregateUserRights":
		if e.complexity.Query.AggregateUserRights == nil {
			break
		}

		args, err := ec.field_Query_aggregateUserRights_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateUserRights(childComplexity, args["filter"].(*model.UserRightsFilter)), true

	case "Query.aggregateVote":
		if e.complexity.Query.AggregateVote == nil {
			break
		}

		args, err := ec.field_Query_aggregateVote_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateVote(childComplexity, args["filter"].(*model.VoteFilter)), true

	case "Query.getBlob":
		if e.complexity.Query.GetBlob == nil {
			break
		}

		args, err := ec.field_Query_getBlob_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetBlob(childComplexity, args["id"].(string)), true

	case "Query.getComment":
		if e.complexity.Query.GetComment == nil {
			break
		}

		args, err := ec.field_Query_getComment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetComment(childComplexity, args["id"].(string)), true

	case "Query.getContract":
		if e.complexity.Query.GetContract == nil {
			break
		}

		args, err := ec.field_Query_getContract_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetContract(childComplexity, args["id"].(*string), args["contractid"].(*string)), true

	case "Query.getEvent":
		if e.complexity.Query.GetEvent == nil {
			break
		}

		args, err := ec.field_Query_getEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetEvent(childComplexity, args["id"].(string)), true

	case "Query.getLabel":
		if e.complexity.Query.GetLabel == nil {
			break
		}

		args, err := ec.field_Query_getLabel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetLabel(childComplexity, args["id"].(string)), true

	case "Query.getMandate":
		if e.complexity.Query.GetMandate == nil {
			break
		}

		args, err := ec.field_Query_getMandate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMandate(childComplexity, args["id"].(string)), true

	case "Query.getNode":
		if e.complexity.Query.GetNode == nil {
			break
		}

		args, err := ec.field_Query_getNode_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetNode(childComplexity, args["id"].(*string), args["nameid"].(*string)), true

	case "Query.getNodeFragment":
		if e.complexity.Query.GetNodeFragment == nil {
			break
		}

		args, err := ec.field_Query_getNodeFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetNodeFragment(childComplexity, args["id"].(string)), true

	case "Query.getNotif":
		if e.complexity.Query.GetNotif == nil {
			break
		}

		args, err := ec.field_Query_getNotif_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetNotif(childComplexity, args["id"].(string)), true

	case "Query.getPendingUser":
		if e.complexity.Query.GetPendingUser == nil {
			break
		}

		args, err := ec.field_Query_getPendingUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetPendingUser(childComplexity, args["id"].(*string), args["username"].(*string), args["email"].(*string)), true

	case "Query.getPost":
		if e.complexity.Query.GetPost == nil {
			break
		}

		args, err := ec.field_Query_getPost_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetPost(childComplexity, args["id"].(string)), true

	case "Query.getReaction":
		if e.complexity.Query.GetReaction == nil {
			break
		}

		args, err := ec.field_Query_getReaction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetReaction(childComplexity, args["id"].(*string), args["reactionid"].(*string)), true

	case "Query.getRoleExt":
		if e.complexity.Query.GetRoleExt == nil {
			break
		}

		args, err := ec.field_Query_getRoleExt_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetRoleExt(childComplexity, args["id"].(string)), true

	case "Query.getTension":
		if e.complexity.Query.GetTension == nil {
			break
		}

		args, err := ec.field_Query_getTension_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetTension(childComplexity, args["id"].(string)), true

	case "Query.getUser":
		if e.complexity.Query.GetUser == nil {
			break
		}

		args, err := ec.field_Query_getUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetUser(childComplexity, args["id"].(*string), args["username"].(*string), args["email"].(*string)), true

	case "Query.getUserEvent":
		if e.complexity.Query.GetUserEvent == nil {
			break
		}

		args, err := ec.field_Query_getUserEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetUserEvent(childComplexity, args["id"].(string)), true

	case "Query.getVote":
		if e.complexity.Query.GetVote == nil {
			break
		}

		args, err := ec.field_Query_getVote_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetVote(childComplexity, args["id"].(*string), args["voteid"].(*string)), true

	case "Query.queryBlob":
		if e.complexity.Query.QueryBlob == nil {
			break
		}

		args, err := ec.field_Query_queryBlob_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryBlob(childComplexity, args["filter"].(*model.BlobFilter), args["order"].(*model.BlobOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryComment":
		if e.complexity.Query.QueryComment == nil {
			break
		}

		args, err := ec.field_Query_queryComment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryComment(childComplexity, args["filter"].(*model.CommentFilter), args["order"].(*model.CommentOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryContract":
		if e.complexity.Query.QueryContract == nil {
			break
		}

		args, err := ec.field_Query_queryContract_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryContract(childComplexity, args["filter"].(*model.ContractFilter), args["order"].(*model.ContractOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryEvent":
		if e.complexity.Query.QueryEvent == nil {
			break
		}

		args, err := ec.field_Query_queryEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryEvent(childComplexity, args["filter"].(*model.EventFilter), args["order"].(*model.EventOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryEventCount":
		if e.complexity.Query.QueryEventCount == nil {
			break
		}

		args, err := ec.field_Query_queryEventCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryEventCount(childComplexity, args["filter"].(*model.EventCountFilter), args["order"].(*model.EventCountOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryEventFragment":
		if e.complexity.Query.QueryEventFragment == nil {
			break
		}

		args, err := ec.field_Query_queryEventFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryEventFragment(childComplexity, args["filter"].(*model.EventFragmentFilter), args["order"].(*model.EventFragmentOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryLabel":
		if e.complexity.Query.QueryLabel == nil {
			break
		}

		args, err := ec.field_Query_queryLabel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryLabel(childComplexity, args["filter"].(*model.LabelFilter), args["order"].(*model.LabelOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryMandate":
		if e.complexity.Query.QueryMandate == nil {
			break
		}

		args, err := ec.field_Query_queryMandate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryMandate(childComplexity, args["filter"].(*model.MandateFilter), args["order"].(*model.MandateOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryNode":
		if e.complexity.Query.QueryNode == nil {
			break
		}

		args, err := ec.field_Query_queryNode_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryNode(childComplexity, args["filter"].(*model.NodeFilter), args["order"].(*model.NodeOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryNodeFragment":
		if e.complexity.Query.QueryNodeFragment == nil {
			break
		}

		args, err := ec.field_Query_queryNodeFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryNodeFragment(childComplexity, args["filter"].(*model.NodeFragmentFilter), args["order"].(*model.NodeFragmentOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryNotif":
		if e.complexity.Query.QueryNotif == nil {
			break
		}

		args, err := ec.field_Query_queryNotif_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryNotif(childComplexity, args["filter"].(*model.NotifFilter), args["order"].(*model.NotifOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryOrgaAgg":
		if e.complexity.Query.QueryOrgaAgg == nil {
			break
		}

		args, err := ec.field_Query_queryOrgaAgg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryOrgaAgg(childComplexity, args["filter"].(*model.OrgaAggFilter), args["order"].(*model.OrgaAggOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryPendingUser":
		if e.complexity.Query.QueryPendingUser == nil {
			break
		}

		args, err := ec.field_Query_queryPendingUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryPendingUser(childComplexity, args["filter"].(*model.PendingUserFilter), args["order"].(*model.PendingUserOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryPost":
		if e.complexity.Query.QueryPost == nil {
			break
		}

		args, err := ec.field_Query_queryPost_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryPost(childComplexity, args["filter"].(*model.PostFilter), args["order"].(*model.PostOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryReaction":
		if e.complexity.Query.QueryReaction == nil {
			break
		}

		args, err := ec.field_Query_queryReaction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryReaction(childComplexity, args["filter"].(*model.ReactionFilter), args["order"].(*model.ReactionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryRoleExt":
		if e.complexity.Query.QueryRoleExt == nil {
			break
		}

		args, err := ec.field_Query_queryRoleExt_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryRoleExt(childComplexity, args["filter"].(*model.RoleExtFilter), args["order"].(*model.RoleExtOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryTension":
		if e.complexity.Query.QueryTension == nil {
			break
		}

		args, err := ec.field_Query_queryTension_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryTension(childComplexity, args["filter"].(*model.TensionFilter), args["order"].(*model.TensionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryUser":
		if e.complexity.Query.QueryUser == nil {
			break
		}

		args, err := ec.field_Query_queryUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryUser(childComplexity, args["filter"].(*model.UserFilter), args["order"].(*model.UserOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryUserEvent":
		if e.complexity.Query.QueryUserEvent == nil {
			break
		}

		args, err := ec.field_Query_queryUserEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryUserEvent(childComplexity, args["filter"].(*model.UserEventFilter), args["order"].(*model.UserEventOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryUserRights":
		if e.complexity.Query.QueryUserRights == nil {
			break
		}

		args, err := ec.field_Query_queryUserRights_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryUserRights(childComplexity, args["filter"].(*model.UserRightsFilter), args["order"].(*model.UserRightsOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Query.queryVote":
		if e.complexity.Query.QueryVote == nil {
			break
		}

		args, err := ec.field_Query_queryVote_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryVote(childComplexity, args["filter"].(*model.VoteFilter), args["order"].(*model.VoteOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Reaction.comment":
		if e.complexity.Reaction.Comment == nil {
			break
		}

		args, err := ec.field_Reaction_comment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Reaction.Comment(childComplexity, args["filter"].(*model.CommentFilter)), true

	case "Reaction.id":
		if e.complexity.Reaction.ID == nil {
			break
		}

		return e.complexity.Reaction.ID(childComplexity), true

	case "Reaction.reactionid":
		if e.complexity.Reaction.Reactionid == nil {
			break
		}

		return e.complexity.Reaction.Reactionid(childComplexity), true

	case "Reaction.type_":
		if e.complexity.Reaction.Type == nil {
			break
		}

		return e.complexity.Reaction.Type(childComplexity), true

	case "Reaction.user":
		if e.complexity.Reaction.User == nil {
			break
		}

		args, err := ec.field_Reaction_user_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Reaction.User(childComplexity, args["filter"].(*model.UserFilter)), true

	case "ReactionAggregateResult.count":
		if e.complexity.ReactionAggregateResult.Count == nil {
			break
		}

		return e.complexity.ReactionAggregateResult.Count(childComplexity), true

	case "ReactionAggregateResult.reactionidMax":
		if e.complexity.ReactionAggregateResult.ReactionidMax == nil {
			break
		}

		return e.complexity.ReactionAggregateResult.ReactionidMax(childComplexity), true

	case "ReactionAggregateResult.reactionidMin":
		if e.complexity.ReactionAggregateResult.ReactionidMin == nil {
			break
		}

		return e.complexity.ReactionAggregateResult.ReactionidMin(childComplexity), true

	case "ReactionAggregateResult.type_Avg":
		if e.complexity.ReactionAggregateResult.TypeAvg == nil {
			break
		}

		return e.complexity.ReactionAggregateResult.TypeAvg(childComplexity), true

	case "ReactionAggregateResult.type_Max":
		if e.complexity.ReactionAggregateResult.TypeMax == nil {
			break
		}

		return e.complexity.ReactionAggregateResult.TypeMax(childComplexity), true

	case "ReactionAggregateResult.type_Min":
		if e.complexity.ReactionAggregateResult.TypeMin == nil {
			break
		}

		return e.complexity.ReactionAggregateResult.TypeMin(childComplexity), true

	case "ReactionAggregateResult.type_Sum":
		if e.complexity.ReactionAggregateResult.TypeSum == nil {
			break
		}

		return e.complexity.ReactionAggregateResult.TypeSum(childComplexity), true

	case "RoleExt.about":
		if e.complexity.RoleExt.About == nil {
			break
		}

		return e.complexity.RoleExt.About(childComplexity), true

	case "RoleExt.color":
		if e.complexity.RoleExt.Color == nil {
			break
		}

		return e.complexity.RoleExt.Color(childComplexity), true

	case "RoleExt.id":
		if e.complexity.RoleExt.ID == nil {
			break
		}

		return e.complexity.RoleExt.ID(childComplexity), true

	case "RoleExt.mandate":
		if e.complexity.RoleExt.Mandate == nil {
			break
		}

		args, err := ec.field_RoleExt_mandate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.RoleExt.Mandate(childComplexity, args["filter"].(*model.MandateFilter)), true

	case "RoleExt.name":
		if e.complexity.RoleExt.Name == nil {
			break
		}

		return e.complexity.RoleExt.Name(childComplexity), true

	case "RoleExt.nodes":
		if e.complexity.RoleExt.Nodes == nil {
			break
		}

		args, err := ec.field_RoleExt_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.RoleExt.Nodes(childComplexity, args["filter"].(*model.NodeFilter), args["order"].(*model.NodeOrder), args["first"].(*int), args["offset"].(*int)), true

	case "RoleExt.nodesAggregate":
		if e.complexity.RoleExt.NodesAggregate == nil {
			break
		}

		args, err := ec.field_RoleExt_nodesAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.RoleExt.NodesAggregate(childComplexity, args["filter"].(*model.NodeFilter)), true

	case "RoleExt.role_type":
		if e.complexity.RoleExt.RoleType == nil {
			break
		}

		return e.complexity.RoleExt.RoleType(childComplexity), true

	case "RoleExt.roles":
		if e.complexity.RoleExt.Roles == nil {
			break
		}

		args, err := ec.field_RoleExt_roles_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.RoleExt.Roles(childComplexity, args["filter"].(*model.NodeFilter), args["order"].(*model.NodeOrder), args["first"].(*int), args["offset"].(*int)), true

	case "RoleExt.rolesAggregate":
		if e.complexity.RoleExt.RolesAggregate == nil {
			break
		}

		args, err := ec.field_RoleExt_rolesAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.RoleExt.RolesAggregate(childComplexity, args["filter"].(*model.NodeFilter)), true

	case "RoleExt.rootnameid":
		if e.complexity.RoleExt.Rootnameid == nil {
			break
		}

		return e.complexity.RoleExt.Rootnameid(childComplexity), true

	case "RoleExtAggregateResult.aboutMax":
		if e.complexity.RoleExtAggregateResult.AboutMax == nil {
			break
		}

		return e.complexity.RoleExtAggregateResult.AboutMax(childComplexity), true

	case "RoleExtAggregateResult.aboutMin":
		if e.complexity.RoleExtAggregateResult.AboutMin == nil {
			break
		}

		return e.complexity.RoleExtAggregateResult.AboutMin(childComplexity), true

	case "RoleExtAggregateResult.colorMax":
		if e.complexity.RoleExtAggregateResult.ColorMax == nil {
			break
		}

		return e.complexity.RoleExtAggregateResult.ColorMax(childComplexity), true

	case "RoleExtAggregateResult.colorMin":
		if e.complexity.RoleExtAggregateResult.ColorMin == nil {
			break
		}

		return e.complexity.RoleExtAggregateResult.ColorMin(childComplexity), true

	case "RoleExtAggregateResult.count":
		if e.complexity.RoleExtAggregateResult.Count == nil {
			break
		}

		return e.complexity.RoleExtAggregateResult.Count(childComplexity), true

	case "RoleExtAggregateResult.nameMax":
		if e.complexity.RoleExtAggregateResult.NameMax == nil {
			break
		}

		return e.complexity.RoleExtAggregateResult.NameMax(childComplexity), true

	case "RoleExtAggregateResult.nameMin":
		if e.complexity.RoleExtAggregateResult.NameMin == nil {
			break
		}

		return e.complexity.RoleExtAggregateResult.NameMin(childComplexity), true

	case "RoleExtAggregateResult.rootnameidMax":
		if e.complexity.RoleExtAggregateResult.RootnameidMax == nil {
			break
		}

		return e.complexity.RoleExtAggregateResult.RootnameidMax(childComplexity), true

	case "RoleExtAggregateResult.rootnameidMin":
		if e.complexity.RoleExtAggregateResult.RootnameidMin == nil {
			break
		}

		return e.complexity.RoleExtAggregateResult.RootnameidMin(childComplexity), true

	case "Tension.action":
		if e.complexity.Tension.Action == nil {
			break
		}

		return e.complexity.Tension.Action(childComplexity), true

	case "Tension.assignees":
		if e.complexity.Tension.Assignees == nil {
			break
		}

		args, err := ec.field_Tension_assignees_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.Assignees(childComplexity, args["filter"].(*model.UserFilter), args["order"].(*model.UserOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Tension.assigneesAggregate":
		if e.complexity.Tension.AssigneesAggregate == nil {
			break
		}

		args, err := ec.field_Tension_assigneesAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.AssigneesAggregate(childComplexity, args["filter"].(*model.UserFilter)), true

	case "Tension.blobs":
		if e.complexity.Tension.Blobs == nil {
			break
		}

		args, err := ec.field_Tension_blobs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.Blobs(childComplexity, args["filter"].(*model.BlobFilter), args["order"].(*model.BlobOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Tension.blobsAggregate":
		if e.complexity.Tension.BlobsAggregate == nil {
			break
		}

		args, err := ec.field_Tension_blobsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.BlobsAggregate(childComplexity, args["filter"].(*model.BlobFilter)), true

	case "Tension.comments":
		if e.complexity.Tension.Comments == nil {
			break
		}

		args, err := ec.field_Tension_comments_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.Comments(childComplexity, args["filter"].(*model.CommentFilter), args["order"].(*model.CommentOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Tension.commentsAggregate":
		if e.complexity.Tension.CommentsAggregate == nil {
			break
		}

		args, err := ec.field_Tension_commentsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.CommentsAggregate(childComplexity, args["filter"].(*model.CommentFilter)), true

	case "Tension.contracts":
		if e.complexity.Tension.Contracts == nil {
			break
		}

		args, err := ec.field_Tension_contracts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.Contracts(childComplexity, args["filter"].(*model.ContractFilter), args["order"].(*model.ContractOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Tension.contractsAggregate":
		if e.complexity.Tension.ContractsAggregate == nil {
			break
		}

		args, err := ec.field_Tension_contractsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.ContractsAggregate(childComplexity, args["filter"].(*model.ContractFilter)), true

	case "Tension.createdAt":
		if e.complexity.Tension.CreatedAt == nil {
			break
		}

		return e.complexity.Tension.CreatedAt(childComplexity), true

	case "Tension.createdBy":
		if e.complexity.Tension.CreatedBy == nil {
			break
		}

		args, err := ec.field_Tension_createdBy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.CreatedBy(childComplexity, args["filter"].(*model.UserFilter)), true

	case "Tension.emitter":
		if e.complexity.Tension.Emitter == nil {
			break
		}

		args, err := ec.field_Tension_emitter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.Emitter(childComplexity, args["filter"].(*model.NodeFilter)), true

	case "Tension.emitterid":
		if e.complexity.Tension.Emitterid == nil {
			break
		}

		return e.complexity.Tension.Emitterid(childComplexity), true

	case "Tension.history":
		if e.complexity.Tension.History == nil {
			break
		}

		args, err := ec.field_Tension_history_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.History(childComplexity, args["filter"].(*model.EventFilter), args["order"].(*model.EventOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Tension.historyAggregate":
		if e.complexity.Tension.HistoryAggregate == nil {
			break
		}

		args, err := ec.field_Tension_historyAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.HistoryAggregate(childComplexity, args["filter"].(*model.EventFilter)), true

	case "Tension.id":
		if e.complexity.Tension.ID == nil {
			break
		}

		return e.complexity.Tension.ID(childComplexity), true

	case "Tension.labels":
		if e.complexity.Tension.Labels == nil {
			break
		}

		args, err := ec.field_Tension_labels_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.Labels(childComplexity, args["filter"].(*model.LabelFilter), args["order"].(*model.LabelOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Tension.labelsAggregate":
		if e.complexity.Tension.LabelsAggregate == nil {
			break
		}

		args, err := ec.field_Tension_labelsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.LabelsAggregate(childComplexity, args["filter"].(*model.LabelFilter)), true

	case "Tension.mentions":
		if e.complexity.Tension.Mentions == nil {
			break
		}

		args, err := ec.field_Tension_mentions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.Mentions(childComplexity, args["filter"].(*model.EventFilter), args["order"].(*model.EventOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Tension.mentionsAggregate":
		if e.complexity.Tension.MentionsAggregate == nil {
			break
		}

		args, err := ec.field_Tension_mentionsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.MentionsAggregate(childComplexity, args["filter"].(*model.EventFilter)), true

	case "Tension.message":
		if e.complexity.Tension.Message == nil {
			break
		}

		return e.complexity.Tension.Message(childComplexity), true

	case "Tension.n_comments":
		if e.complexity.Tension.NComments == nil {
			break
		}

		return e.complexity.Tension.NComments(childComplexity), true

	case "Tension.n_open_contracts":
		if e.complexity.Tension.NOpenContracts == nil {
			break
		}

		return e.complexity.Tension.NOpenContracts(childComplexity), true

	case "Tension.receiver":
		if e.complexity.Tension.Receiver == nil {
			break
		}

		args, err := ec.field_Tension_receiver_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.Receiver(childComplexity, args["filter"].(*model.NodeFilter)), true

	case "Tension.receiverid":
		if e.complexity.Tension.Receiverid == nil {
			break
		}

		return e.complexity.Tension.Receiverid(childComplexity), true

	case "Tension.status":
		if e.complexity.Tension.Status == nil {
			break
		}

		return e.complexity.Tension.Status(childComplexity), true

	case "Tension.subscribers":
		if e.complexity.Tension.Subscribers == nil {
			break
		}

		args, err := ec.field_Tension_subscribers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.Subscribers(childComplexity, args["filter"].(*model.UserFilter), args["order"].(*model.UserOrder), args["first"].(*int), args["offset"].(*int)), true

	case "Tension.subscribersAggregate":
		if e.complexity.Tension.SubscribersAggregate == nil {
			break
		}

		args, err := ec.field_Tension_subscribersAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tension.SubscribersAggregate(childComplexity, args["filter"].(*model.UserFilter)), true

	case "Tension.title":
		if e.complexity.Tension.Title == nil {
			break
		}

		return e.complexity.Tension.Title(childComplexity), true

	case "Tension.type_":
		if e.complexity.Tension.Type == nil {
			break
		}

		return e.complexity.Tension.Type(childComplexity), true

	case "Tension.updatedAt":
		if e.complexity.Tension.UpdatedAt == nil {
			break
		}

		return e.complexity.Tension.UpdatedAt(childComplexity), true

	case "TensionAggregateResult.count":
		if e.complexity.TensionAggregateResult.Count == nil {
			break
		}

		return e.complexity.TensionAggregateResult.Count(childComplexity), true

	case "TensionAggregateResult.createdAtMax":
		if e.complexity.TensionAggregateResult.CreatedAtMax == nil {
			break
		}

		return e.complexity.TensionAggregateResult.CreatedAtMax(childComplexity), true

	case "TensionAggregateResult.createdAtMin":
		if e.complexity.TensionAggregateResult.CreatedAtMin == nil {
			break
		}

		return e.complexity.TensionAggregateResult.CreatedAtMin(childComplexity), true

	case "TensionAggregateResult.emitteridMax":
		if e.complexity.TensionAggregateResult.EmitteridMax == nil {
			break
		}

		return e.complexity.TensionAggregateResult.EmitteridMax(childComplexity), true

	case "TensionAggregateResult.emitteridMin":
		if e.complexity.TensionAggregateResult.EmitteridMin == nil {
			break
		}

		return e.complexity.TensionAggregateResult.EmitteridMin(childComplexity), true

	case "TensionAggregateResult.messageMax":
		if e.complexity.TensionAggregateResult.MessageMax == nil {
			break
		}

		return e.complexity.TensionAggregateResult.MessageMax(childComplexity), true

	case "TensionAggregateResult.messageMin":
		if e.complexity.TensionAggregateResult.MessageMin == nil {
			break
		}

		return e.complexity.TensionAggregateResult.MessageMin(childComplexity), true

	case "TensionAggregateResult.n_commentsAvg":
		if e.complexity.TensionAggregateResult.NCommentsAvg == nil {
			break
		}

		return e.complexity.TensionAggregateResult.NCommentsAvg(childComplexity), true

	case "TensionAggregateResult.n_commentsMax":
		if e.complexity.TensionAggregateResult.NCommentsMax == nil {
			break
		}

		return e.complexity.TensionAggregateResult.NCommentsMax(childComplexity), true

	case "TensionAggregateResult.n_commentsMin":
		if e.complexity.TensionAggregateResult.NCommentsMin == nil {
			break
		}

		return e.complexity.TensionAggregateResult.NCommentsMin(childComplexity), true

	case "TensionAggregateResult.n_commentsSum":
		if e.complexity.TensionAggregateResult.NCommentsSum == nil {
			break
		}

		return e.complexity.TensionAggregateResult.NCommentsSum(childComplexity), true

	case "TensionAggregateResult.n_open_contractsAvg":
		if e.complexity.TensionAggregateResult.NOpenContractsAvg == nil {
			break
		}

		return e.complexity.TensionAggregateResult.NOpenContractsAvg(childComplexity), true

	case "TensionAggregateResult.n_open_contractsMax":
		if e.complexity.TensionAggregateResult.NOpenContractsMax == nil {
			break
		}

		return e.complexity.TensionAggregateResult.NOpenContractsMax(childComplexity), true

	case "TensionAggregateResult.n_open_contractsMin":
		if e.complexity.TensionAggregateResult.NOpenContractsMin == nil {
			break
		}

		return e.complexity.TensionAggregateResult.NOpenContractsMin(childComplexity), true

	case "TensionAggregateResult.n_open_contractsSum":
		if e.complexity.TensionAggregateResult.NOpenContractsSum == nil {
			break
		}

		return e.complexity.TensionAggregateResult.NOpenContractsSum(childComplexity), true

	case "TensionAggregateResult.receiveridMax":
		if e.complexity.TensionAggregateResult.ReceiveridMax == nil {
			break
		}

		return e.complexity.TensionAggregateResult.ReceiveridMax(childComplexity), true

	case "TensionAggregateResult.receiveridMin":
		if e.complexity.TensionAggregateResult.ReceiveridMin == nil {
			break
		}

		return e.complexity.TensionAggregateResult.ReceiveridMin(childComplexity), true

	case "TensionAggregateResult.titleMax":
		if e.complexity.TensionAggregateResult.TitleMax == nil {
			break
		}

		return e.complexity.TensionAggregateResult.TitleMax(childComplexity), true

	case "TensionAggregateResult.titleMin":
		if e.complexity.TensionAggregateResult.TitleMin == nil {
			break
		}

		return e.complexity.TensionAggregateResult.TitleMin(childComplexity), true

	case "TensionAggregateResult.updatedAtMax":
		if e.complexity.TensionAggregateResult.UpdatedAtMax == nil {
			break
		}

		return e.complexity.TensionAggregateResult.UpdatedAtMax(childComplexity), true

	case "TensionAggregateResult.updatedAtMin":
		if e.complexity.TensionAggregateResult.UpdatedAtMin == nil {
			break
		}

		return e.complexity.TensionAggregateResult.UpdatedAtMin(childComplexity), true

	case "UpdateBlobPayload.blob":
		if e.complexity.UpdateBlobPayload.Blob == nil {
			break
		}

		args, err := ec.field_UpdateBlobPayload_blob_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateBlobPayload.Blob(childComplexity, args["filter"].(*model.BlobFilter), args["order"].(*model.BlobOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateBlobPayload.numUids":
		if e.complexity.UpdateBlobPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateBlobPayload.NumUids(childComplexity), true

	case "UpdateCommentPayload.comment":
		if e.complexity.UpdateCommentPayload.Comment == nil {
			break
		}

		args, err := ec.field_UpdateCommentPayload_comment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateCommentPayload.Comment(childComplexity, args["filter"].(*model.CommentFilter), args["order"].(*model.CommentOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateCommentPayload.numUids":
		if e.complexity.UpdateCommentPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateCommentPayload.NumUids(childComplexity), true

	case "UpdateContractPayload.contract":
		if e.complexity.UpdateContractPayload.Contract == nil {
			break
		}

		args, err := ec.field_UpdateContractPayload_contract_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateContractPayload.Contract(childComplexity, args["filter"].(*model.ContractFilter), args["order"].(*model.ContractOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateContractPayload.numUids":
		if e.complexity.UpdateContractPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateContractPayload.NumUids(childComplexity), true

	case "UpdateEventCountPayload.eventCount":
		if e.complexity.UpdateEventCountPayload.EventCount == nil {
			break
		}

		args, err := ec.field_UpdateEventCountPayload_eventCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateEventCountPayload.EventCount(childComplexity, args["filter"].(*model.EventCountFilter), args["order"].(*model.EventCountOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateEventCountPayload.numUids":
		if e.complexity.UpdateEventCountPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateEventCountPayload.NumUids(childComplexity), true

	case "UpdateEventFragmentPayload.eventFragment":
		if e.complexity.UpdateEventFragmentPayload.EventFragment == nil {
			break
		}

		args, err := ec.field_UpdateEventFragmentPayload_eventFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateEventFragmentPayload.EventFragment(childComplexity, args["filter"].(*model.EventFragmentFilter), args["order"].(*model.EventFragmentOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateEventFragmentPayload.numUids":
		if e.complexity.UpdateEventFragmentPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateEventFragmentPayload.NumUids(childComplexity), true

	case "UpdateEventPayload.event":
		if e.complexity.UpdateEventPayload.Event == nil {
			break
		}

		args, err := ec.field_UpdateEventPayload_event_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateEventPayload.Event(childComplexity, args["filter"].(*model.EventFilter), args["order"].(*model.EventOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateEventPayload.numUids":
		if e.complexity.UpdateEventPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateEventPayload.NumUids(childComplexity), true

	case "UpdateLabelPayload.label":
		if e.complexity.UpdateLabelPayload.Label == nil {
			break
		}

		args, err := ec.field_UpdateLabelPayload_label_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateLabelPayload.Label(childComplexity, args["filter"].(*model.LabelFilter), args["order"].(*model.LabelOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateLabelPayload.numUids":
		if e.complexity.UpdateLabelPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateLabelPayload.NumUids(childComplexity), true

	case "UpdateMandatePayload.mandate":
		if e.complexity.UpdateMandatePayload.Mandate == nil {
			break
		}

		args, err := ec.field_UpdateMandatePayload_mandate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateMandatePayload.Mandate(childComplexity, args["filter"].(*model.MandateFilter), args["order"].(*model.MandateOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateMandatePayload.numUids":
		if e.complexity.UpdateMandatePayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateMandatePayload.NumUids(childComplexity), true

	case "UpdateNodeFragmentPayload.nodeFragment":
		if e.complexity.UpdateNodeFragmentPayload.NodeFragment == nil {
			break
		}

		args, err := ec.field_UpdateNodeFragmentPayload_nodeFragment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateNodeFragmentPayload.NodeFragment(childComplexity, args["filter"].(*model.NodeFragmentFilter), args["order"].(*model.NodeFragmentOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateNodeFragmentPayload.numUids":
		if e.complexity.UpdateNodeFragmentPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateNodeFragmentPayload.NumUids(childComplexity), true

	case "UpdateNodePayload.node":
		if e.complexity.UpdateNodePayload.Node == nil {
			break
		}

		args, err := ec.field_UpdateNodePayload_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateNodePayload.Node(childComplexity, args["filter"].(*model.NodeFilter), args["order"].(*model.NodeOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateNodePayload.numUids":
		if e.complexity.UpdateNodePayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateNodePayload.NumUids(childComplexity), true

	case "UpdateNotifPayload.notif":
		if e.complexity.UpdateNotifPayload.Notif == nil {
			break
		}

		args, err := ec.field_UpdateNotifPayload_notif_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateNotifPayload.Notif(childComplexity, args["filter"].(*model.NotifFilter), args["order"].(*model.NotifOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateNotifPayload.numUids":
		if e.complexity.UpdateNotifPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateNotifPayload.NumUids(childComplexity), true

	case "UpdateOrgaAggPayload.numUids":
		if e.complexity.UpdateOrgaAggPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateOrgaAggPayload.NumUids(childComplexity), true

	case "UpdateOrgaAggPayload.orgaAgg":
		if e.complexity.UpdateOrgaAggPayload.OrgaAgg == nil {
			break
		}

		args, err := ec.field_UpdateOrgaAggPayload_orgaAgg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateOrgaAggPayload.OrgaAgg(childComplexity, args["filter"].(*model.OrgaAggFilter), args["order"].(*model.OrgaAggOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdatePendingUserPayload.numUids":
		if e.complexity.UpdatePendingUserPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdatePendingUserPayload.NumUids(childComplexity), true

	case "UpdatePendingUserPayload.pendingUser":
		if e.complexity.UpdatePendingUserPayload.PendingUser == nil {
			break
		}

		args, err := ec.field_UpdatePendingUserPayload_pendingUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdatePendingUserPayload.PendingUser(childComplexity, args["filter"].(*model.PendingUserFilter), args["order"].(*model.PendingUserOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdatePostPayload.numUids":
		if e.complexity.UpdatePostPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdatePostPayload.NumUids(childComplexity), true

	case "UpdatePostPayload.post":
		if e.complexity.UpdatePostPayload.Post == nil {
			break
		}

		args, err := ec.field_UpdatePostPayload_post_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdatePostPayload.Post(childComplexity, args["filter"].(*model.PostFilter), args["order"].(*model.PostOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateReactionPayload.numUids":
		if e.complexity.UpdateReactionPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateReactionPayload.NumUids(childComplexity), true

	case "UpdateReactionPayload.reaction":
		if e.complexity.UpdateReactionPayload.Reaction == nil {
			break
		}

		args, err := ec.field_UpdateReactionPayload_reaction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateReactionPayload.Reaction(childComplexity, args["filter"].(*model.ReactionFilter), args["order"].(*model.ReactionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateRoleExtPayload.numUids":
		if e.complexity.UpdateRoleExtPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateRoleExtPayload.NumUids(childComplexity), true

	case "UpdateRoleExtPayload.roleExt":
		if e.complexity.UpdateRoleExtPayload.RoleExt == nil {
			break
		}

		args, err := ec.field_UpdateRoleExtPayload_roleExt_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateRoleExtPayload.RoleExt(childComplexity, args["filter"].(*model.RoleExtFilter), args["order"].(*model.RoleExtOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateTensionPayload.numUids":
		if e.complexity.UpdateTensionPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateTensionPayload.NumUids(childComplexity), true

	case "UpdateTensionPayload.tension":
		if e.complexity.UpdateTensionPayload.Tension == nil {
			break
		}

		args, err := ec.field_UpdateTensionPayload_tension_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateTensionPayload.Tension(childComplexity, args["filter"].(*model.TensionFilter), args["order"].(*model.TensionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateUserEventPayload.numUids":
		if e.complexity.UpdateUserEventPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateUserEventPayload.NumUids(childComplexity), true

	case "UpdateUserEventPayload.userEvent":
		if e.complexity.UpdateUserEventPayload.UserEvent == nil {
			break
		}

		args, err := ec.field_UpdateUserEventPayload_userEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateUserEventPayload.UserEvent(childComplexity, args["filter"].(*model.UserEventFilter), args["order"].(*model.UserEventOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateUserPayload.numUids":
		if e.complexity.UpdateUserPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateUserPayload.NumUids(childComplexity), true

	case "UpdateUserPayload.user":
		if e.complexity.UpdateUserPayload.User == nil {
			break
		}

		args, err := ec.field_UpdateUserPayload_user_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateUserPayload.User(childComplexity, args["filter"].(*model.UserFilter), args["order"].(*model.UserOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateUserRightsPayload.numUids":
		if e.complexity.UpdateUserRightsPayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateUserRightsPayload.NumUids(childComplexity), true

	case "UpdateUserRightsPayload.userRights":
		if e.complexity.UpdateUserRightsPayload.UserRights == nil {
			break
		}

		args, err := ec.field_UpdateUserRightsPayload_userRights_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateUserRightsPayload.UserRights(childComplexity, args["filter"].(*model.UserRightsFilter), args["order"].(*model.UserRightsOrder), args["first"].(*int), args["offset"].(*int)), true

	case "UpdateVotePayload.numUids":
		if e.complexity.UpdateVotePayload.NumUids == nil {
			break
		}

		return e.complexity.UpdateVotePayload.NumUids(childComplexity), true

	case "UpdateVotePayload.vote":
		if e.complexity.UpdateVotePayload.Vote == nil {
			break
		}

		args, err := ec.field_UpdateVotePayload_vote_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UpdateVotePayload.Vote(childComplexity, args["filter"].(*model.VoteFilter), args["order"].(*model.VoteOrder), args["first"].(*int), args["offset"].(*int)), true

	case "User.backed_roles":
		if e.complexity.User.BackedRoles == nil {
			break
		}

		args, err := ec.field_User_backed_roles_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.BackedRoles(childComplexity, args["filter"].(*model.NodeFilter), args["order"].(*model.NodeOrder), args["first"].(*int), args["offset"].(*int)), true

	case "User.backed_rolesAggregate":
		if e.complexity.User.BackedRolesAggregate == nil {
			break
		}

		args, err := ec.field_User_backed_rolesAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.BackedRolesAggregate(childComplexity, args["filter"].(*model.NodeFilter)), true

	case "User.bio":
		if e.complexity.User.Bio == nil {
			break
		}

		return e.complexity.User.Bio(childComplexity), true

	case "User.contracts":
		if e.complexity.User.Contracts == nil {
			break
		}

		args, err := ec.field_User_contracts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Contracts(childComplexity, args["filter"].(*model.ContractFilter), args["order"].(*model.ContractOrder), args["first"].(*int), args["offset"].(*int)), true

	case "User.contractsAggregate":
		if e.complexity.User.ContractsAggregate == nil {
			break
		}

		args, err := ec.field_User_contractsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.ContractsAggregate(childComplexity, args["filter"].(*model.ContractFilter)), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.event_count":
		if e.complexity.User.EventCount == nil {
			break
		}

		args, err := ec.field_User_event_count_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.EventCount(childComplexity, args["filter"].(*model.EventCountFilter)), true

	case "User.events":
		if e.complexity.User.Events == nil {
			break
		}

		args, err := ec.field_User_events_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Events(childComplexity, args["filter"].(*model.UserEventFilter), args["order"].(*model.UserEventOrder), args["first"].(*int), args["offset"].(*int)), true

	case "User.eventsAggregate":
		if e.complexity.User.EventsAggregate == nil {
			break
		}

		args, err := ec.field_User_eventsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.EventsAggregate(childComplexity, args["filter"].(*model.UserEventFilter)), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.lang":
		if e.complexity.User.Lang == nil {
			break
		}

		return e.complexity.User.Lang(childComplexity), true

	case "User.lastAck":
		if e.complexity.User.LastAck == nil {
			break
		}

		return e.complexity.User.LastAck(childComplexity), true

	case "User.links":
		if e.complexity.User.Links == nil {
			break
		}

		return e.complexity.User.Links(childComplexity), true

	case "User.location":
		if e.complexity.User.Location == nil {
			break
		}

		return e.complexity.User.Location(childComplexity), true

	case "User.markAllAsRead":
		if e.complexity.User.MarkAllAsRead == nil {
			break
		}

		return e.complexity.User.MarkAllAsRead(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.notifyByEmail":
		if e.complexity.User.NotifyByEmail == nil {
			break
		}

		return e.complexity.User.NotifyByEmail(childComplexity), true

	case "User.password":
		if e.complexity.User.Password == nil {
			break
		}

		return e.complexity.User.Password(childComplexity), true

	case "User.reactions":
		if e.complexity.User.Reactions == nil {
			break
		}

		args, err := ec.field_User_reactions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Reactions(childComplexity, args["filter"].(*model.ReactionFilter), args["order"].(*model.ReactionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "User.reactionsAggregate":
		if e.complexity.User.ReactionsAggregate == nil {
			break
		}

		args, err := ec.field_User_reactionsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.ReactionsAggregate(childComplexity, args["filter"].(*model.ReactionFilter)), true

	case "User.rights":
		if e.complexity.User.Rights == nil {
			break
		}

		args, err := ec.field_User_rights_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Rights(childComplexity, args["filter"].(*model.UserRightsFilter)), true

	case "User.roles":
		if e.complexity.User.Roles == nil {
			break
		}

		args, err := ec.field_User_roles_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Roles(childComplexity, args["filter"].(*model.NodeFilter), args["order"].(*model.NodeOrder), args["first"].(*int), args["offset"].(*int)), true

	case "User.rolesAggregate":
		if e.complexity.User.RolesAggregate == nil {
			break
		}

		args, err := ec.field_User_rolesAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.RolesAggregate(childComplexity, args["filter"].(*model.NodeFilter)), true

	case "User.skills":
		if e.complexity.User.Skills == nil {
			break
		}

		return e.complexity.User.Skills(childComplexity), true

	case "User.subscriptions":
		if e.complexity.User.Subscriptions == nil {
			break
		}

		args, err := ec.field_User_subscriptions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Subscriptions(childComplexity, args["filter"].(*model.TensionFilter), args["order"].(*model.TensionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "User.subscriptionsAggregate":
		if e.complexity.User.SubscriptionsAggregate == nil {
			break
		}

		args, err := ec.field_User_subscriptionsAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.SubscriptionsAggregate(childComplexity, args["filter"].(*model.TensionFilter)), true

	case "User.tensions_assigned":
		if e.complexity.User.TensionsAssigned == nil {
			break
		}

		args, err := ec.field_User_tensions_assigned_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.TensionsAssigned(childComplexity, args["filter"].(*model.TensionFilter), args["order"].(*model.TensionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "User.tensions_assignedAggregate":
		if e.complexity.User.TensionsAssignedAggregate == nil {
			break
		}

		args, err := ec.field_User_tensions_assignedAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.TensionsAssignedAggregate(childComplexity, args["filter"].(*model.TensionFilter)), true

	case "User.tensions_created":
		if e.complexity.User.TensionsCreated == nil {
			break
		}

		args, err := ec.field_User_tensions_created_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.TensionsCreated(childComplexity, args["filter"].(*model.TensionFilter), args["order"].(*model.TensionOrder), args["first"].(*int), args["offset"].(*int)), true

	case "User.tensions_createdAggregate":
		if e.complexity.User.TensionsCreatedAggregate == nil {
			break
		}

		args, err := ec.field_User_tensions_createdAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.TensionsCreatedAggregate(childComplexity, args["filter"].(*model.TensionFilter)), true

	case "User.username":
		if e.complexity.User.Username == nil {
			break
		}

		return e.complexity.User.Username(childComplexity), true

	case "User.utc":
		if e.complexity.User.Utc == nil {
			break
		}

		return e.complexity.User.Utc(childComplexity), true

	case "User.watching":
		if e.complexity.User.Watching == nil {
			break
		}

		args, err := ec.field_User_watching_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Watching(childComplexity, args["filter"].(*model.NodeFilter), args["order"].(*model.NodeOrder), args["first"].(*int), args["offset"].(*int)), true

	case "User.watchingAggregate":
		if e.complexity.User.WatchingAggregate == nil {
			break
		}

		args, err := ec.field_User_watchingAggregate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.WatchingAggregate(childComplexity, args["filter"].(*model.NodeFilter)), true

	case "UserAggregateResult.bioMax":
		if e.complexity.UserAggregateResult.BioMax == nil {
			break
		}

		return e.complexity.UserAggregateResult.BioMax(childComplexity), true

	case "UserAggregateResult.bioMin":
		if e.complexity.UserAggregateResult.BioMin == nil {
			break
		}

		return e.complexity.UserAggregateResult.BioMin(childComplexity), true

	case "UserAggregateResult.count":
		if e.complexity.UserAggregateResult.Count == nil {
			break
		}

		return e.complexity.UserAggregateResult.Count(childComplexity), true

	case "UserAggregateResult.createdAtMax":
		if e.complexity.UserAggregateResult.CreatedAtMax == nil {
			break
		}

		return e.complexity.UserAggregateResult.CreatedAtMax(childComplexity), true

	case "UserAggregateResult.createdAtMin":
		if e.complexity.UserAggregateResult.CreatedAtMin == nil {
			break
		}

		return e.complexity.UserAggregateResult.CreatedAtMin(childComplexity), true

	case "UserAggregateResult.emailMax":
		if e.complexity.UserAggregateResult.EmailMax == nil {
			break
		}

		return e.complexity.UserAggregateResult.EmailMax(childComplexity), true

	case "UserAggregateResult.emailMin":
		if e.complexity.UserAggregateResult.EmailMin == nil {
			break
		}

		return e.complexity.UserAggregateResult.EmailMin(childComplexity), true

	case "UserAggregateResult.lastAckMax":
		if e.complexity.UserAggregateResult.LastAckMax == nil {
			break
		}

		return e.complexity.UserAggregateResult.LastAckMax(childComplexity), true

	case "UserAggregateResult.lastAckMin":
		if e.complexity.UserAggregateResult.LastAckMin == nil {
			break
		}

		return e.complexity.UserAggregateResult.LastAckMin(childComplexity), true

	case "UserAggregateResult.locationMax":
		if e.complexity.UserAggregateResult.LocationMax == nil {
			break
		}

		return e.complexity.UserAggregateResult.LocationMax(childComplexity), true

	case "UserAggregateResult.locationMin":
		if e.complexity.UserAggregateResult.LocationMin == nil {
			break
		}

		return e.complexity.UserAggregateResult.LocationMin(childComplexity), true

	case "UserAggregateResult.markAllAsReadMax":
		if e.complexity.UserAggregateResult.MarkAllAsReadMax == nil {
			break
		}

		return e.complexity.UserAggregateResult.MarkAllAsReadMax(childComplexity), true

	case "UserAggregateResult.markAllAsReadMin":
		if e.complexity.UserAggregateResult.MarkAllAsReadMin == nil {
			break
		}

		return e.complexity.UserAggregateResult.MarkAllAsReadMin(childComplexity), true

	case "UserAggregateResult.nameMax":
		if e.complexity.UserAggregateResult.NameMax == nil {
			break
		}

		return e.complexity.UserAggregateResult.NameMax(childComplexity), true

	case "UserAggregateResult.nameMin":
		if e.complexity.UserAggregateResult.NameMin == nil {
			break
		}

		return e.complexity.UserAggregateResult.NameMin(childComplexity), true

	case "UserAggregateResult.passwordMax":
		if e.complexity.UserAggregateResult.PasswordMax == nil {
			break
		}

		return e.complexity.UserAggregateResult.PasswordMax(childComplexity), true

	case "UserAggregateResult.passwordMin":
		if e.complexity.UserAggregateResult.PasswordMin == nil {
			break
		}

		return e.complexity.UserAggregateResult.PasswordMin(childComplexity), true

	case "UserAggregateResult.usernameMax":
		if e.complexity.UserAggregateResult.UsernameMax == nil {
			break
		}

		return e.complexity.UserAggregateResult.UsernameMax(childComplexity), true

	case "UserAggregateResult.usernameMin":
		if e.complexity.UserAggregateResult.UsernameMin == nil {
			break
		}

		return e.complexity.UserAggregateResult.UsernameMin(childComplexity), true

	case "UserAggregateResult.utcMax":
		if e.complexity.UserAggregateResult.UtcMax == nil {
			break
		}

		return e.complexity.UserAggregateResult.UtcMax(childComplexity), true

	case "UserAggregateResult.utcMin":
		if e.complexity.UserAggregateResult.UtcMin == nil {
			break
		}

		return e.complexity.UserAggregateResult.UtcMin(childComplexity), true

	case "UserEvent.createdAt":
		if e.complexity.UserEvent.CreatedAt == nil {
			break
		}

		return e.complexity.UserEvent.CreatedAt(childComplexity), true

	case "UserEvent.event":
		if e.complexity.UserEvent.Event == nil {
			break
		}

		args, err := ec.field_UserEvent_event_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UserEvent.Event(childComplexity, args["filter"].(*model.EventKindFilter), args["first"].(*int), args["offset"].(*int)), true

	case "UserEvent.id":
		if e.complexity.UserEvent.ID == nil {
			break
		}

		return e.complexity.UserEvent.ID(childComplexity), true

	case "UserEvent.isRead":
		if e.complexity.UserEvent.IsRead == nil {
			break
		}

		return e.complexity.UserEvent.IsRead(childComplexity), true

	case "UserEvent.user":
		if e.complexity.UserEvent.User == nil {
			break
		}

		args, err := ec.field_UserEvent_user_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UserEvent.User(childComplexity, args["filter"].(*model.UserFilter)), true

	case "UserEventAggregateResult.count":
		if e.complexity.UserEventAggregateResult.Count == nil {
			break
		}

		return e.complexity.UserEventAggregateResult.Count(childComplexity), true

	case "UserEventAggregateResult.createdAtMax":
		if e.complexity.UserEventAggregateResult.CreatedAtMax == nil {
			break
		}

		return e.complexity.UserEventAggregateResult.CreatedAtMax(childComplexity), true

	case "UserEventAggregateResult.createdAtMin":
		if e.complexity.UserEventAggregateResult.CreatedAtMin == nil {
			break
		}

		return e.complexity.UserEventAggregateResult.CreatedAtMin(childComplexity), true

	case "UserRights.canCreateRoot":
		if e.complexity.UserRights.CanCreateRoot == nil {
			break
		}

		return e.complexity.UserRights.CanCreateRoot(childComplexity), true

	case "UserRights.canLogin":
		if e.complexity.UserRights.CanLogin == nil {
			break
		}

		return e.complexity.UserRights.CanLogin(childComplexity), true

	case "UserRights.hasEmailNotifications":
		if e.complexity.UserRights.HasEmailNotifications == nil {
			break
		}

		return e.complexity.UserRights.HasEmailNotifications(childComplexity), true

	case "UserRights.maxPrivateOrga":
		if e.complexity.UserRights.MaxPrivateOrga == nil {
			break
		}

		return e.complexity.UserRights.MaxPrivateOrga(childComplexity), true

	case "UserRights.maxPublicOrga":
		if e.complexity.UserRights.MaxPublicOrga == nil {
			break
		}

		return e.complexity.UserRights.MaxPublicOrga(childComplexity), true

	case "UserRights.type_":
		if e.complexity.UserRights.Type == nil {
			break
		}

		return e.complexity.UserRights.Type(childComplexity), true

	case "UserRightsAggregateResult.count":
		if e.complexity.UserRightsAggregateResult.Count == nil {
			break
		}

		return e.complexity.UserRightsAggregateResult.Count(childComplexity), true

	case "UserRightsAggregateResult.maxPrivateOrgaAvg":
		if e.complexity.UserRightsAggregateResult.MaxPrivateOrgaAvg == nil {
			break
		}

		return e.complexity.UserRightsAggregateResult.MaxPrivateOrgaAvg(childComplexity), true

	case "UserRightsAggregateResult.maxPrivateOrgaMax":
		if e.complexity.UserRightsAggregateResult.MaxPrivateOrgaMax == nil {
			break
		}

		return e.complexity.UserRightsAggregateResult.MaxPrivateOrgaMax(childComplexity), true

	case "UserRightsAggregateResult.maxPrivateOrgaMin":
		if e.complexity.UserRightsAggregateResult.MaxPrivateOrgaMin == nil {
			break
		}

		return e.complexity.UserRightsAggregateResult.MaxPrivateOrgaMin(childComplexity), true

	case "UserRightsAggregateResult.maxPrivateOrgaSum":
		if e.complexity.UserRightsAggregateResult.MaxPrivateOrgaSum == nil {
			break
		}

		return e.complexity.UserRightsAggregateResult.MaxPrivateOrgaSum(childComplexity), true

	case "UserRightsAggregateResult.maxPublicOrgaAvg":
		if e.complexity.UserRightsAggregateResult.MaxPublicOrgaAvg == nil {
			break
		}

		return e.complexity.UserRightsAggregateResult.MaxPublicOrgaAvg(childComplexity), true

	case "UserRightsAggregateResult.maxPublicOrgaMax":
		if e.complexity.UserRightsAggregateResult.MaxPublicOrgaMax == nil {
			break
		}

		return e.complexity.UserRightsAggregateResult.MaxPublicOrgaMax(childComplexity), true

	case "UserRightsAggregateResult.maxPublicOrgaMin":
		if e.complexity.UserRightsAggregateResult.MaxPublicOrgaMin == nil {
			break
		}

		return e.complexity.UserRightsAggregateResult.MaxPublicOrgaMin(childComplexity), true

	case "UserRightsAggregateResult.maxPublicOrgaSum":
		if e.complexity.UserRightsAggregateResult.MaxPublicOrgaSum == nil {
			break
		}

		return e.complexity.UserRightsAggregateResult.MaxPublicOrgaSum(childComplexity), true

	case "Vote.contract":
		if e.complexity.Vote.Contract == nil {
			break
		}

		args, err := ec.field_Vote_contract_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Vote.Contract(childComplexity, args["filter"].(*model.ContractFilter)), true

	case "Vote.createdAt":
		if e.complexity.Vote.CreatedAt == nil {
			break
		}

		return e.complexity.Vote.CreatedAt(childComplexity), true

	case "Vote.createdBy":
		if e.complexity.Vote.CreatedBy == nil {
			break
		}

		args, err := ec.field_Vote_createdBy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Vote.CreatedBy(childComplexity, args["filter"].(*model.UserFilter)), true

	case "Vote.data":
		if e.complexity.Vote.Data == nil {
			break
		}

		return e.complexity.Vote.Data(childComplexity), true

	case "Vote.id":
		if e.complexity.Vote.ID == nil {
			break
		}

		return e.complexity.Vote.ID(childComplexity), true

	case "Vote.message":
		if e.complexity.Vote.Message == nil {
			break
		}

		return e.complexity.Vote.Message(childComplexity), true

	case "Vote.node":
		if e.complexity.Vote.Node == nil {
			break
		}

		args, err := ec.field_Vote_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Vote.Node(childComplexity, args["filter"].(*model.NodeFilter)), true

	case "Vote.updatedAt":
		if e.complexity.Vote.UpdatedAt == nil {
			break
		}

		return e.complexity.Vote.UpdatedAt(childComplexity), true

	case "Vote.voteid":
		if e.complexity.Vote.Voteid == nil {
			break
		}

		return e.complexity.Vote.Voteid(childComplexity), true

	case "VoteAggregateResult.count":
		if e.complexity.VoteAggregateResult.Count == nil {
			break
		}

		return e.complexity.VoteAggregateResult.Count(childComplexity), true

	case "VoteAggregateResult.createdAtMax":
		if e.complexity.VoteAggregateResult.CreatedAtMax == nil {
			break
		}

		return e.complexity.VoteAggregateResult.CreatedAtMax(childComplexity), true

	case "VoteAggregateResult.createdAtMin":
		if e.complexity.VoteAggregateResult.CreatedAtMin == nil {
			break
		}

		return e.complexity.VoteAggregateResult.CreatedAtMin(childComplexity), true

	case "VoteAggregateResult.messageMax":
		if e.complexity.VoteAggregateResult.MessageMax == nil {
			break
		}

		return e.complexity.VoteAggregateResult.MessageMax(childComplexity), true

	case "VoteAggregateResult.messageMin":
		if e.complexity.VoteAggregateResult.MessageMin == nil {
			break
		}

		return e.complexity.VoteAggregateResult.MessageMin(childComplexity), true

	case "VoteAggregateResult.updatedAtMax":
		if e.complexity.VoteAggregateResult.UpdatedAtMax == nil {
			break
		}

		return e.complexity.VoteAggregateResult.UpdatedAtMax(childComplexity), true

	case "VoteAggregateResult.updatedAtMin":
		if e.complexity.VoteAggregateResult.UpdatedAtMin == nil {
			break
		}

		return e.complexity.VoteAggregateResult.UpdatedAtMin(childComplexity), true

	case "VoteAggregateResult.voteidMax":
		if e.complexity.VoteAggregateResult.VoteidMax == nil {
			break
		}

		return e.complexity.VoteAggregateResult.VoteidMax(childComplexity), true

	case "VoteAggregateResult.voteidMin":
		if e.complexity.VoteAggregateResult.VoteidMin == nil {
			break
		}

		return e.complexity.VoteAggregateResult.VoteidMin(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAddBlobInput,
		ec.unmarshalInputAddCommentInput,
		ec.unmarshalInputAddContractInput,
		ec.unmarshalInputAddEventCountInput,
		ec.unmarshalInputAddEventFragmentInput,
		ec.unmarshalInputAddEventInput,
		ec.unmarshalInputAddLabelInput,
		ec.unmarshalInputAddMandateInput,
		ec.unmarshalInputAddNodeFragmentInput,
		ec.unmarshalInputAddNodeInput,
		ec.unmarshalInputAddNotifInput,
		ec.unmarshalInputAddOrgaAggInput,
		ec.unmarshalInputAddPendingUserInput,
		ec.unmarshalInputAddReactionInput,
		ec.unmarshalInputAddRoleExtInput,
		ec.unmarshalInputAddTensionInput,
		ec.unmarshalInputAddUserEventInput,
		ec.unmarshalInputAddUserInput,
		ec.unmarshalInputAddUserRightsInput,
		ec.unmarshalInputAddVoteInput,
		ec.unmarshalInputAuthRule,
		ec.unmarshalInputBlobFilter,
		ec.unmarshalInputBlobOrder,
		ec.unmarshalInputBlobPatch,
		ec.unmarshalInputBlobRef,
		ec.unmarshalInputBlobType_hash,
		ec.unmarshalInputCommentFilter,
		ec.unmarshalInputCommentOrder,
		ec.unmarshalInputCommentPatch,
		ec.unmarshalInputCommentRef,
		ec.unmarshalInputContainsFilter,
		ec.unmarshalInputContractFilter,
		ec.unmarshalInputContractOrder,
		ec.unmarshalInputContractPatch,
		ec.unmarshalInputContractRef,
		ec.unmarshalInputContractStatus_hash,
		ec.unmarshalInputContractType_hash,
		ec.unmarshalInputCustomHTTP,
		ec.unmarshalInputDateTimeFilter,
		ec.unmarshalInputDateTimeRange,
		ec.unmarshalInputDgraphDefault,
		ec.unmarshalInputEventCountFilter,
		ec.unmarshalInputEventCountOrder,
		ec.unmarshalInputEventCountPatch,
		ec.unmarshalInputEventCountRef,
		ec.unmarshalInputEventFilter,
		ec.unmarshalInputEventFragmentFilter,
		ec.unmarshalInputEventFragmentOrder,
		ec.unmarshalInputEventFragmentPatch,
		ec.unmarshalInputEventFragmentRef,
		ec.unmarshalInputEventKindFilter,
		ec.unmarshalInputEventKindRef,
		ec.unmarshalInputEventOrder,
		ec.unmarshalInputEventPatch,
		ec.unmarshalInputEventRef,
		ec.unmarshalInputFloatFilter,
		ec.unmarshalInputFloatRange,
		ec.unmarshalInputGenerateMutationParams,
		ec.unmarshalInputGenerateQueryParams,
		ec.unmarshalInputInt64Filter,
		ec.unmarshalInputInt64Range,
		ec.unmarshalInputIntFilter,
		ec.unmarshalInputIntRange,
		ec.unmarshalInputIntersectsFilter,
		ec.unmarshalInputLabelFilter,
		ec.unmarshalInputLabelOrder,
		ec.unmarshalInputLabelPatch,
		ec.unmarshalInputLabelRef,
		ec.unmarshalInputMandateFilter,
		ec.unmarshalInputMandateOrder,
		ec.unmarshalInputMandatePatch,
		ec.unmarshalInputMandateRef,
		ec.unmarshalInputMultiPolygonRef,
		ec.unmarshalInputNearFilter,
		ec.unmarshalInputNodeFilter,
		ec.unmarshalInputNodeFragmentFilter,
		ec.unmarshalInputNodeFragmentOrder,
		ec.unmarshalInputNodeFragmentPatch,
		ec.unmarshalInputNodeFragmentRef,
		ec.unmarshalInputNodeMode_hash,
		ec.unmarshalInputNodeOrder,
		ec.unmarshalInputNodePatch,
		ec.unmarshalInputNodeRef,
		ec.unmarshalInputNodeType_hash,
		ec.unmarshalInputNodeVisibility_hash,
		ec.unmarshalInputNotifFilter,
		ec.unmarshalInputNotifOrder,
		ec.unmarshalInputNotifPatch,
		ec.unmarshalInputNotifRef,
		ec.unmarshalInputOrgaAggFilter,
		ec.unmarshalInputOrgaAggOrder,
		ec.unmarshalInputOrgaAggPatch,
		ec.unmarshalInputOrgaAggRef,
		ec.unmarshalInputPendingUserFilter,
		ec.unmarshalInputPendingUserOrder,
		ec.unmarshalInputPendingUserPatch,
		ec.unmarshalInputPendingUserRef,
		ec.unmarshalInputPointGeoFilter,
		ec.unmarshalInputPointListRef,
		ec.unmarshalInputPointRef,
		ec.unmarshalInputPolygonGeoFilter,
		ec.unmarshalInputPolygonRef,
		ec.unmarshalInputPostFilter,
		ec.unmarshalInputPostOrder,
		ec.unmarshalInputPostPatch,
		ec.unmarshalInputPostRef,
		ec.unmarshalInputReactionFilter,
		ec.unmarshalInputReactionOrder,
		ec.unmarshalInputReactionPatch,
		ec.unmarshalInputReactionRef,
		ec.unmarshalInputRoleExtFilter,
		ec.unmarshalInputRoleExtOrder,
		ec.unmarshalInputRoleExtPatch,
		ec.unmarshalInputRoleExtRef,
		ec.unmarshalInputRoleType_hash,
		ec.unmarshalInputStringExactFilter,
		ec.unmarshalInputStringFullTextFilter,
		ec.unmarshalInputStringHashFilter,
		ec.unmarshalInputStringHashFilter_StringRegExpFilter,
		ec.unmarshalInputStringHashFilter_StringTermFilter,
		ec.unmarshalInputStringRange,
		ec.unmarshalInputStringRegExpFilter,
		ec.unmarshalInputStringTermFilter,
		ec.unmarshalInputTensionEvent_hash,
		ec.unmarshalInputTensionFilter,
		ec.unmarshalInputTensionOrder,
		ec.unmarshalInputTensionPatch,
		ec.unmarshalInputTensionRef,
		ec.unmarshalInputTensionStatus_hash,
		ec.unmarshalInputTensionType_hash,
		ec.unmarshalInputUpdateBlobInput,
		ec.unmarshalInputUpdateCommentInput,
		ec.unmarshalInputUpdateContractInput,
		ec.unmarshalInputUpdateEventCountInput,
		ec.unmarshalInputUpdateEventFragmentInput,
		ec.unmarshalInputUpdateEventInput,
		ec.unmarshalInputUpdateLabelInput,
		ec.unmarshalInputUpdateMandateInput,
		ec.unmarshalInputUpdateNodeFragmentInput,
		ec.unmarshalInputUpdateNodeInput,
		ec.unmarshalInputUpdateNotifInput,
		ec.unmarshalInputUpdateOrgaAggInput,
		ec.unmarshalInputUpdatePendingUserInput,
		ec.unmarshalInputUpdatePostInput,
		ec.unmarshalInputUpdateReactionInput,
		ec.unmarshalInputUpdateRoleExtInput,
		ec.unmarshalInputUpdateTensionInput,
		ec.unmarshalInputUpdateUserEventInput,
		ec.unmarshalInputUpdateUserInput,
		ec.unmarshalInputUpdateUserRightsInput,
		ec.unmarshalInputUpdateVoteInput,
		ec.unmarshalInputUserEventFilter,
		ec.unmarshalInputUserEventOrder,
		ec.unmarshalInputUserEventPatch,
		ec.unmarshalInputUserEventRef,
		ec.unmarshalInputUserFilter,
		ec.unmarshalInputUserOrder,
		ec.unmarshalInputUserPatch,
		ec.unmarshalInputUserRef,
		ec.unmarshalInputUserRightsFilter,
		ec.unmarshalInputUserRightsOrder,
		ec.unmarshalInputUserRightsPatch,
		ec.unmarshalInputUserRightsRef,
		ec.unmarshalInputVoteFilter,
		ec.unmarshalInputVoteOrder,
		ec.unmarshalInputVotePatch,
		ec.unmarshalInputVoteRef,
		ec.unmarshalInputWithinFilter,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._queryMiddleware(ctx, rc.Operation, func(ctx context.Context) (interface{}, error) {
				return ec._Query(ctx, rc.Operation.SelectionSet), nil
			})
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../schema/schema.graphql", Input: `
directive @hook_addLabelInput on ARGUMENT_DEFINITION
directive @hook_addLabel on FIELD_DEFINITION
directive @hook_updateLabelInput on ARGUMENT_DEFINITION
directive @hook_updateLabel on FIELD_DEFINITION
directive @hook_deleteLabelInput on ARGUMENT_DEFINITION
directive @hook_deleteLabel on FIELD_DEFINITION
directive @hook_addRoleExtInput on ARGUMENT_DEFINITION
directive @hook_addRoleExt on FIELD_DEFINITION
directive @hook_updateRoleExtInput on ARGUMENT_DEFINITION
directive @hook_updateRoleExt on FIELD_DEFINITION
directive @hook_deleteRoleExtInput on ARGUMENT_DEFINITION
directive @hook_deleteRoleExt on FIELD_DEFINITION
directive @hook_addTensionInput on ARGUMENT_DEFINITION
directive @hook_addTension on FIELD_DEFINITION
directive @hook_updateTensionInput on ARGUMENT_DEFINITION
directive @hook_updateTension on FIELD_DEFINITION
directive @hook_deleteTensionInput on ARGUMENT_DEFINITION
directive @hook_deleteTension on FIELD_DEFINITION
directive @hook_addCommentInput on ARGUMENT_DEFINITION
directive @hook_addComment on FIELD_DEFINITION
directive @hook_updateCommentInput on ARGUMENT_DEFINITION
directive @hook_updateComment on FIELD_DEFINITION
directive @hook_deleteCommentInput on ARGUMENT_DEFINITION
directive @hook_deleteComment on FIELD_DEFINITION
directive @hook_addReactionInput on ARGUMENT_DEFINITION
directive @hook_addReaction on FIELD_DEFINITION
directive @hook_updateReactionInput on ARGUMENT_DEFINITION
directive @hook_updateReaction on FIELD_DEFINITION
directive @hook_deleteReactionInput on ARGUMENT_DEFINITION
directive @hook_deleteReaction on FIELD_DEFINITION
directive @hook_addContractInput on ARGUMENT_DEFINITION
directive @hook_addContract on FIELD_DEFINITION
directive @hook_updateContractInput on ARGUMENT_DEFINITION
directive @hook_updateContract on FIELD_DEFINITION
directive @hook_deleteContractInput on ARGUMENT_DEFINITION
directive @hook_deleteContract on FIELD_DEFINITION
directive @hook_addVoteInput on ARGUMENT_DEFINITION
directive @hook_addVote on FIELD_DEFINITION
directive @hook_updateVoteInput on ARGUMENT_DEFINITION
directive @hook_updateVote on FIELD_DEFINITION
directive @hook_deleteVoteInput on ARGUMENT_DEFINITION
directive @hook_deleteVote on FIELD_DEFINITION
directive @hook_addUserInput on ARGUMENT_DEFINITION
directive @hook_addUser on FIELD_DEFINITION
directive @hook_updateUserInput on ARGUMENT_DEFINITION
directive @hook_updateUser on FIELD_DEFINITION
directive @hook_deleteUserInput on ARGUMENT_DEFINITION
directive @hook_deleteUser on FIELD_DEFINITION
directive @hook_getLabelInput on ARGUMENT_DEFINITION
directive @hook_queryLabelInput on ARGUMENT_DEFINITION
directive @hook_getRoleExtInput on ARGUMENT_DEFINITION
directive @hook_queryRoleExtInput on ARGUMENT_DEFINITION
directive @hook_getTensionInput on ARGUMENT_DEFINITION
directive @hook_queryTensionInput on ARGUMENT_DEFINITION
directive @hook_getCommentInput on ARGUMENT_DEFINITION
directive @hook_queryCommentInput on ARGUMENT_DEFINITION
directive @hook_getReactionInput on ARGUMENT_DEFINITION
directive @hook_queryReactionInput on ARGUMENT_DEFINITION
directive @hook_getContractInput on ARGUMENT_DEFINITION
directive @hook_queryContractInput on ARGUMENT_DEFINITION
directive @hook_getVoteInput on ARGUMENT_DEFINITION
directive @hook_queryVoteInput on ARGUMENT_DEFINITION
directive @hook_getUserInput on ARGUMENT_DEFINITION
directive @hook_queryUserInput on ARGUMENT_DEFINITION


directive @hidden on FIELD_DEFINITION

directive @private on FIELD_DEFINITION

directive @meta(f: String!, k: String) on FIELD_DEFINITION

directive @isContractValidator on FIELD_DEFINITION

directive @x_add(r: String, f: String, e: [TensionEvent!], n: Int) on INPUT_FIELD_DEFINITION

directive @x_set(r: String, f: String, e: [TensionEvent!], n: Int) on INPUT_FIELD_DEFINITION

directive @x_remove(r: String, f: String, e: [TensionEvent!], n: Int) on INPUT_FIELD_DEFINITION

directive @x_patch(r: String, f: String, e: [TensionEvent!], n: Int) on INPUT_FIELD_DEFINITION

directive @x_alter(r: String, f: String, e: [TensionEvent!], n: Int) on INPUT_FIELD_DEFINITION

directive @x_patch_ro on INPUT_FIELD_DEFINITION

directive @x_ro on INPUT_FIELD_DEFINITION

directive @w_add(a: String!) on INPUT_FIELD_DEFINITION

directive @w_set(a: String!) on INPUT_FIELD_DEFINITION

directive @w_remove(a: String!) on INPUT_FIELD_DEFINITION

directive @w_patch(a: String!) on INPUT_FIELD_DEFINITION

directive @w_alter(a: String!) on INPUT_FIELD_DEFINITION

directive @w_meta_patch(f: String!, k: String) on INPUT_FIELD_DEFINITION

type Node {
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime
  nameid: String!
  rootnameid: String!
  source(filter: BlobFilter): Blob
  name: String!
  about: String
  skills: [String!]
  isRoot: Boolean!
  parent(filter: NodeFilter): Node
  type_: NodeType!
  tensions_out(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension!]
  tensions_in(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension!]
  visibility: NodeVisibility!
  mode: NodeMode!
  rights: Int!
  isArchived: Boolean!
  isPersonal: Boolean
  userCanJoin: Boolean
  guestCanCreateTension: Boolean
  children(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node!]
  labels(filter: LabelFilter, order: LabelOrder, first: Int, offset: Int): [Label!]
  roles(filter: RoleExtFilter, order: RoleExtOrder, first: Int, offset: Int): [RoleExt!]
  role_ext(filter: RoleExtFilter): RoleExt
  role_type: RoleType
  color: String
  first_link(filter: UserFilter): User
  second_link(filter: UserFilter): User
  contracts(filter: VoteFilter, order: VoteOrder, first: Int, offset: Int): [Vote!]
  watchers(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User!]
  orga_agg(filter: OrgaAggFilter): OrgaAgg @meta(f:"getOrgaAgg", k:"nameid")
  events_history(filter: EventFilter, order: EventOrder, first: Int, offset: Int): [Event!] @meta(f:"getNodeHistory", k:"nameid")

  tensions_outAggregate(filter: TensionFilter): TensionAggregateResult
  tensions_inAggregate(filter: TensionFilter): TensionAggregateResult
  childrenAggregate(filter: NodeFilter): NodeAggregateResult
  labelsAggregate(filter: LabelFilter): LabelAggregateResult
  rolesAggregate(filter: RoleExtFilter): RoleExtAggregateResult
  contractsAggregate(filter: VoteFilter): VoteAggregateResult
  watchersAggregate(filter: UserFilter): UserAggregateResult
  events_historyAggregate(filter: EventFilter): EventAggregateResult
}

type NodeFragment {
  id: ID!
  nameid: String
  name: String
  about: String
  mandate(filter: MandateFilter): Mandate
  skills: [String!]
  visibility: NodeVisibility
  mode: NodeMode
  type_: NodeType
  first_link: String
  second_link: String
  role_ext: String
  role_type: RoleType
  color: String
}

type Mandate {
  id: ID!
  purpose: String!
  responsabilities: String
  domains: String
  policies: String
}

type Label {
  id: ID!
  rootnameid: String!
  name: String!
  description: String
  color: String
  tensions(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension!]
  nodes(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node!]

  tensionsAggregate(filter: TensionFilter): TensionAggregateResult
  nodesAggregate(filter: NodeFilter): NodeAggregateResult
}

type RoleExt {
  id: ID!
  rootnameid: String!
  name: String!
  about: String
  role_type: RoleType!
  color: String
  mandate(filter: MandateFilter): Mandate
  roles(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node!]
  nodes(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node!]

  rolesAggregate(filter: NodeFilter): NodeAggregateResult
  nodesAggregate(filter: NodeFilter): NodeAggregateResult
}

type OrgaAgg {
  n_members: Int
  n_guests: Int
}

type Post {
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime
  message: String
}

type Tension {
  emitter(filter: NodeFilter): Node!
  emitterid: String!
  receiver(filter: NodeFilter): Node!
  receiverid: String!
  title: String!
  type_: TensionType!
  status: TensionStatus!
  action: TensionAction
  comments(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment!]
  assignees(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User!]
  labels(filter: LabelFilter, order: LabelOrder, first: Int, offset: Int): [Label!]
  blobs(filter: BlobFilter, order: BlobOrder, first: Int, offset: Int): [Blob!]
  history(filter: EventFilter, order: EventOrder, first: Int, offset: Int): [Event!]
  mentions(filter: EventFilter, order: EventOrder, first: Int, offset: Int): [Event!]
  contracts(filter: ContractFilter, order: ContractOrder, first: Int, offset: Int): [Contract!]
  subscribers(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User!]
  n_comments: Int
  n_open_contracts: Int
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime
  message: String

  commentsAggregate(filter: CommentFilter): CommentAggregateResult
  assigneesAggregate(filter: UserFilter): UserAggregateResult
  labelsAggregate(filter: LabelFilter): LabelAggregateResult
  blobsAggregate(filter: BlobFilter): BlobAggregateResult
  historyAggregate(filter: EventFilter): EventAggregateResult
  mentionsAggregate(filter: EventFilter): EventAggregateResult
  contractsAggregate(filter: ContractFilter): ContractAggregateResult
  subscribersAggregate(filter: UserFilter): UserAggregateResult
}

type Comment {
  message: String!
  reactions(filter: ReactionFilter, order: ReactionOrder, first: Int, offset: Int): [Reaction!]
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime

  reactionsAggregate(filter: ReactionFilter): ReactionAggregateResult
}

type Reaction {
  id: ID!
  reactionid: String
  user(filter: UserFilter): User!
  comment(filter: CommentFilter): Comment!
  type_: Int!
}

type Blob {
  tension(filter: TensionFilter): Tension!
  blob_type: BlobType!
  pushedFlag: DateTime
  archivedFlag: DateTime
  node(filter: NodeFragmentFilter): NodeFragment
  md: String
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime
  message: String
}

type Event {
  tension(filter: TensionFilter): Tension!
  event_type: TensionEvent!
  mentioned(filter: TensionFilter): Tension
  old: String
  new: String
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime
  message: String
}

type EventFragment {
  event_type: TensionEvent!
  old: String
  new: String
}

type Contract {
  contractid: String!
  tension(filter: TensionFilter): Tension!
  status: ContractStatus!
  contract_type: ContractType!
  closedAt: DateTime
  event(filter: EventFragmentFilter): EventFragment!
  participants(filter: VoteFilter, order: VoteOrder, first: Int, offset: Int): [Vote!]!
  candidates(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User!]
  pending_candidates(filter: PendingUserFilter, order: PendingUserOrder, first: Int, offset: Int): [PendingUser!]
  comments(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment!]
  isValidator: Boolean @isContractValidator
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime
  message: String

  participantsAggregate(filter: VoteFilter): VoteAggregateResult
  candidatesAggregate(filter: UserFilter): UserAggregateResult
  pending_candidatesAggregate(filter: PendingUserFilter): PendingUserAggregateResult
  commentsAggregate(filter: CommentFilter): CommentAggregateResult
}

type Vote {
  voteid: String!
  contract(filter: ContractFilter): Contract!
  node(filter: NodeFilter): Node!
  data: [Int!]!
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime
  message: String
}

type User {
  id: ID!
  createdAt: DateTime!
  lastAck: DateTime!
  username: String!
  name: String
  email: String! @private
  password: String! @hidden
  bio: String
  location: String
  utc: String
  links: [String!]
  skills: [String!]
  notifyByEmail: Boolean!
  lang: Lang!
  subscriptions(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension!] @private
  watching(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node!] @private
  rights(filter: UserRightsFilter): UserRights!
  roles(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node!]
  backed_roles(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node!]
  tensions_created(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension!] @private
  tensions_assigned(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension!] @private
  contracts(filter: ContractFilter, order: ContractOrder, first: Int, offset: Int): [Contract!] @private
  reactions(filter: ReactionFilter, order: ReactionOrder, first: Int, offset: Int): [Reaction!]
  events(filter: UserEventFilter, order: UserEventOrder, first: Int, offset: Int): [UserEvent!] @private
  markAllAsRead: String
  event_count(filter: EventCountFilter): EventCount @meta(f:"getEventCount", k:"username")

  subscriptionsAggregate(filter: TensionFilter): TensionAggregateResult
  watchingAggregate(filter: NodeFilter): NodeAggregateResult
  rolesAggregate(filter: NodeFilter): NodeAggregateResult
  backed_rolesAggregate(filter: NodeFilter): NodeAggregateResult
  tensions_createdAggregate(filter: TensionFilter): TensionAggregateResult
  tensions_assignedAggregate(filter: TensionFilter): TensionAggregateResult
  contractsAggregate(filter: ContractFilter): ContractAggregateResult
  reactionsAggregate(filter: ReactionFilter): ReactionAggregateResult
  eventsAggregate(filter: UserEventFilter): UserEventAggregateResult
}

type PendingUser {
  id: ID!
  updatedAt: DateTime
  username: String
  password: String @hidden
  email: String @hidden
  email_token: String @hidden
  token: String @hidden
  contracts(filter: ContractFilter, order: ContractOrder, first: Int, offset: Int): [Contract!]
  subscribe: Boolean

  contractsAggregate(filter: ContractFilter): ContractAggregateResult
}

type UserRights {
  type_: UserType!
  canLogin: Boolean!
  canCreateRoot: Boolean!
  maxPublicOrga: Int!
  maxPrivateOrga: Int!
  hasEmailNotifications: Boolean!
}

type UserEvent {
  id: ID!
  createdAt: DateTime!
  isRead: Boolean!
  user(filter: UserFilter): User!
  event(filter: EventKindFilter, first: Int, offset: Int): [EventKind!]
}

union EventKind= Event| Contract| Notif

type Notif {
  tension_(filter: TensionFilter): Tension
  contract(filter: ContractFilter): Contract
  link: String
  id: ID!
  createdBy(filter: UserFilter): User!
  createdAt: DateTime!
  updatedAt: DateTime
  message: String
}

type EventCount {
  unread_events: Int
  pending_contracts: Int
  assigned_tensions: Int
}

enum NodeType {
  Circle
  Role
}

enum RoleType {


  Owner

  Member

  Guest

  Retired

  Pending


  Coordinator

  Peer

  Bot

}

enum NodeVisibility {
  Public

  Private

  Secret

}

enum NodeMode {
  Coordinated

  Agile

}

enum TensionStatus {
  Open
  Closed
}

enum TensionType {
  Operational
  Governance
  Help
  Alert
  Announcement

}

enum TensionAction {

  NewRole
  NewCircle
  NewMd

  EditRole
  EditCircle
  EditMd

  ArchivedRole
  ArchivedCircle
  ArchivedMd




}

enum TensionEvent {

  Created
  Reopened
  Closed
  TitleUpdated
  TypeUpdated
  CommentPushed
  AssigneeAdded
  AssigneeRemoved
  LabelAdded
  LabelRemoved
  BlobCreated
  BlobCommitted
  Mentioned

  BlobPushed
  BlobArchived
  BlobUnarchived
  UserJoined
  UserLeft
  MemberLinked
  MemberUnlinked
  Authority
  Visibility
  Moved
}

enum BlobType {

  OnNode
  OnAbout
  OnMandate
  OnAboutAndMandate

  OnDoc

}

enum ContractStatus {
  Open
  Closed
  Canceled
}

enum ContractType {


  AnyCoordoDual

  AnyCandidates


  AnyCoordoSource

  AnyCoordoTarget
}

enum UserType {
  Regular

  Pro

  Root

}

enum Lang {
  EN
  FR
}

# Dgraph.Authorization {"Header":"X-Frac6-Auth","Namespace":"https://fractale.co/jwt/claims","Algo":"RS256","VerificationKey":"-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqfBbJAanlwf2mYlBszBA\nxgHw3hTu6gZ9nmej+5fCCdyA85IXhw14+F14o+vLogPe/giFuPMpG9eCOPWKvL/T\nGyahW5Lm8TRB4Pf54fZq5+VKdf5/i9u2e8CelpFvT+zLRdBmNVy9H9MitOF9mSGK\nHviPH1nHzU6TGvuVf44s60LAKliiwagALF+T/3ReDFhoqdLb1J3w4JkxFO6Guw5p\n3aDT+RMjjz9W8XpT3+k8IHocWxcEsuWMKdhuNwOHX2l7yU+/yLOrK1nuAMH7KewC\nCT4gJOan1qFO8NKe37jeQgsuRbhtF5C+L6CKs3n+B2A3ZOYB4gzdJfMLXxW/wwr1\nRQIDAQAB\n-----END PUBLIC KEY-----"}

directive @withSubscription on OBJECT|INTERFACE|FIELD_DEFINITION

directive @auth(password: AuthRule, query: AuthRule, add: AuthRule, update: AuthRule, delete: AuthRule) on OBJECT|INTERFACE

directive @custom(http: CustomHTTP, dql: String) on FIELD_DEFINITION

directive @lambda on FIELD_DEFINITION

directive @cacheControl(maxAge: Int!) on QUERY

directive @generate(query: GenerateQueryParams, mutation: GenerateMutationParams, subscription: Boolean) on OBJECT|INTERFACE

directive @id(interface: Boolean) on FIELD_DEFINITION

directive @default(add: DgraphDefault, update: DgraphDefault) on FIELD_DEFINITION

directive @cascade(fields: [String]) on FIELD

directive @lambdaOnMutate(add: Boolean, update: Boolean, delete: Boolean) on OBJECT|INTERFACE

directive @hasInverse(field: String!) on FIELD_DEFINITION

directive @search(by: [DgraphIndex!]) on FIELD_DEFINITION

directive @dgraph(type: String, pred: String) on OBJECT|INTERFACE|FIELD_DEFINITION

directive @secret(field: String!, pred: String) on OBJECT|INTERFACE

directive @remote on OBJECT|INTERFACE|UNION|INPUT_OBJECT|ENUM

directive @remoteResponse(name: String) on FIELD_DEFINITION

input AddBlobInput {
  createdBy: UserRef!
  createdAt: DateTime!
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String
  tension: TensionRef! @x_add(r:"ref")
  blob_type: BlobType!
  pushedFlag: DateTime
  archivedFlag: DateTime
  node: NodeFragmentRef
  md: String
}

type AddBlobPayload {
  blob(filter: BlobFilter, order: BlobOrder, first: Int, offset: Int): [Blob]
  numUids: Int
}

input AddCommentInput {
  createdBy: UserRef!
  createdAt: DateTime!
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String
  reactions: [ReactionRef!]
}

type AddCommentPayload {
  comment(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment]
  numUids: Int
}

input AddContractInput {
  createdBy: UserRef!
  createdAt: DateTime!
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String
  contractid: String!
  tension: TensionRef! @x_add(r:"ref")
  status: ContractStatus!
  contract_type: ContractType!
  closedAt: DateTime
  event: EventFragmentRef!
  participants: [VoteRef!]!
  candidates: [UserRef!]
  pending_candidates: [PendingUserRef!]
  comments: [CommentRef!] @x_alter(r:"oneByOne")
  isValidator: Boolean
}

type AddContractPayload {
  contract(filter: ContractFilter, order: ContractOrder, first: Int, offset: Int): [Contract]
  numUids: Int
}

input AddEventCountInput {
  unread_events: Int
  pending_contracts: Int
  assigned_tensions: Int
}

type AddEventCountPayload {
  eventCount(filter: EventCountFilter, order: EventCountOrder, first: Int, offset: Int): [EventCount]
  numUids: Int
}

input AddEventFragmentInput {
  event_type: TensionEvent!
  old: String
  new: String
}

type AddEventFragmentPayload {
  eventFragment(filter: EventFragmentFilter, order: EventFragmentOrder, first: Int, offset: Int): [EventFragment]
  numUids: Int
}

input AddEventInput {
  createdBy: UserRef!
  createdAt: DateTime!
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String
  tension: TensionRef! @x_add(r:"ref")
  event_type: TensionEvent!
  mentioned: TensionRef @x_add(r:"ref")
  old: String
  new: String
}

type AddEventPayload {
  event(filter: EventFilter, order: EventOrder, first: Int, offset: Int): [Event]
  numUids: Int
}

input AddLabelInput {
  rootnameid: String!
  name: String! @w_alter(a:"lower") @x_alter(r:"unique", f:"rootnameid") @x_alter(r:"minLen", n:1)
  description: String @x_alter(r:"maxLen", n:280)
  color: String
  tensions: [TensionRef!]
  nodes: [NodeRef!] @x_alter(r:"oneByOne") @x_alter(r:"ref")
}

type AddLabelPayload {
  label(filter: LabelFilter, order: LabelOrder, first: Int, offset: Int): [Label]
  numUids: Int
}

input AddMandateInput {
  purpose: String!
  responsabilities: String
  domains: String
  policies: String
}

type AddMandatePayload {
  mandate(filter: MandateFilter, order: MandateOrder, first: Int, offset: Int): [Mandate]
  numUids: Int
}

input AddNodeFragmentInput {
  nameid: String @w_add(a:"lower")
  name: String @x_alter(r:"minLen", n:1)
  about: String @x_alter(r:"maxLen", n:280)
  mandate: MandateRef
  skills: [String!]
  visibility: NodeVisibility
  mode: NodeMode
  type_: NodeType
  first_link: String
  second_link: String
  role_ext: String
  role_type: RoleType
  color: String
}

type AddNodeFragmentPayload {
  nodeFragment(filter: NodeFragmentFilter, order: NodeFragmentOrder, first: Int, offset: Int): [NodeFragment]
  numUids: Int
}

input AddNodeInput {
  createdBy: UserRef!
  createdAt: DateTime!
  updatedAt: DateTime
  nameid: String!
  rootnameid: String!
  source: BlobRef
  name: String!
  about: String
  skills: [String!]
  isRoot: Boolean!
  parent: NodeRef
  type_: NodeType!
  tensions_out: [TensionRef!]
  tensions_in: [TensionRef!]
  visibility: NodeVisibility!
  mode: NodeMode!
  rights: Int!
  isArchived: Boolean!
  isPersonal: Boolean
  userCanJoin: Boolean
  guestCanCreateTension: Boolean
  children: [NodeRef!]
  labels: [LabelRef!]
  roles: [RoleExtRef!]
  role_ext: RoleExtRef
  role_type: RoleType
  color: String
  first_link: UserRef
  second_link: UserRef
  contracts: [VoteRef!]
  watchers: [UserRef!]
  orga_agg: OrgaAggRef
  events_history: [EventRef!]
}

type AddNodePayload {
  node(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node]
  numUids: Int
}

input AddNotifInput {
  createdBy: UserRef!
  createdAt: DateTime!
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String
  tension_: TensionRef
  contract: ContractRef
  link: String
}

type AddNotifPayload {
  notif(filter: NotifFilter, order: NotifOrder, first: Int, offset: Int): [Notif]
  numUids: Int
}

input AddOrgaAggInput {
  n_members: Int
  n_guests: Int
}

type AddOrgaAggPayload {
  orgaAgg(filter: OrgaAggFilter, order: OrgaAggOrder, first: Int, offset: Int): [OrgaAgg]
  numUids: Int
}

input AddPendingUserInput {
  updatedAt: DateTime
  username: String @w_alter(a:"lower")
  password: String
  email: String @w_alter(a:"lower")
  email_token: String
  token: String
  contracts: [ContractRef!]
  subscribe: Boolean
}

type AddPendingUserPayload {
  pendingUser(filter: PendingUserFilter, order: PendingUserOrder, first: Int, offset: Int): [PendingUser]
  numUids: Int
}

input AddReactionInput {
  reactionid: String
  user: UserRef! @x_add(r:"ref")
  comment: CommentRef! @x_add(r:"ref")
  type_: Int!
}

type AddReactionPayload {
  reaction(filter: ReactionFilter, order: ReactionOrder, first: Int, offset: Int): [Reaction]
  numUids: Int
}

input AddRoleExtInput {
  rootnameid: String!
  name: String! @w_alter(a:"lower") @x_alter(r:"unique", f:"rootnameid") @x_alter(r:"minLen", n:1)
  about: String @x_alter(r:"maxLen", n:280)
  role_type: RoleType!
  color: String
  mandate: MandateRef
  roles: [NodeRef!]
  nodes: [NodeRef!] @x_alter(r:"oneByOne") @x_alter(r:"ref")
}

type AddRoleExtPayload {
  roleExt(filter: RoleExtFilter, order: RoleExtOrder, first: Int, offset: Int): [RoleExt]
  numUids: Int
}

input AddTensionInput {
  createdBy: UserRef!
  createdAt: DateTime!
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String
  emitter: NodeRef!
  emitterid: String!
  receiver: NodeRef!
  receiverid: String!
  title: String!
  type_: TensionType! @x_alter(r:"tensionTypeCheck")
  status: TensionStatus!
  action: TensionAction
  comments: [CommentRef!] @x_alter(r:"hasEvent", e:[Created, CommentPushed]) @x_alter(r:"oneByOne")
  assignees: [UserRef!] @x_alter(r:"hasEvent", e:[AssigneeAdded, AssigneeRemoved]) @x_alter(r:"oneByOne") @x_alter(r:"ref")
  labels: [LabelRef!] @x_alter(r:"hasEvent", e:[LabelAdded, LabelRemoved]) @x_alter(r:"oneByOne") @x_alter(r:"ref")
  blobs: [BlobRef!] @x_alter(r:"hasEvent", e:[BlobCreated, BlobCommitted]) @x_alter(r:"oneByOne")
  history: [EventRef!]
  mentions: [EventRef!]
  contracts: [ContractRef!] @x_add(r:"ref")
  subscribers: [UserRef!]
  n_comments: Int
  n_open_contracts: Int
}

type AddTensionPayload {
  tension(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension]
  numUids: Int
}

input AddUserEventInput {
  createdAt: DateTime!
  isRead: Boolean!
  user: UserRef!
  event: [EventKindRef!] @x_add(r:"ref")
}

type AddUserEventPayload {
  userEvent(filter: UserEventFilter, order: UserEventOrder, first: Int, offset: Int): [UserEvent]
  numUids: Int
}

input AddUserInput {
  createdAt: DateTime!
  lastAck: DateTime!
  username: String! @w_add(a:"lower")
  name: String
  email: String! @w_add(a:"lower")
  password: String!
  bio: String @x_alter(r:"maxLen", n:280)
  location: String
  utc: String
  links: [String!]
  skills: [String!]
  notifyByEmail: Boolean!
  lang: Lang!
  subscriptions: [TensionRef!] @x_alter(r:"ref")
  watching: [NodeRef!] @x_alter(r:"ref")
  rights: UserRightsRef!
  roles: [NodeRef!] @x_add(r:"ref")
  backed_roles: [NodeRef!] @x_add(r:"ref")
  tensions_created: [TensionRef!] @x_add(r:"ref")
  tensions_assigned: [TensionRef!] @x_add(r:"ref")
  contracts: [ContractRef!] @x_add(r:"ref")
  reactions: [ReactionRef!]
  events: [UserEventRef!]
  markAllAsRead: String
  event_count: EventCountRef
}

type AddUserPayload {
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  numUids: Int
}

input AddUserRightsInput {
  type_: UserType!
  canLogin: Boolean!
  canCreateRoot: Boolean!
  maxPublicOrga: Int!
  maxPrivateOrga: Int!
  hasEmailNotifications: Boolean!
}

type AddUserRightsPayload {
  userRights(filter: UserRightsFilter, order: UserRightsOrder, first: Int, offset: Int): [UserRights]
  numUids: Int
}

input AddVoteInput {
  createdBy: UserRef!
  createdAt: DateTime!
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String
  voteid: String!
  contract: ContractRef! @x_add(r:"ref")
  node: NodeRef! @x_add(r:"ref")
  data: [Int!]!
}

type AddVotePayload {
  vote(filter: VoteFilter, order: VoteOrder, first: Int, offset: Int): [Vote]
  numUids: Int
}

input AuthRule {
  and: [AuthRule]
  or: [AuthRule]
  not: AuthRule
  rule: String
}

type BlobAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  messageMin: String
  messageMax: String
  pushedFlagMin: DateTime
  pushedFlagMax: DateTime
  archivedFlagMin: DateTime
  archivedFlagMax: DateTime
  mdMin: String
  mdMax: String
}

input BlobFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  blob_type: BlobType_hash
  pushedFlag: DateTimeFilter
  archivedFlag: DateTimeFilter
  has: [BlobHasFilter]
  and: [BlobFilter]
  or: [BlobFilter]
  not: BlobFilter
}

enum BlobHasFilter {
  createdBy
  createdAt
  updatedAt
  message
  tension
  blob_type
  pushedFlag
  archivedFlag
  node
  md
}

input BlobOrder {
  asc: BlobOrderable
  desc: BlobOrderable
  then: BlobOrder
}

enum BlobOrderable {
  createdAt
  updatedAt
  message
  pushedFlag
  archivedFlag
  md
}

input BlobPatch {
  createdBy: UserRef @x_patch_ro
  createdAt: DateTime @x_patch_ro
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_patch_ro
  tension: TensionRef @x_patch_ro
  blob_type: BlobType @x_patch_ro
  pushedFlag: DateTime @x_patch_ro
  archivedFlag: DateTime @x_patch_ro
  node: NodeFragmentRef @x_patch_ro
  md: String @x_patch_ro
}

input BlobRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String
  tension: TensionRef @x_add(r:"ref")
  blob_type: BlobType
  pushedFlag: DateTime
  archivedFlag: DateTime
  node: NodeFragmentRef
  md: String
}

input BlobType_hash {
  eq: BlobType
  in: [BlobType]
}

type CommentAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  messageMin: String
  messageMax: String
}

input CommentFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  has: [CommentHasFilter]
  and: [CommentFilter]
  or: [CommentFilter]
  not: CommentFilter
}

enum CommentHasFilter {
  createdBy
  createdAt
  updatedAt
  message
  reactions
}

input CommentOrder {
  asc: CommentOrderable
  desc: CommentOrderable
  then: CommentOrder
}

enum CommentOrderable {
  createdAt
  updatedAt
  message
}

input CommentPatch {
  createdBy: UserRef @x_patch_ro
  createdAt: DateTime @x_patch_ro
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_alter
  reactions: [ReactionRef!] @x_patch_ro
}

input CommentRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_alter
  reactions: [ReactionRef!]
}

input ContainsFilter {
  point: PointRef
  polygon: PolygonRef
}

type ContractAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  messageMin: String
  messageMax: String
  contractidMin: String
  contractidMax: String
  closedAtMin: DateTime
  closedAtMax: DateTime
}

input ContractFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  contractid: StringHashFilter
  status: ContractStatus_hash
  contract_type: ContractType_hash
  closedAt: DateTimeFilter
  has: [ContractHasFilter]
  and: [ContractFilter]
  or: [ContractFilter]
  not: ContractFilter
}

enum ContractHasFilter {
  createdBy
  createdAt
  updatedAt
  message
  contractid
  tension
  status
  contract_type
  closedAt
  event
  participants
  candidates
  pending_candidates
  comments
  isValidator
}

input ContractOrder {
  asc: ContractOrderable
  desc: ContractOrderable
  then: ContractOrder
}

enum ContractOrderable {
  createdAt
  updatedAt
  message
  contractid
  closedAt
}

input ContractPatch {
  createdBy: UserRef @x_patch_ro
  createdAt: DateTime @x_patch_ro
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_patch_ro
  contractid: String @x_patch_ro
  tension: TensionRef @x_patch_ro
  status: ContractStatus @x_patch_ro
  contract_type: ContractType @x_patch_ro
  closedAt: DateTime @x_patch_ro
  event: EventFragmentRef @x_patch_ro
  participants: [VoteRef!] @x_patch_ro
  candidates: [UserRef!] @x_patch_ro
  pending_candidates: [PendingUserRef!] @x_patch_ro
  comments: [CommentRef!] @x_alter(r:"oneByOne")
  isValidator: Boolean @x_patch_ro
}

input ContractRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String
  contractid: String
  tension: TensionRef @x_add(r:"ref")
  status: ContractStatus
  contract_type: ContractType
  closedAt: DateTime
  event: EventFragmentRef
  participants: [VoteRef!]
  candidates: [UserRef!]
  pending_candidates: [PendingUserRef!]
  comments: [CommentRef!] @x_alter(r:"oneByOne")
  isValidator: Boolean
}

input ContractStatus_hash {
  eq: ContractStatus
  in: [ContractStatus]
}

input ContractType_hash {
  eq: ContractType
  in: [ContractType]
}

input CustomHTTP {
  url: String!
  method: HTTPMethod!
  body: String
  graphql: String
  mode: Mode
  forwardHeaders: [String!]
  secretHeaders: [String!]
  introspectionHeaders: [String!]
  skipIntrospection: Boolean
}

scalar DateTime

input DateTimeFilter {
  eq: DateTime
  in: [DateTime]
  le: DateTime
  lt: DateTime
  ge: DateTime
  gt: DateTime
  between: DateTimeRange
}

input DateTimeRange {
  min: DateTime!
  max: DateTime!
}

type DeleteBlobPayload {
  blob(filter: BlobFilter, order: BlobOrder, first: Int, offset: Int): [Blob]
  msg: String
  numUids: Int
}

type DeleteCommentPayload {
  comment(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment]
  msg: String
  numUids: Int
}

type DeleteContractPayload {
  contract(filter: ContractFilter, order: ContractOrder, first: Int, offset: Int): [Contract]
  msg: String
  numUids: Int
}

type DeleteEventCountPayload {
  eventCount(filter: EventCountFilter, order: EventCountOrder, first: Int, offset: Int): [EventCount]
  msg: String
  numUids: Int
}

type DeleteEventFragmentPayload {
  eventFragment(filter: EventFragmentFilter, order: EventFragmentOrder, first: Int, offset: Int): [EventFragment]
  msg: String
  numUids: Int
}

type DeleteEventPayload {
  event(filter: EventFilter, order: EventOrder, first: Int, offset: Int): [Event]
  msg: String
  numUids: Int
}

type DeleteLabelPayload {
  label(filter: LabelFilter, order: LabelOrder, first: Int, offset: Int): [Label]
  msg: String
  numUids: Int
}

type DeleteMandatePayload {
  mandate(filter: MandateFilter, order: MandateOrder, first: Int, offset: Int): [Mandate]
  msg: String
  numUids: Int
}

type DeleteNodeFragmentPayload {
  nodeFragment(filter: NodeFragmentFilter, order: NodeFragmentOrder, first: Int, offset: Int): [NodeFragment]
  msg: String
  numUids: Int
}

type DeleteNodePayload {
  node(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node]
  msg: String
  numUids: Int
}

type DeleteNotifPayload {
  notif(filter: NotifFilter, order: NotifOrder, first: Int, offset: Int): [Notif]
  msg: String
  numUids: Int
}

type DeleteOrgaAggPayload {
  orgaAgg(filter: OrgaAggFilter, order: OrgaAggOrder, first: Int, offset: Int): [OrgaAgg]
  msg: String
  numUids: Int
}

type DeletePendingUserPayload {
  pendingUser(filter: PendingUserFilter, order: PendingUserOrder, first: Int, offset: Int): [PendingUser]
  msg: String
  numUids: Int
}

type DeletePostPayload {
  post(filter: PostFilter, order: PostOrder, first: Int, offset: Int): [Post]
  msg: String
  numUids: Int
}

type DeleteReactionPayload {
  reaction(filter: ReactionFilter, order: ReactionOrder, first: Int, offset: Int): [Reaction]
  msg: String
  numUids: Int
}

type DeleteRoleExtPayload {
  roleExt(filter: RoleExtFilter, order: RoleExtOrder, first: Int, offset: Int): [RoleExt]
  msg: String
  numUids: Int
}

type DeleteTensionPayload {
  tension(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension]
  msg: String
  numUids: Int
}

type DeleteUserEventPayload {
  userEvent(filter: UserEventFilter, order: UserEventOrder, first: Int, offset: Int): [UserEvent]
  msg: String
  numUids: Int
}

type DeleteUserPayload {
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  msg: String
  numUids: Int
}

type DeleteUserRightsPayload {
  userRights(filter: UserRightsFilter, order: UserRightsOrder, first: Int, offset: Int): [UserRights]
  msg: String
  numUids: Int
}

type DeleteVotePayload {
  vote(filter: VoteFilter, order: VoteOrder, first: Int, offset: Int): [Vote]
  msg: String
  numUids: Int
}

input DgraphDefault {
  value: String
}

enum DgraphIndex {
  int
  int64
  float
  bool
  hash
  exact
  term
  fulltext
  trigram
  regexp
  year
  month
  day
  hour
  geo
}

enum ErrorBla {
  ContactCoordo
  OrgaLimitReached
  MemberLimitReached
  EmailLimitReached
  StorageLimitReached
}

type EventAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  messageMin: String
  messageMax: String
  oldMin: String
  oldMax: String
  newMin: String
  newMax: String
}

type EventCountAggregateResult {
  count: Int
  unread_eventsMin: Int
  unread_eventsMax: Int
  unread_eventsSum: Int
  unread_eventsAvg: Float
  pending_contractsMin: Int
  pending_contractsMax: Int
  pending_contractsSum: Int
  pending_contractsAvg: Float
  assigned_tensionsMin: Int
  assigned_tensionsMax: Int
  assigned_tensionsSum: Int
  assigned_tensionsAvg: Float
}

input EventCountFilter {
  has: [EventCountHasFilter]
  and: [EventCountFilter]
  or: [EventCountFilter]
  not: EventCountFilter
}

enum EventCountHasFilter {
  unread_events
  pending_contracts
  assigned_tensions
}

input EventCountOrder {
  asc: EventCountOrderable
  desc: EventCountOrderable
  then: EventCountOrder
}

enum EventCountOrderable {
  unread_events
  pending_contracts
  assigned_tensions
}

input EventCountPatch {
  unread_events: Int @x_patch_ro
  pending_contracts: Int @x_patch_ro
  assigned_tensions: Int @x_patch_ro
}

input EventCountRef {
  unread_events: Int
  pending_contracts: Int
  assigned_tensions: Int
}

input EventFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  event_type: TensionEvent_hash
  has: [EventHasFilter]
  and: [EventFilter]
  or: [EventFilter]
  not: EventFilter
}

type EventFragmentAggregateResult {
  count: Int
  oldMin: String
  oldMax: String
  newMin: String
  newMax: String
}

input EventFragmentFilter {
  event_type: TensionEvent_hash
  has: [EventFragmentHasFilter]
  and: [EventFragmentFilter]
  or: [EventFragmentFilter]
  not: EventFragmentFilter
}

enum EventFragmentHasFilter {
  event_type
  old
  new
}

input EventFragmentOrder {
  asc: EventFragmentOrderable
  desc: EventFragmentOrderable
  then: EventFragmentOrder
}

enum EventFragmentOrderable {
  old
  new
}

input EventFragmentPatch {
  event_type: TensionEvent @x_patch_ro
  old: String @x_patch_ro
  new: String @x_patch_ro
}

input EventFragmentRef {
  event_type: TensionEvent
  old: String
  new: String
}

enum EventHasFilter {
  createdBy
  createdAt
  updatedAt
  message
  tension
  event_type
  mentioned
  old
  new
}

input EventKindFilter {
  memberTypes: [EventKindType!]
  eventFilter: EventFilter
  contractFilter: ContractFilter
  notifFilter: NotifFilter
}

input EventKindRef {
  eventRef: EventRef
  contractRef: ContractRef
  notifRef: NotifRef
}

enum EventKindType {
  Event
  Contract
  Notif
}

input EventOrder {
  asc: EventOrderable
  desc: EventOrderable
  then: EventOrder
}

enum EventOrderable {
  createdAt
  updatedAt
  message
  old
  new
}

input EventPatch {
  createdBy: UserRef @x_patch_ro
  createdAt: DateTime @x_patch_ro
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_patch_ro
  tension: TensionRef @x_patch_ro
  event_type: TensionEvent @x_patch_ro
  mentioned: TensionRef @x_patch_ro
  old: String @x_patch_ro
  new: String @x_patch_ro
}

input EventRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String
  tension: TensionRef @x_add(r:"ref")
  event_type: TensionEvent
  mentioned: TensionRef @x_add(r:"ref")
  old: String
  new: String
}

input FloatFilter {
  eq: Float
  in: [Float]
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: FloatRange
}

input FloatRange {
  min: Float!
  max: Float!
}

input GenerateMutationParams {
  add: Boolean
  update: Boolean
  delete: Boolean
}

input GenerateQueryParams {
  get: Boolean
  query: Boolean
  password: Boolean
  aggregate: Boolean
}

enum HTTPMethod {
  GET
  POST
  PUT
  PATCH
  DELETE
}

scalar Int64

input Int64Filter {
  eq: Int64
  in: [Int64]
  le: Int64
  lt: Int64
  ge: Int64
  gt: Int64
  between: Int64Range
}

input Int64Range {
  min: Int64!
  max: Int64!
}

input IntersectsFilter {
  polygon: PolygonRef
  multiPolygon: MultiPolygonRef
}

input IntFilter {
  eq: Int
  in: [Int]
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: IntRange
}

input IntRange {
  min: Int!
  max: Int!
}

type LabelAggregateResult {
  count: Int
  rootnameidMin: String
  rootnameidMax: String
  nameMin: String
  nameMax: String
  descriptionMin: String
  descriptionMax: String
  colorMin: String
  colorMax: String
}

input LabelFilter {
  id: [ID!]
  rootnameid: StringHashFilter
  name: StringHashFilter_StringTermFilter
  has: [LabelHasFilter]
  and: [LabelFilter]
  or: [LabelFilter]
  not: LabelFilter
}

enum LabelHasFilter {
  rootnameid
  name
  description
  color
  tensions
  nodes
}

input LabelOrder {
  asc: LabelOrderable
  desc: LabelOrderable
  then: LabelOrder
}

enum LabelOrderable {
  rootnameid
  name
  description
  color
}

input LabelPatch {
  rootnameid: String @x_patch_ro
  name: String @w_alter(a:"lower") @x_alter(r:"unique", f:"rootnameid") @x_alter(r:"minLen", n:1)
  description: String @x_alter(r:"maxLen", n:280)
  color: String @x_alter
  tensions: [TensionRef!] @x_ro
  nodes: [NodeRef!] @x_alter(r:"oneByOne") @x_alter(r:"ref")
}

input LabelRef {
  id: ID
  rootnameid: String
  name: String @w_alter(a:"lower") @x_alter(r:"unique", f:"rootnameid") @x_alter(r:"minLen", n:1)
  description: String @x_alter(r:"maxLen", n:280)
  color: String @x_alter
  tensions: [TensionRef!] @x_ro
  nodes: [NodeRef!] @x_alter(r:"oneByOne") @x_alter(r:"ref")
}

type MandateAggregateResult {
  count: Int
  purposeMin: String
  purposeMax: String
  responsabilitiesMin: String
  responsabilitiesMax: String
  domainsMin: String
  domainsMax: String
  policiesMin: String
  policiesMax: String
}

input MandateFilter {
  id: [ID!]
  purpose: StringFullTextFilter
  has: [MandateHasFilter]
  and: [MandateFilter]
  or: [MandateFilter]
  not: MandateFilter
}

enum MandateHasFilter {
  purpose
  responsabilities
  domains
  policies
}

input MandateOrder {
  asc: MandateOrderable
  desc: MandateOrderable
  then: MandateOrder
}

enum MandateOrderable {
  purpose
  responsabilities
  domains
  policies
}

input MandatePatch {
  purpose: String @x_alter
  responsabilities: String @x_alter
  domains: String @x_alter
  policies: String @x_alter
}

input MandateRef {
  id: ID
  purpose: String @x_alter
  responsabilities: String @x_alter
  domains: String @x_alter
  policies: String @x_alter
}

enum Mode {
  BATCH
  SINGLE
}

type MultiPolygon {
  polygons: [Polygon!]!
}

input MultiPolygonRef {
  polygons: [PolygonRef!]!
}

type Mutation {
  addNode(input: [AddNodeInput!]!, upsert: Boolean): AddNodePayload
  updateNode(input: UpdateNodeInput!): UpdateNodePayload
  deleteNode(filter: NodeFilter!): DeleteNodePayload
  addNodeFragment(input: [AddNodeFragmentInput!]!): AddNodeFragmentPayload
  updateNodeFragment(input: UpdateNodeFragmentInput!): UpdateNodeFragmentPayload
  deleteNodeFragment(filter: NodeFragmentFilter!): DeleteNodeFragmentPayload
  addMandate(input: [AddMandateInput!]!): AddMandatePayload
  updateMandate(input: UpdateMandateInput!): UpdateMandatePayload
  deleteMandate(filter: MandateFilter!): DeleteMandatePayload
  addLabel(input: [AddLabelInput!]! @hook_addLabelInput): AddLabelPayload @hook_addLabel
  updateLabel(input: UpdateLabelInput! @hook_updateLabelInput): UpdateLabelPayload @hook_updateLabel
  deleteLabel(filter: LabelFilter! @hook_deleteLabelInput): DeleteLabelPayload @hook_deleteLabel
  addRoleExt(input: [AddRoleExtInput!]! @hook_addRoleExtInput): AddRoleExtPayload @hook_addRoleExt
  updateRoleExt(input: UpdateRoleExtInput! @hook_updateRoleExtInput): UpdateRoleExtPayload @hook_updateRoleExt
  deleteRoleExt(filter: RoleExtFilter! @hook_deleteRoleExtInput): DeleteRoleExtPayload @hook_deleteRoleExt
  addOrgaAgg(input: [AddOrgaAggInput!]!): AddOrgaAggPayload
  updateOrgaAgg(input: UpdateOrgaAggInput!): UpdateOrgaAggPayload
  deleteOrgaAgg(filter: OrgaAggFilter!): DeleteOrgaAggPayload
  updatePost(input: UpdatePostInput!): UpdatePostPayload
  deletePost(filter: PostFilter!): DeletePostPayload
  addTension(input: [AddTensionInput!]! @hook_addTensionInput): AddTensionPayload @hook_addTension
  updateTension(input: UpdateTensionInput! @hook_updateTensionInput): UpdateTensionPayload @hook_updateTension
  deleteTension(filter: TensionFilter! @hook_deleteTensionInput): DeleteTensionPayload @hook_deleteTension
  addComment(input: [AddCommentInput!]! @hook_addCommentInput): AddCommentPayload @hook_addComment
  updateComment(input: UpdateCommentInput! @hook_updateCommentInput): UpdateCommentPayload @hook_updateComment
  deleteComment(filter: CommentFilter! @hook_deleteCommentInput): DeleteCommentPayload @hook_deleteComment
  addReaction(input: [AddReactionInput!]! @hook_addReactionInput, upsert: Boolean): AddReactionPayload @hook_addReaction
  updateReaction(input: UpdateReactionInput! @hook_updateReactionInput): UpdateReactionPayload @hook_updateReaction
  deleteReaction(filter: ReactionFilter! @hook_deleteReactionInput): DeleteReactionPayload @hook_deleteReaction
  addBlob(input: [AddBlobInput!]!): AddBlobPayload
  updateBlob(input: UpdateBlobInput!): UpdateBlobPayload
  deleteBlob(filter: BlobFilter!): DeleteBlobPayload
  addEvent(input: [AddEventInput!]!): AddEventPayload
  updateEvent(input: UpdateEventInput!): UpdateEventPayload
  deleteEvent(filter: EventFilter!): DeleteEventPayload
  addEventFragment(input: [AddEventFragmentInput!]!): AddEventFragmentPayload
  updateEventFragment(input: UpdateEventFragmentInput!): UpdateEventFragmentPayload
  deleteEventFragment(filter: EventFragmentFilter!): DeleteEventFragmentPayload
  addContract(input: [AddContractInput!]! @hook_addContractInput, upsert: Boolean): AddContractPayload @hook_addContract
  updateContract(input: UpdateContractInput! @hook_updateContractInput): UpdateContractPayload @hook_updateContract
  deleteContract(filter: ContractFilter! @hook_deleteContractInput): DeleteContractPayload @hook_deleteContract
  addVote(input: [AddVoteInput!]! @hook_addVoteInput, upsert: Boolean): AddVotePayload @hook_addVote
  updateVote(input: UpdateVoteInput! @hook_updateVoteInput): UpdateVotePayload @hook_updateVote
  deleteVote(filter: VoteFilter! @hook_deleteVoteInput): DeleteVotePayload @hook_deleteVote
  addUser(input: [AddUserInput!]! @hook_addUserInput, upsert: Boolean): AddUserPayload @hook_addUser
  updateUser(input: UpdateUserInput! @hook_updateUserInput): UpdateUserPayload @hook_updateUser
  deleteUser(filter: UserFilter! @hook_deleteUserInput): DeleteUserPayload @hook_deleteUser
  addPendingUser(input: [AddPendingUserInput!]!, upsert: Boolean): AddPendingUserPayload
  updatePendingUser(input: UpdatePendingUserInput!): UpdatePendingUserPayload
  deletePendingUser(filter: PendingUserFilter!): DeletePendingUserPayload
  addUserRights(input: [AddUserRightsInput!]!): AddUserRightsPayload
  updateUserRights(input: UpdateUserRightsInput!): UpdateUserRightsPayload
  deleteUserRights(filter: UserRightsFilter!): DeleteUserRightsPayload
  addUserEvent(input: [AddUserEventInput!]!): AddUserEventPayload
  updateUserEvent(input: UpdateUserEventInput!): UpdateUserEventPayload
  deleteUserEvent(filter: UserEventFilter!): DeleteUserEventPayload
  addNotif(input: [AddNotifInput!]!): AddNotifPayload
  updateNotif(input: UpdateNotifInput!): UpdateNotifPayload
  deleteNotif(filter: NotifFilter!): DeleteNotifPayload
  addEventCount(input: [AddEventCountInput!]!): AddEventCountPayload
  updateEventCount(input: UpdateEventCountInput!): UpdateEventCountPayload
  deleteEventCount(filter: EventCountFilter!): DeleteEventCountPayload
}

input NearFilter {
  distance: Float!
  coordinate: PointRef!
}

type NodeAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  nameidMin: String
  nameidMax: String
  rootnameidMin: String
  rootnameidMax: String
  nameMin: String
  nameMax: String
  aboutMin: String
  aboutMax: String
  rightsMin: Int
  rightsMax: Int
  rightsSum: Int
  rightsAvg: Float
  colorMin: String
  colorMax: String
}

input NodeFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  nameid: StringHashFilter_StringRegExpFilter
  rootnameid: StringHashFilter_StringRegExpFilter
  name: StringTermFilter
  about: StringFullTextFilter
  skills: StringTermFilter
  isRoot: Boolean
  type_: NodeType_hash
  visibility: NodeVisibility_hash
  mode: NodeMode_hash
  isArchived: Boolean
  isPersonal: Boolean
  role_type: RoleType_hash
  has: [NodeHasFilter]
  and: [NodeFilter]
  or: [NodeFilter]
  not: NodeFilter
}

type NodeFragmentAggregateResult {
  count: Int
  nameidMin: String
  nameidMax: String
  nameMin: String
  nameMax: String
  aboutMin: String
  aboutMax: String
  first_linkMin: String
  first_linkMax: String
  second_linkMin: String
  second_linkMax: String
  role_extMin: String
  role_extMax: String
  colorMin: String
  colorMax: String
}

input NodeFragmentFilter {
  id: [ID!]
  has: [NodeFragmentHasFilter]
  and: [NodeFragmentFilter]
  or: [NodeFragmentFilter]
  not: NodeFragmentFilter
}

enum NodeFragmentHasFilter {
  nameid
  name
  about
  mandate
  skills
  visibility
  mode
  type_
  first_link
  second_link
  role_ext
  role_type
  color
}

input NodeFragmentOrder {
  asc: NodeFragmentOrderable
  desc: NodeFragmentOrderable
  then: NodeFragmentOrder
}

enum NodeFragmentOrderable {
  nameid
  name
  about
  first_link
  second_link
  role_ext
  color
}

input NodeFragmentPatch {
  nameid: String @x_patch_ro
  name: String @x_alter(r:"minLen", n:1)
  about: String @x_alter(r:"maxLen", n:280)
  mandate: MandateRef @x_alter
  skills: [String!] @x_alter
  visibility: NodeVisibility @x_patch_ro
  mode: NodeMode @x_patch_ro
  type_: NodeType @x_patch_ro
  first_link: String @x_patch_ro
  second_link: String @x_patch_ro
  role_ext: String @x_patch_ro
  role_type: RoleType @x_patch_ro
  color: String @x_patch_ro
}

input NodeFragmentRef {
  id: ID
  nameid: String @w_add(a:"lower")
  name: String @x_alter(r:"minLen", n:1)
  about: String @x_alter(r:"maxLen", n:280)
  mandate: MandateRef @x_alter
  skills: [String!] @x_alter
  visibility: NodeVisibility
  mode: NodeMode
  type_: NodeType
  first_link: String
  second_link: String
  role_ext: String
  role_type: RoleType
  color: String
}

enum NodeHasFilter {
  createdBy
  createdAt
  updatedAt
  nameid
  rootnameid
  source
  name
  about
  skills
  isRoot
  parent
  type_
  tensions_out
  tensions_in
  visibility
  mode
  rights
  isArchived
  isPersonal
  userCanJoin
  guestCanCreateTension
  children
  labels
  roles
  role_ext
  role_type
  color
  first_link
  second_link
  contracts
  watchers
  orga_agg
  events_history
}

input NodeMode_hash {
  eq: NodeMode
  in: [NodeMode]
}

input NodeOrder {
  asc: NodeOrderable
  desc: NodeOrderable
  then: NodeOrder
}

enum NodeOrderable {
  createdAt
  updatedAt
  nameid
  rootnameid
  name
  about
  rights
  color
}

input NodePatch {
  createdBy: UserRef @x_patch_ro
  createdAt: DateTime @x_patch_ro
  updatedAt: DateTime @x_patch_ro
  nameid: String @x_patch_ro
  rootnameid: String @x_patch_ro
  source: BlobRef @x_patch_ro
  name: String @x_patch_ro
  about: String @x_patch_ro
  skills: [String!] @x_patch_ro
  isRoot: Boolean @x_patch_ro
  parent: NodeRef @x_patch_ro
  type_: NodeType @x_patch_ro
  tensions_out: [TensionRef!] @x_patch_ro
  tensions_in: [TensionRef!] @x_patch_ro
  visibility: NodeVisibility @x_patch_ro
  mode: NodeMode @x_patch_ro
  rights: Int @x_patch_ro
  isArchived: Boolean @x_patch_ro
  isPersonal: Boolean @x_patch_ro
  userCanJoin: Boolean @x_patch_ro
  guestCanCreateTension: Boolean @x_patch_ro
  children: [NodeRef!] @x_patch_ro
  labels: [LabelRef!] @x_patch_ro
  roles: [RoleExtRef!] @x_patch_ro
  role_ext: RoleExtRef @x_patch_ro
  role_type: RoleType @x_patch_ro
  color: String @x_patch_ro
  first_link: UserRef @x_patch_ro
  second_link: UserRef @x_patch_ro
  contracts: [VoteRef!] @x_patch_ro
  watchers: [UserRef!] @x_patch_ro
  orga_agg: OrgaAggRef @x_patch_ro
  events_history: [EventRef!] @x_patch_ro
}

input NodeRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime
  updatedAt: DateTime
  nameid: String
  rootnameid: String
  source: BlobRef
  name: String
  about: String
  skills: [String!]
  isRoot: Boolean
  parent: NodeRef
  type_: NodeType
  tensions_out: [TensionRef!]
  tensions_in: [TensionRef!]
  visibility: NodeVisibility
  mode: NodeMode
  rights: Int
  isArchived: Boolean
  isPersonal: Boolean
  userCanJoin: Boolean
  guestCanCreateTension: Boolean
  children: [NodeRef!]
  labels: [LabelRef!]
  roles: [RoleExtRef!]
  role_ext: RoleExtRef
  role_type: RoleType
  color: String
  first_link: UserRef
  second_link: UserRef
  contracts: [VoteRef!]
  watchers: [UserRef!]
  orga_agg: OrgaAggRef
  events_history: [EventRef!]
}

input NodeType_hash {
  eq: NodeType
  in: [NodeType]
}

input NodeVisibility_hash {
  eq: NodeVisibility
  in: [NodeVisibility]
}

type NotifAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  messageMin: String
  messageMax: String
  linkMin: String
  linkMax: String
}

input NotifFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  has: [NotifHasFilter]
  and: [NotifFilter]
  or: [NotifFilter]
  not: NotifFilter
}

enum NotifHasFilter {
  createdBy
  createdAt
  updatedAt
  message
  tension_
  contract
  link
}

input NotifOrder {
  asc: NotifOrderable
  desc: NotifOrderable
  then: NotifOrder
}

enum NotifOrderable {
  createdAt
  updatedAt
  message
  link
}

input NotifPatch {
  createdBy: UserRef @x_patch_ro
  createdAt: DateTime @x_patch_ro
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_patch_ro
  tension_: TensionRef @x_patch_ro
  contract: ContractRef @x_patch_ro
  link: String @x_patch_ro
}

input NotifRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String
  tension_: TensionRef
  contract: ContractRef
  link: String
}

type OrgaAggAggregateResult {
  count: Int
  n_membersMin: Int
  n_membersMax: Int
  n_membersSum: Int
  n_membersAvg: Float
  n_guestsMin: Int
  n_guestsMax: Int
  n_guestsSum: Int
  n_guestsAvg: Float
}

input OrgaAggFilter {
  has: [OrgaAggHasFilter]
  and: [OrgaAggFilter]
  or: [OrgaAggFilter]
  not: OrgaAggFilter
}

enum OrgaAggHasFilter {
  n_members
  n_guests
}

input OrgaAggOrder {
  asc: OrgaAggOrderable
  desc: OrgaAggOrderable
  then: OrgaAggOrder
}

enum OrgaAggOrderable {
  n_members
  n_guests
}

input OrgaAggPatch {
  n_members: Int @x_patch_ro
  n_guests: Int @x_patch_ro
}

input OrgaAggRef {
  n_members: Int
  n_guests: Int
}

type PendingUserAggregateResult {
  count: Int
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  usernameMin: String
  usernameMax: String
  passwordMin: String
  passwordMax: String
  emailMin: String
  emailMax: String
  email_tokenMin: String
  email_tokenMax: String
  tokenMin: String
  tokenMax: String
}

input PendingUserFilter {
  id: [ID!]
  username: StringHashFilter
  email: StringHashFilter
  email_token: StringHashFilter
  token: StringHashFilter
  has: [PendingUserHasFilter]
  and: [PendingUserFilter]
  or: [PendingUserFilter]
  not: PendingUserFilter
}

enum PendingUserHasFilter {
  updatedAt
  username
  password
  email
  email_token
  token
  contracts
  subscribe
}

input PendingUserOrder {
  asc: PendingUserOrderable
  desc: PendingUserOrderable
  then: PendingUserOrder
}

enum PendingUserOrderable {
  updatedAt
  username
  password
  email
  email_token
  token
}

input PendingUserPatch {
  updatedAt: DateTime @x_patch_ro
  username: String @w_alter(a:"lower")
  password: String @x_patch_ro
  email: String @w_alter(a:"lower")
  email_token: String @x_patch_ro
  token: String @x_patch_ro
  contracts: [ContractRef!] @x_patch_ro
  subscribe: Boolean @x_patch_ro
}

input PendingUserRef {
  id: ID
  updatedAt: DateTime
  username: String @w_alter(a:"lower")
  password: String
  email: String @w_alter(a:"lower")
  email_token: String
  token: String
  contracts: [ContractRef!]
  subscribe: Boolean
}

type Point {
  longitude: Float!
  latitude: Float!
}

input PointGeoFilter {
  near: NearFilter
  within: WithinFilter
}

type PointList {
  points: [Point!]!
}

input PointListRef {
  points: [PointRef!]!
}

input PointRef {
  longitude: Float!
  latitude: Float!
}

type Polygon {
  coordinates: [PointList!]!
}

input PolygonGeoFilter {
  near: NearFilter
  within: WithinFilter
  contains: ContainsFilter
  intersects: IntersectsFilter
}

input PolygonRef {
  coordinates: [PointListRef!]!
}

type PostAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  messageMin: String
  messageMax: String
}

input PostFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  has: [PostHasFilter]
  and: [PostFilter]
  or: [PostFilter]
  not: PostFilter
}

enum PostHasFilter {
  createdBy
  createdAt
  updatedAt
  message
}

input PostOrder {
  asc: PostOrderable
  desc: PostOrderable
  then: PostOrder
}

enum PostOrderable {
  createdAt
  updatedAt
  message
}

input PostPatch {
  createdBy: UserRef @x_patch_ro
  createdAt: DateTime @x_patch_ro
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_alter(r:"isOwner", f:"createdBy")
}

input PostRef {
  id: ID!
}

type Query {
  getNode(id: ID, nameid: String): Node
  queryNode(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node]
  aggregateNode(filter: NodeFilter): NodeAggregateResult
  getNodeFragment(id: ID!): NodeFragment
  queryNodeFragment(filter: NodeFragmentFilter, order: NodeFragmentOrder, first: Int, offset: Int): [NodeFragment]
  aggregateNodeFragment(filter: NodeFragmentFilter): NodeFragmentAggregateResult
  getMandate(id: ID!): Mandate
  queryMandate(filter: MandateFilter, order: MandateOrder, first: Int, offset: Int): [Mandate]
  aggregateMandate(filter: MandateFilter): MandateAggregateResult
  getLabel(id: ID!): Label
  queryLabel(filter: LabelFilter @hook_queryLabelInput, order: LabelOrder, first: Int, offset: Int): [Label]
  aggregateLabel(filter: LabelFilter): LabelAggregateResult
  getRoleExt(id: ID!): RoleExt
  queryRoleExt(filter: RoleExtFilter @hook_queryRoleExtInput, order: RoleExtOrder, first: Int, offset: Int): [RoleExt]
  aggregateRoleExt(filter: RoleExtFilter): RoleExtAggregateResult
  queryOrgaAgg(filter: OrgaAggFilter, order: OrgaAggOrder, first: Int, offset: Int): [OrgaAgg]
  aggregateOrgaAgg(filter: OrgaAggFilter): OrgaAggAggregateResult
  getPost(id: ID!): Post
  queryPost(filter: PostFilter, order: PostOrder, first: Int, offset: Int): [Post]
  aggregatePost(filter: PostFilter): PostAggregateResult
  getTension(id: ID!): Tension
  queryTension(filter: TensionFilter @hook_queryTensionInput, order: TensionOrder, first: Int, offset: Int): [Tension]
  aggregateTension(filter: TensionFilter): TensionAggregateResult
  getComment(id: ID!): Comment
  queryComment(filter: CommentFilter @hook_queryCommentInput, order: CommentOrder, first: Int, offset: Int): [Comment]
  aggregateComment(filter: CommentFilter): CommentAggregateResult
  getReaction(id: ID, reactionid: String): Reaction
  queryReaction(filter: ReactionFilter @hook_queryReactionInput, order: ReactionOrder, first: Int, offset: Int): [Reaction]
  aggregateReaction(filter: ReactionFilter): ReactionAggregateResult
  getBlob(id: ID!): Blob
  queryBlob(filter: BlobFilter, order: BlobOrder, first: Int, offset: Int): [Blob]
  aggregateBlob(filter: BlobFilter): BlobAggregateResult
  getEvent(id: ID!): Event
  queryEvent(filter: EventFilter, order: EventOrder, first: Int, offset: Int): [Event]
  aggregateEvent(filter: EventFilter): EventAggregateResult
  queryEventFragment(filter: EventFragmentFilter, order: EventFragmentOrder, first: Int, offset: Int): [EventFragment]
  aggregateEventFragment(filter: EventFragmentFilter): EventFragmentAggregateResult
  getContract(id: ID, contractid: String): Contract
  queryContract(filter: ContractFilter @hook_queryContractInput, order: ContractOrder, first: Int, offset: Int): [Contract]
  aggregateContract(filter: ContractFilter): ContractAggregateResult
  getVote(id: ID, voteid: String): Vote
  queryVote(filter: VoteFilter @hook_queryVoteInput, order: VoteOrder, first: Int, offset: Int): [Vote]
  aggregateVote(filter: VoteFilter): VoteAggregateResult
  getUser(id: ID, username: String, email: String): User
  queryUser(filter: UserFilter @hook_queryUserInput, order: UserOrder, first: Int, offset: Int): [User]
  aggregateUser(filter: UserFilter): UserAggregateResult
  getPendingUser(id: ID, username: String, email: String): PendingUser
  queryPendingUser(filter: PendingUserFilter, order: PendingUserOrder, first: Int, offset: Int): [PendingUser]
  aggregatePendingUser(filter: PendingUserFilter): PendingUserAggregateResult
  queryUserRights(filter: UserRightsFilter, order: UserRightsOrder, first: Int, offset: Int): [UserRights]
  aggregateUserRights(filter: UserRightsFilter): UserRightsAggregateResult
  getUserEvent(id: ID!): UserEvent
  queryUserEvent(filter: UserEventFilter, order: UserEventOrder, first: Int, offset: Int): [UserEvent]
  aggregateUserEvent(filter: UserEventFilter): UserEventAggregateResult
  getNotif(id: ID!): Notif
  queryNotif(filter: NotifFilter, order: NotifOrder, first: Int, offset: Int): [Notif]
  aggregateNotif(filter: NotifFilter): NotifAggregateResult
  queryEventCount(filter: EventCountFilter, order: EventCountOrder, first: Int, offset: Int): [EventCount]
  aggregateEventCount(filter: EventCountFilter): EventCountAggregateResult
}

type ReactionAggregateResult {
  count: Int
  reactionidMin: String
  reactionidMax: String
  type_Min: Int
  type_Max: Int
  type_Sum: Int
  type_Avg: Float
}

input ReactionFilter {
  id: [ID!]
  reactionid: StringHashFilter
  has: [ReactionHasFilter]
  and: [ReactionFilter]
  or: [ReactionFilter]
  not: ReactionFilter
}

enum ReactionHasFilter {
  reactionid
  user
  comment
  type_
}

input ReactionOrder {
  asc: ReactionOrderable
  desc: ReactionOrderable
  then: ReactionOrder
}

enum ReactionOrderable {
  reactionid
  type_
}

input ReactionPatch {
  reactionid: String @x_patch_ro
  user: UserRef @x_patch_ro
  comment: CommentRef @x_patch_ro
  type_: Int @x_patch_ro
}

input ReactionRef {
  id: ID
  reactionid: String
  user: UserRef @x_add(r:"ref")
  comment: CommentRef @x_add(r:"ref")
  type_: Int
}

type RoleExtAggregateResult {
  count: Int
  rootnameidMin: String
  rootnameidMax: String
  nameMin: String
  nameMax: String
  aboutMin: String
  aboutMax: String
  colorMin: String
  colorMax: String
}

input RoleExtFilter {
  id: [ID!]
  rootnameid: StringHashFilter
  name: StringHashFilter_StringTermFilter
  has: [RoleExtHasFilter]
  and: [RoleExtFilter]
  or: [RoleExtFilter]
  not: RoleExtFilter
}

enum RoleExtHasFilter {
  rootnameid
  name
  about
  role_type
  color
  mandate
  roles
  nodes
}

input RoleExtOrder {
  asc: RoleExtOrderable
  desc: RoleExtOrderable
  then: RoleExtOrder
}

enum RoleExtOrderable {
  rootnameid
  name
  about
  color
}

input RoleExtPatch {
  rootnameid: String @x_patch_ro
  name: String @w_alter(a:"lower") @x_alter(r:"unique", f:"rootnameid") @x_alter(r:"minLen", n:1)
  about: String @x_alter(r:"maxLen", n:280)
  role_type: RoleType @x_alter
  color: String @x_alter
  mandate: MandateRef @x_alter
  roles: [NodeRef!] @x_ro
  nodes: [NodeRef!] @x_alter(r:"oneByOne") @x_alter(r:"ref")
}

input RoleExtRef {
  id: ID
  rootnameid: String
  name: String @w_alter(a:"lower") @x_alter(r:"unique", f:"rootnameid") @x_alter(r:"minLen", n:1)
  about: String @x_alter(r:"maxLen", n:280)
  role_type: RoleType @x_alter
  color: String @x_alter
  mandate: MandateRef @x_alter
  roles: [NodeRef!] @x_ro
  nodes: [NodeRef!] @x_alter(r:"oneByOne") @x_alter(r:"ref")
}

input RoleType_hash {
  eq: RoleType
  in: [RoleType]
}

input StringExactFilter {
  eq: String
  in: [String]
  le: String
  lt: String
  ge: String
  gt: String
  between: StringRange
}

input StringFullTextFilter {
  alloftext: String
  anyoftext: String
}

input StringHashFilter {
  eq: String
  in: [String]
}

input StringHashFilter_StringRegExpFilter {
  eq: String
  in: [String]
  regexp: String
}

input StringHashFilter_StringTermFilter {
  eq: String
  in: [String]
  allofterms: String
  anyofterms: String
}

input StringRange {
  min: String!
  max: String!
}

input StringRegExpFilter {
  regexp: String
}

input StringTermFilter {
  allofterms: String
  anyofterms: String
}

type TensionAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  messageMin: String
  messageMax: String
  emitteridMin: String
  emitteridMax: String
  receiveridMin: String
  receiveridMax: String
  titleMin: String
  titleMax: String
  n_commentsMin: Int
  n_commentsMax: Int
  n_commentsSum: Int
  n_commentsAvg: Float
  n_open_contractsMin: Int
  n_open_contractsMax: Int
  n_open_contractsSum: Int
  n_open_contractsAvg: Float
}

input TensionEvent_hash {
  eq: TensionEvent
  in: [TensionEvent]
}

input TensionFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  emitterid: StringHashFilter_StringRegExpFilter
  receiverid: StringHashFilter_StringRegExpFilter
  title: StringFullTextFilter
  type_: TensionType_hash
  status: TensionStatus_hash
  has: [TensionHasFilter]
  and: [TensionFilter]
  or: [TensionFilter]
  not: TensionFilter
}

enum TensionHasFilter {
  createdBy
  createdAt
  updatedAt
  message
  emitter
  emitterid
  receiver
  receiverid
  title
  type_
  status
  action
  comments
  assignees
  labels
  blobs
  history
  mentions
  contracts
  subscribers
  n_comments
  n_open_contracts
}

input TensionOrder {
  asc: TensionOrderable
  desc: TensionOrderable
  then: TensionOrder
}

enum TensionOrderable {
  createdAt
  updatedAt
  message
  emitterid
  receiverid
  title
  n_comments
  n_open_contracts
}

input TensionPatch {
  createdBy: UserRef @x_patch_ro
  createdAt: DateTime @x_patch_ro
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_patch_ro
  emitter: NodeRef @x_patch_ro
  emitterid: String @x_patch_ro
  receiver: NodeRef @x_patch_ro
  receiverid: String @x_patch_ro
  title: String @x_patch_ro
  type_: TensionType @x_alter(r:"tensionTypeCheck")
  status: TensionStatus @x_patch_ro
  action: TensionAction @x_patch_ro
  comments: [CommentRef!] @x_alter(r:"hasEvent", e:[Created, CommentPushed]) @x_alter(r:"oneByOne")
  assignees: [UserRef!] @x_alter(r:"hasEvent", e:[AssigneeAdded, AssigneeRemoved]) @x_alter(r:"oneByOne") @x_alter(r:"ref")
  labels: [LabelRef!] @x_alter(r:"hasEvent", e:[LabelAdded, LabelRemoved]) @x_alter(r:"oneByOne") @x_alter(r:"ref")
  blobs: [BlobRef!] @x_alter(r:"hasEvent", e:[BlobCreated, BlobCommitted]) @x_alter(r:"oneByOne")
  history: [EventRef!] @x_alter
  mentions: [EventRef!] @x_patch_ro
  contracts: [ContractRef!] @x_patch_ro
  subscribers: [UserRef!] @x_patch_ro
  n_comments: Int @x_patch_ro
  n_open_contracts: Int @x_patch_ro
}

input TensionRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String
  emitter: NodeRef
  emitterid: String
  receiver: NodeRef
  receiverid: String
  title: String
  type_: TensionType @x_alter(r:"tensionTypeCheck")
  status: TensionStatus
  action: TensionAction
  comments: [CommentRef!] @x_alter(r:"hasEvent", e:[Created, CommentPushed]) @x_alter(r:"oneByOne")
  assignees: [UserRef!] @x_alter(r:"hasEvent", e:[AssigneeAdded, AssigneeRemoved]) @x_alter(r:"oneByOne") @x_alter(r:"ref")
  labels: [LabelRef!] @x_alter(r:"hasEvent", e:[LabelAdded, LabelRemoved]) @x_alter(r:"oneByOne") @x_alter(r:"ref")
  blobs: [BlobRef!] @x_alter(r:"hasEvent", e:[BlobCreated, BlobCommitted]) @x_alter(r:"oneByOne")
  history: [EventRef!] @x_alter
  mentions: [EventRef!]
  contracts: [ContractRef!] @x_add(r:"ref")
  subscribers: [UserRef!]
  n_comments: Int
  n_open_contracts: Int
}

input TensionStatus_hash {
  eq: TensionStatus
  in: [TensionStatus]
}

input TensionType_hash {
  eq: TensionType
  in: [TensionType]
}

input UpdateBlobInput {
  filter: BlobFilter!
  set: BlobPatch
  remove: BlobPatch
}

type UpdateBlobPayload {
  blob(filter: BlobFilter, order: BlobOrder, first: Int, offset: Int): [Blob]
  numUids: Int
}

input UpdateCommentInput {
  filter: CommentFilter!
  set: CommentPatch
  remove: CommentPatch
}

type UpdateCommentPayload {
  comment(filter: CommentFilter, order: CommentOrder, first: Int, offset: Int): [Comment]
  numUids: Int
}

input UpdateContractInput {
  filter: ContractFilter!
  set: ContractPatch
  remove: ContractPatch
}

type UpdateContractPayload {
  contract(filter: ContractFilter, order: ContractOrder, first: Int, offset: Int): [Contract]
  numUids: Int
}

input UpdateEventCountInput {
  filter: EventCountFilter!
  set: EventCountPatch
  remove: EventCountPatch
}

type UpdateEventCountPayload {
  eventCount(filter: EventCountFilter, order: EventCountOrder, first: Int, offset: Int): [EventCount]
  numUids: Int
}

input UpdateEventFragmentInput {
  filter: EventFragmentFilter!
  set: EventFragmentPatch
  remove: EventFragmentPatch
}

type UpdateEventFragmentPayload {
  eventFragment(filter: EventFragmentFilter, order: EventFragmentOrder, first: Int, offset: Int): [EventFragment]
  numUids: Int
}

input UpdateEventInput {
  filter: EventFilter!
  set: EventPatch
  remove: EventPatch
}

type UpdateEventPayload {
  event(filter: EventFilter, order: EventOrder, first: Int, offset: Int): [Event]
  numUids: Int
}

input UpdateLabelInput {
  filter: LabelFilter!
  set: LabelPatch
  remove: LabelPatch
}

type UpdateLabelPayload {
  label(filter: LabelFilter, order: LabelOrder, first: Int, offset: Int): [Label]
  numUids: Int
}

input UpdateMandateInput {
  filter: MandateFilter!
  set: MandatePatch
  remove: MandatePatch
}

type UpdateMandatePayload {
  mandate(filter: MandateFilter, order: MandateOrder, first: Int, offset: Int): [Mandate]
  numUids: Int
}

input UpdateNodeFragmentInput {
  filter: NodeFragmentFilter!
  set: NodeFragmentPatch
  remove: NodeFragmentPatch
}

type UpdateNodeFragmentPayload {
  nodeFragment(filter: NodeFragmentFilter, order: NodeFragmentOrder, first: Int, offset: Int): [NodeFragment]
  numUids: Int
}

input UpdateNodeInput {
  filter: NodeFilter!
  set: NodePatch
  remove: NodePatch
}

type UpdateNodePayload {
  node(filter: NodeFilter, order: NodeOrder, first: Int, offset: Int): [Node]
  numUids: Int
}

input UpdateNotifInput {
  filter: NotifFilter!
  set: NotifPatch
  remove: NotifPatch
}

type UpdateNotifPayload {
  notif(filter: NotifFilter, order: NotifOrder, first: Int, offset: Int): [Notif]
  numUids: Int
}

input UpdateOrgaAggInput {
  filter: OrgaAggFilter!
  set: OrgaAggPatch
  remove: OrgaAggPatch
}

type UpdateOrgaAggPayload {
  orgaAgg(filter: OrgaAggFilter, order: OrgaAggOrder, first: Int, offset: Int): [OrgaAgg]
  numUids: Int
}

input UpdatePendingUserInput {
  filter: PendingUserFilter!
  set: PendingUserPatch
  remove: PendingUserPatch
}

type UpdatePendingUserPayload {
  pendingUser(filter: PendingUserFilter, order: PendingUserOrder, first: Int, offset: Int): [PendingUser]
  numUids: Int
}

input UpdatePostInput {
  filter: PostFilter!
  set: PostPatch
  remove: PostPatch
}

type UpdatePostPayload {
  post(filter: PostFilter, order: PostOrder, first: Int, offset: Int): [Post]
  numUids: Int
}

input UpdateReactionInput {
  filter: ReactionFilter!
  set: ReactionPatch
  remove: ReactionPatch
}

type UpdateReactionPayload {
  reaction(filter: ReactionFilter, order: ReactionOrder, first: Int, offset: Int): [Reaction]
  numUids: Int
}

input UpdateRoleExtInput {
  filter: RoleExtFilter!
  set: RoleExtPatch
  remove: RoleExtPatch
}

type UpdateRoleExtPayload {
  roleExt(filter: RoleExtFilter, order: RoleExtOrder, first: Int, offset: Int): [RoleExt]
  numUids: Int
}

input UpdateTensionInput {
  filter: TensionFilter!
  set: TensionPatch
  remove: TensionPatch
}

type UpdateTensionPayload {
  tension(filter: TensionFilter, order: TensionOrder, first: Int, offset: Int): [Tension]
  numUids: Int
}

input UpdateUserEventInput {
  filter: UserEventFilter!
  set: UserEventPatch
  remove: UserEventPatch
}

type UpdateUserEventPayload {
  userEvent(filter: UserEventFilter, order: UserEventOrder, first: Int, offset: Int): [UserEvent]
  numUids: Int
}

input UpdateUserInput {
  filter: UserFilter!
  set: UserPatch
  remove: UserPatch
}

type UpdateUserPayload {
  user(filter: UserFilter, order: UserOrder, first: Int, offset: Int): [User]
  numUids: Int
}

input UpdateUserRightsInput {
  filter: UserRightsFilter!
  set: UserRightsPatch
  remove: UserRightsPatch
}

type UpdateUserRightsPayload {
  userRights(filter: UserRightsFilter, order: UserRightsOrder, first: Int, offset: Int): [UserRights]
  numUids: Int
}

input UpdateVoteInput {
  filter: VoteFilter!
  set: VotePatch
  remove: VotePatch
}

type UpdateVotePayload {
  vote(filter: VoteFilter, order: VoteOrder, first: Int, offset: Int): [Vote]
  numUids: Int
}

type UserAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  lastAckMin: DateTime
  lastAckMax: DateTime
  usernameMin: String
  usernameMax: String
  nameMin: String
  nameMax: String
  emailMin: String
  emailMax: String
  passwordMin: String
  passwordMax: String
  bioMin: String
  bioMax: String
  locationMin: String
  locationMax: String
  utcMin: String
  utcMax: String
  markAllAsReadMin: String
  markAllAsReadMax: String
}

type UserEventAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
}

input UserEventFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  isRead: Boolean
  has: [UserEventHasFilter]
  and: [UserEventFilter]
  or: [UserEventFilter]
  not: UserEventFilter
}

enum UserEventHasFilter {
  createdAt
  isRead
  user
  event
}

input UserEventOrder {
  asc: UserEventOrderable
  desc: UserEventOrderable
  then: UserEventOrder
}

enum UserEventOrderable {
  createdAt
}

input UserEventPatch {
  createdAt: DateTime @x_patch_ro
  isRead: Boolean @x_alter
  user: UserRef @x_patch_ro
  event: [EventKindRef!] @x_patch_ro
}

input UserEventRef {
  id: ID
  createdAt: DateTime
  isRead: Boolean @x_alter
  user: UserRef
  event: [EventKindRef!] @x_add(r:"ref")
}

input UserFilter {
  id: [ID!]
  username: StringHashFilter_StringRegExpFilter
  name: StringRegExpFilter
  email: StringHashFilter
  has: [UserHasFilter]
  and: [UserFilter]
  or: [UserFilter]
  not: UserFilter
}

enum UserHasFilter {
  createdAt
  lastAck
  username
  name
  email
  password
  bio
  location
  utc
  links
  skills
  notifyByEmail
  lang
  subscriptions
  watching
  rights
  roles
  backed_roles
  tensions_created
  tensions_assigned
  contracts
  reactions
  events
  markAllAsRead
  event_count
}

input UserOrder {
  asc: UserOrderable
  desc: UserOrderable
  then: UserOrder
}

enum UserOrderable {
  createdAt
  lastAck
  username
  name
  email
  password
  bio
  location
  utc
  markAllAsRead
}

input UserPatch {
  createdAt: DateTime @x_patch_ro
  lastAck: DateTime @x_patch_ro
  username: String @x_patch_ro
  name: String @x_patch
  email: String @x_patch_ro
  password: String @x_patch_ro
  bio: String @x_patch @x_alter(r:"maxLen", n:280)
  location: String @x_patch
  utc: String @x_patch
  links: [String!] @x_patch
  skills: [String!] @x_patch
  notifyByEmail: Boolean @x_patch
  lang: Lang @x_patch
  subscriptions: [TensionRef!] @x_patch @x_alter(r:"ref")
  watching: [NodeRef!] @x_patch @x_alter(r:"ref")
  rights: UserRightsRef @x_patch_ro
  roles: [NodeRef!] @x_patch_ro
  backed_roles: [NodeRef!] @x_patch_ro
  tensions_created: [TensionRef!] @x_patch_ro
  tensions_assigned: [TensionRef!] @x_patch_ro
  contracts: [ContractRef!] @x_patch_ro
  reactions: [ReactionRef!] @x_alter
  events: [UserEventRef!] @x_alter
  markAllAsRead: String @w_meta_patch(f:"markAllAsRead", k:"username") @x_alter
  event_count: EventCountRef @x_patch_ro
}

input UserRef {
  id: ID
  createdAt: DateTime
  lastAck: DateTime
  username: String @w_add(a:"lower")
  name: String @x_patch
  email: String @w_add(a:"lower")
  password: String
  bio: String @x_patch @x_alter(r:"maxLen", n:280)
  location: String @x_patch
  utc: String @x_patch
  links: [String!] @x_patch
  skills: [String!] @x_patch
  notifyByEmail: Boolean @x_patch
  lang: Lang @x_patch
  subscriptions: [TensionRef!] @x_patch @x_alter(r:"ref")
  watching: [NodeRef!] @x_patch @x_alter(r:"ref")
  rights: UserRightsRef
  roles: [NodeRef!] @x_add(r:"ref")
  backed_roles: [NodeRef!] @x_add(r:"ref")
  tensions_created: [TensionRef!] @x_add(r:"ref")
  tensions_assigned: [TensionRef!] @x_add(r:"ref")
  contracts: [ContractRef!] @x_add(r:"ref")
  reactions: [ReactionRef!] @x_alter
  events: [UserEventRef!] @x_alter
  markAllAsRead: String @w_meta_patch(f:"markAllAsRead", k:"username") @x_alter
  event_count: EventCountRef
}

type UserRightsAggregateResult {
  count: Int
  maxPublicOrgaMin: Int
  maxPublicOrgaMax: Int
  maxPublicOrgaSum: Int
  maxPublicOrgaAvg: Float
  maxPrivateOrgaMin: Int
  maxPrivateOrgaMax: Int
  maxPrivateOrgaSum: Int
  maxPrivateOrgaAvg: Float
}

input UserRightsFilter {
  has: [UserRightsHasFilter]
  and: [UserRightsFilter]
  or: [UserRightsFilter]
  not: UserRightsFilter
}

enum UserRightsHasFilter {
  type_
  canLogin
  canCreateRoot
  maxPublicOrga
  maxPrivateOrga
  hasEmailNotifications
}

input UserRightsOrder {
  asc: UserRightsOrderable
  desc: UserRightsOrderable
  then: UserRightsOrder
}

enum UserRightsOrderable {
  maxPublicOrga
  maxPrivateOrga
}

input UserRightsPatch {
  type_: UserType @x_patch_ro
  canLogin: Boolean @x_patch_ro
  canCreateRoot: Boolean @x_patch_ro
  maxPublicOrga: Int @x_patch_ro
  maxPrivateOrga: Int @x_patch_ro
  hasEmailNotifications: Boolean @x_patch_ro
}

input UserRightsRef {
  type_: UserType
  canLogin: Boolean
  canCreateRoot: Boolean
  maxPublicOrga: Int
  maxPrivateOrga: Int
  hasEmailNotifications: Boolean
}

type VoteAggregateResult {
  count: Int
  createdAtMin: DateTime
  createdAtMax: DateTime
  updatedAtMin: DateTime
  updatedAtMax: DateTime
  messageMin: String
  messageMax: String
  voteidMin: String
  voteidMax: String
}

input VoteFilter {
  id: [ID!]
  createdAt: DateTimeFilter
  message: StringFullTextFilter
  voteid: StringHashFilter
  has: [VoteHasFilter]
  and: [VoteFilter]
  or: [VoteFilter]
  not: VoteFilter
}

enum VoteHasFilter {
  createdBy
  createdAt
  updatedAt
  message
  voteid
  contract
  node
  data
}

input VoteOrder {
  asc: VoteOrderable
  desc: VoteOrderable
  then: VoteOrder
}

enum VoteOrderable {
  createdAt
  updatedAt
  message
  voteid
}

input VotePatch {
  createdBy: UserRef @x_patch_ro
  createdAt: DateTime @x_patch_ro
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String @x_patch_ro
  voteid: String @x_patch_ro
  contract: ContractRef @x_patch_ro
  node: NodeRef @x_patch_ro
  data: [Int!] @x_patch_ro
}

input VoteRef {
  id: ID
  createdBy: UserRef
  createdAt: DateTime
  updatedAt: DateTime @x_alter(r:"isOwner", f:"createdBy")
  message: String
  voteid: String
  contract: ContractRef @x_add(r:"ref")
  node: NodeRef @x_add(r:"ref")
  data: [Int!]
}

input WithinFilter {
  polygon: PolygonRef!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
